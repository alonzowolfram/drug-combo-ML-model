---
title: "Data processing"
output: html_notebook
---

# Setup
```{r eval=TRUE, include=FALSE}
source("Scripts/setup.R")
```

# GTEx

# NCI-60
## Expression: normalization
### GSE32474
```{r}
# Create a file to hold the error messages for this GEO data set. 
GSE = "GSE32474"
GSE_error_file_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "GEO",
  data_type = "Logs",
  processing_stage = "Processed"
), paste0(GSE, "_", preprocessing_method, "_", id_type, "_error_log.txt"))
file.create(GSE_error_file_filename)

# Read in the GSE metadata file. 
GSE_metadata_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "GEO",
  data_type = "Metadata",
  processing_stage = "Raw"
), "GEO_GSE_metadata.csv")
GSE_metadata = read.csv(GSE_metadata_filename)

# Set annotation variables.
GPL = as.character(GSE_metadata[GSE_metadata$GSE==GSE,"AnnotationDB"])
annotation = as.character(GSE_metadata[GSE_metadata$GSE==GSE,"Annotation"])
  
possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
  {
    # Read in the raw data and BG correct.
    if(GSE %in% c("GSE39345")) {
      exprs_bgcorrected = processLumi(GSE, is_GSE = T, filename_list = filename_list)
    } else {
      exprs_bgcorrected = processAffy(GSE, is_GSE = T, filename_list = filename_list)
    }
    # Perform log2 transformation. 
    exprs_log2 = log2transform(exprs_bgcorrected)
    # Perform YuGene normalization.
    exprs_YuGene = YuGene(exprs_log2)
    exprs_YuGene = exprs_YuGene[1:nrow(exprs_YuGene),1:ncol(exprs_YuGene)] # This step is needed because apparently YuGene() returns a 'YuGene' object, not a matrix, and using colnames() does something funky
      
  }, error=function(cond) {
    message(paste0("There was a problem processing GEO set ", GSE, ". Skipping this set."))
    message(cond)
  }
)
if(inherits(possibleError, "error")) {
  print(paste0("There was a problem processing GEO set ", GSE, ". Skipping this set."))
    
  # Write the error to the appropriate file. 
  fileConn = file(GSE_error_file_filename)
  writeLines(paste0("There was a problem processing GEO set ", GSE, ". Skipping this set."), fileConn)
  close(fileConn)
    
} 

# if(!exists("eset")) next
# Don't think we need this line for right now. ... 

# Annotate the probes.
if(GSE %in% c("GSE39345")) {
      exprs_annotated = annotateLumi(GSE, exprs_YuGene)
} else {
      exprs_annotated = annotateAffy(GSE, exprs_YuGene, GPL, annotation)
}

eset = getGEO(GSE)[[1]] # We will need the pData from getGEO.
# Remove suffixes etc. from the sample names. 
sampleNames(eset) = base::gsub("\\..*$", "", sampleNames(eset))
sampleNames(eset) = base::gsub("_.*$", "", sampleNames(eset))
    
# Set the expression matrix of the eset to be exprs. 
# For this one, since we're not just subsetting, we're creating an entirely new matrix, we will have to ... rebuild the eset. 囧rz
pData = pData(eset)
complete_samples = intersect(rownames(pData), colnames(exprs_annotated))
pData = pData[rownames(pData) %in% complete_samples,,drop=F]
exprs_annotated = exprs_annotated[,colnames(exprs_annotated) %in% complete_samples,drop=F]
pData = pData[order(rownames(pData)),,drop=F] # Default for order() is ascending, which is what we want. 
exprs_annotated = exprs_annotated[,order(colnames(exprs_annotated)),drop=F]
experimentData = experimentData(eset)
    
# Make sure exprs has the correct row and column names. 
if(identical(colnames(exprs_annotated), rownames(pData))) {
  rm(eset)
  eset = ExpressionSet(assayData=exprs_annotated, phenoData=as(pData, "AnnotatedDataFrame"), experimentData=experimentData, annotation=annotation)

  # Save the eset.
  eset_filename = filename_generator(data_dir = data_dir, data_source = "GEO", data_type = "Esets", extension = ".rds", data_set = GSE, processing_stage = "intermed_1", processing = preprocessing_type, gene_identifier = id_type, full_path = T) # intermed_1 because we're going to clean it up later. 
  saveRDS(eset, eset_filename)

  # Write to the appropriate log file. 
  fileConn = file(GSE_error_file_filename)
  writeLines(paste0("No errors for GEO set ", GSE, "."), fileConn)
  close(fileConn)
    
} else {
  # Write the error to the appropriate log file. 
  fileConn = file(GSE_error_file)
  writeLines(paste0("Columns of the expression matrix and the column names of the expression matrix in the eset for ", GSE, " do not match. Skipping this data set."), fileConn)
  close(fileConn)
}
```

### MDA-MB-468 from GDSC
```{r}
# Load the GSE32474 eset if not loaded already. 
eset = readRDS(filename_generator(data_dir = data_dir, data_source = "GEO", data_type = "Esets", extension = ".rds", data_set = "GSE32474", processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T))
# Load GDSC cell-line metadata file.
CCLE_cell_lines_metadata_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "CCLE",
  data_type = "Metadata",
  processing_stage = "Raw"
), "E-MTAB-3610.sdrf.csv")
CCLE_cell_lines = read.csv(CCLE_cell_lines_metadata_filename)
# Read in the GSE metadata file. 
GSE_metadata_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "GEO",
  data_type = "Metadata",
  processing_stage = "Raw"
), "GEO_GSE_metadata.csv")
GSE_metadata = read.csv(GSE_metadata_filename)
# Standardize GDSC cell-line names (all caps, no punctuation.)
CCLE_cell_lines$Characteristics.cell.line. = toupper(base::gsub("[[:punct:]]|[[:space:]]", "", CCLE_cell_lines$Characteristics.cell.line.))

# Set the annotation variables.
GSE = "GDSC"
GPL = as.character(GSE_metadata[GSE_metadata$GSE==GSE,"AnnotationDB"])
annotation = as.character(GSE_metadata[GSE_metadata$GSE==GSE,"Annotation"])

# For each cell line in cell_viability, find corresponding .cel file using CCLE_cell_lines. 
# Then find the folder that .cel file is in. 
tmp_dir_name = "outputDirectory"
tmp_dir_path = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "CCLE",
  data_type = "Expression",
  processing_stage = "Raw"
), tmp_dir_name)
unlink(tmp_dir_path) # Remove all the files in the temporary directory.   
if(!file.exists(tmp_dir_path)){
    dir.create(tmp_dir_path)
} 
  
raw_files = list.files(path = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "CCLE",
  data_type = "Expression",
  processing_stage = "Raw"
)), all.files = FALSE,
           full.names = T, recursive = T,
           ignore.case = T, include.dirs = T)
for(cell_line in c("MDAMB468")) {
  # Get the .cel file. 
  cel_file_name = as.character(CCLE_cell_lines[CCLE_cell_lines$Characteristics.cell.line.==cell_line,"Array.Data.File"])
  
  # Get the full path to the .cel file. 
  cel_file_path = raw_files[base::grep(cel_file_name, raw_files)] # There should only be one match. ...
  
  # Copy that file to the temporary directory. 
  file.copy(cel_file_path, tmp_dir_path)
}

# Process the raw files using YuGene.
exprs_bgcorrected = processAffy(tmp_dir_path, is_GSE = F) # Perform background correction using Affy. 
exprs_log2 = log2transform(exprs_bgcorrected) # Perform log2 transformation. 
exprs_YuGene = YuGene(exprs_log2) # Perform YuGene normalization.
exprs_YuGene = exprs_YuGene[1:nrow(exprs_YuGene),1:ncol(exprs_YuGene),drop=F] # This step is needed because apparently YuGene() returns a 'YuGene' object, not a matrix, and using colnames() does something funky
# Read in the .cel files using UPC. 
#eset_MDAMB468 = UPC(paste0(tmp_dir_path, "/*.cel"), outFilePath = NA, convThreshold = 0.001, verbose = TRUE)

# Remove the temporary directory. 
system(paste0("rm -r ", tmp_dir_path))

# Save to an RDS file. (It won't be an eset yet.)
GSE_temp = "CCLE_MDA-MB-468"
exprs_YuGene_filename = filename_generator(data_dir = data_dir, data_source = "CCLE", data_type = "Expression", extension = ".rds", sample = "MDA-MB-468", processing_stage = "intermed_1", processing = preprocessing_type, gene_identifier = id_type, full_path = T)
saveRDS(exprs_YuGene, exprs_YuGene_filename)

# Change the sample name to be the cell line (MDA-MB-468.) 
#sampleNames(eset_MDAMB468)[1] = "MDA-MB-468"
colnames(exprs_YuGene)[1] = "MDA-MB-468"

# We don't need to remove the suffixes since we will be converting the probeset/probes to ENTREZ IDs ourselves, and the databases (hgu133plus2.db etc.) have the full probeset/probe names including the suffixes.
# We do have to remove the AFFX probesets, though.
exprs_YuGene = exprs_YuGene[!base::grepl("AFFX", rownames(exprs_YuGene)),,drop=F]

# Annotate the probes.
if(GSE %in% c("GSE39345")) {
      exprs_annotated = annotateLumi(GSE, exprs_YuGene)
} else {
      exprs_annotated = annotateAffy(GSE, exprs_YuGene, GPL, annotation)
}

# Set the expression matrix of the eset_MDAMB468 to be exprs. 
# For this one, since we're not just subsetting, we're creating an entirely new matrix, we will have to ... rebuild the eset_MDAMB468. 囧rz
pData = data.frame(CellLine="MDA-MB-468")
rownames(pData) = c("MDA-MB-468")
experimentData = experimentData(eset) 
colnames(exprs_annotated) = "MDA-MB-468"
eset_MDAMB468 = ExpressionSet(assayData=exprs_annotated, phenoData=as(pData, "AnnotatedDataFrame"), experimentData=experimentData, annotation=annotation)

# Save eset_MDAMB468.
eset_MDAMB468_filename = filename_generator(data_dir = data_dir, data_source = "CCLE", data_type = "Esets", extension = ".rds", sample = "MDA-MB-468", processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T)
saveRDS(eset_MDAMB468, eset_MDAMB468_filename)

```

## Expression: cleaning
```{r}
if(!file.exists(filename_generator(data_dir = data_dir, data_source = "GEO", data_type = "Esets", extension = ".rds", data_set = GSE, processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T))) {
  # Read in the eset for GSE32474 (the NCI-60 panel.)
  GSE32474 = readRDS(filename_generator(data_dir = data_dir, data_source = "GEO", data_type = "Esets", extension = ".rds", data_set = GSE, processing_stage = "intermed_1", processing = preprocessing_type, gene_identifier = id_type, full_path = T))

  # Clean up the names of the cell lines to match those in the ALMANAC data set. 
  # Standardize the cell-line names.
  nci60_names = read.csv(paste0(folder_generator(
  data_dir = data_dir,
  data_source = "NCI-60",
  data_type = "Metadata",
  processing_stage = "Processed"
), "NCI-60_cell_line_names_ALMANAC_GEO_GDSC_CCLE.csv"), colClasses = rep("character", 5)) # Maps the different cell line names to the standardized names.

  # Clean up the names of the columns in the pData.
  colnames(pData(GSE32474)) = base::gsub(":.+$", "", colnames(pData(GSE32474)))
  colnames(pData(GSE32474)) = base::gsub("[[:space:]]", "_", colnames(pData(GSE32474)))
  
  # Replace a with b. 
  a = nci60_names$GEO_name
  b = nci60_names$Standardized_name
  names(b) = a
  pData(GSE32474)$cell_line =  b[match(pData(GSE32474)$cell_line, a)]
  sum(is.na(unique(pData(GSE32474)$cell_line)))

  # Merge the triplicated cell lines.
  # First order the pData so that all the triplicate cell lines are together.
  pData(GSE32474) = pData(GSE32474)[order(pData(GSE32474)$cell_line),,drop=FALSE]
  # That will also arrange the GEO accession numbers.
  # Convert geo_accession field to strings for when we order the expression matrix according to the new order of the GEO accession numbers in the pData.
  pData(GSE32474)$geo_accession = as.character(pData(GSE32474)$geo_accession) # From factor to character.
  # Order the columns of the expression matrix to match the new order of the samples in the pData table.
  exprs(GSE32474) = exprs(GSE32474)[,pData(GSE32474)$geo_accession,drop=FALSE]
  identical(colnames(Biobase::exprs(GSE32474)), pData(GSE32474)$geo_accession)
  # Now that the columns of the expression matrix are in the same order as the GEO accession numbers (and therefore the cell line names) in the pData, we can add the cell line names as a new row to the expression matrix. 
  pData(GSE32474)$cell_line = as.character(pData(GSE32474)$cell_line)
  # Set the column names of the expression matrix to be cell lines instead of GEO accession numbers.
  # We will have to extract the expression matrix as a separate variable and then re-assemble the expression set object. :(
  exprs_GSE32474 = exprs(GSE32474)
  colnames(exprs_GSE32474) = pData(GSE32474)$cell_line # Change the column names to the cell lines.
  exprs_GSE32474_rownames = rownames(exprs_GSE32474) # Save the rownames because the following step apparently screws things up.
  exprs_GSE32474 = sapply(unique(colnames(exprs_GSE32474)), function(x) rowMedians(exprs_GSE32474[,base::grepl(x, colnames(exprs_GSE32474))])) # https://stackoverflow.com/a/42098786
  exprs_GSE32474 = exprs_GSE32474[, !duplicated(colnames(exprs_GSE32474)), drop=FALSE] # https://stackoverflow.com/a/24143055
  rownames(exprs_GSE32474) = exprs_GSE32474_rownames # DOUBLE-CHECK THAT THIS IS CORRECT!

  # Re-assemble the eset.
  pData_GSE32474 = pData(GSE32474)[!duplicated(pData(GSE32474)$cell_line), ]
  identical(colnames(exprs_GSE32474), pData_GSE32474$cell_line)

  rownames(pData_GSE32474) = colnames(exprs_GSE32474)
  experimentData_GSE32474 = experimentData(GSE32474)
  rm(GSE32474)
  GSE32474 = ExpressionSet(assayData=exprs_GSE32474, phenoData=as(pData_GSE32474, "AnnotatedDataFrame"), experimentData=experimentData_GSE32474, annotation="hgu133plus2")

  # Save eset.
  GSE32474_filename = filename_generator(data_dir = data_dir, data_source = "GEO", data_type = "Esets", extension = ".rds", data_set = GSE, processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T)
  saveRDS(GSE32474, GSE32474_filename)
  # At this point, the eset has no duplicated Entrez IDs and no duplicated probes. The genes have not been filtered by variance or correlation. 

  # Extract the expression data.
  exprs = exprs(GSE32474)
  
} else {
   GSE32474 = readRDS(filename_generator(data_dir = data_dir, data_source = "GEO", data_type = "Esets", extension = ".rds", data_set = GSE, processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T))
   exprs = exprs(GSE32474)
   
}

# Create the final NCI-60 eset (GSE32474 + MDA-MB-468.)
eset_MDAMB468_filename = filename_generator(data_dir = data_dir, data_source = "CCLE", data_type = "Esets", extension = ".rds", sample = "MDA-MB-468", processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T)
if(!exists("eset_MDAMB468")) eset_MDAMB468 = readRDS(eset_MDAMB468_filename)
exprs_MDAMB468 = exprs(eset_MDAMB468)

common_genes = intersect(rownames(exprs), rownames(exprs_MDAMB468))
exprs = exprs[rownames(exprs) %in% common_genes,,drop=F]
exprs_MDAMB468 = exprs_MDAMB468[rownames(exprs_MDAMB468) %in% common_genes,,drop=F]
exprs = exprs[order(rownames(exprs)),,drop=F]
exprs_MDAMB468 = exprs_MDAMB468[order(rownames(exprs_MDAMB468)),,drop=F]
if(identical(rownames(exprs), rownames(exprs_MDAMB468))) exprs_NCI60 = cbind(exprs, exprs_MDAMB468)

exprs_NCI60_filename = filename_generator(data_dir = data_dir, data_source = "NCI-60", data_type = "Expression", extension = ".rds", processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T)
saveRDS(exprs_NCI60, exprs_NCI60_filename)
```

## Expression: differential expression
```{r}
NCI60_cancer_types_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "NCI-60",
  data_type = "Metadata",
  processing_stage = "Processed"
), "NCI-60_cancer_types.csv")
NCI60_cancer_types = read.csv(NCI60_cancer_types_filename)

exprs_NCI60_filename = filename_generator(data_dir = data_dir, data_source = "NCI-60", data_type = "Expression", extension = ".rds", processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T)
exprs_NCI60 = readRDS(exprs_NCI60_filename)
  
# Load deg_list if it exists. Otherwise, initiate it. 
deg_list_filename = filename_generator(data_dir = data_dir, data_source = "NCI-60", data_type = "Expression", data_subtype = "DEG_list", extension = ".rds", processing_stage = "Processed", processing = "YuGene", gene_identifier = "HUGO", DE_criterion = "all_genes", full_path = T)
if(file.exists(deg_list_filename)) {
  deg_list = readRDS(deg_list_filename)
} else {
  deg_list = list()
}

# Loop over every sample and identify the differentially expressed genes. 
deg_list_names = c()
#system.time({
for(GSM in unique(NCI60_cancer_types$CellLine)) {
  print(paste0("Calculating the differentially expressed genes for sample ", GSM, "."))
  GSM_tissue_type = as.character(NCI60_cancer_types[NCI60_cancer_types$CellLine==GSM,"TissueType"][1])
  
  # Load the appropriate processed normal tissue. 
  # Check if the file exists. If it does, load it. If it doesn't, create it.
  normal_samples_filename = filename_generator(data_dir = data_dir, data_source = "GTEx", data_type = "Expression", sample = GSM_tissue_type, extension = ".rds", processing_stage = "Processed", processing = "YuGene", gene_identifier = "HUGO", additional_info = "normal_", full_path = T)
  if(file.exists(normal_samples_filename)) {
    normal_samples = readRDS(normal_samples_filename)
    deg_list_names = c(deg_list_names, GSM)
  } else {
    print(paste0("Error: the cancer ", GSM_tissue_type, " does not have associated normal tissue. Skipping this cancer."))
    next
  } 
  
  # Check if this sample is already in deg_list. 
  if(GSM %in% names(deg_list)) {
    print(paste0("Sample ", GSM, " is already in deg_list. Skipping this one."))
    next
  }
  
  # Load the expression matrix of the cell-line sample.
  patient_sample = exprs_NCI60[,colnames(exprs_NCI60)==GSM,drop=F]
  # Load the appropriate processed normal tissue. 
  normal_samples2 = t(normal_samples) # Transposing because GTEx_normal_samples_processed.rds contains the expression matrices with rows as samples and columns as genes. 
    
  ######################################
  ## 1. DATA PREPARATION AND CLEANING ##
  ######################################
  # Make sure the genes are the same across both the patient samples and normal tissue. 
  common_genes = intersect(rownames(normal_samples2), rownames(patient_sample))
  normal_samples2 = normal_samples2[rownames(normal_samples2) %in% common_genes,]
  patient_sample = patient_sample[rownames(patient_sample) %in% common_genes,,drop=F]
  normal_samples2 = normal_samples2[order(rownames(normal_samples2)),]
  patient_sample = patient_sample[order(rownames(patient_sample)),,drop=F]
  identical(rownames(normal_samples2), rownames(patient_sample))
  
  # I'm pretty sure we don't need to log2 transform, since log2 transformation is monotonic, and we're using rank-based methods. ... But let's leave this in here anyway in case we need to do so later.  
  #normal_samples_log2 = log2transform(normal_samples2) # Normal tissue.
  #patient_log2 = log2transform(patient_sample) # Patient samples. 
  
  # Harmonize patient samples and normal tissue. 
  # https://link.springer.com/protocol/10.1007%2F978-1-0716-0138-9_15
  # Visualize results. 
  
  # Normalize both patient samples and normal tissue.
  # https://link.springer.com/protocol/10.1007%2F978-1-0716-0138-9_15
  # They recommend quantile normalization for microarray data, but maybe log2-transform for both the patient sample and the normal tissue is OK? Check that Bolstad paper they cite.
  # ... Scratch that. Let's just not normalize outside the harmonization for now. 

  ##############################################
  ## 2. DIFFERENTIAL GENE EXPRESSION ANALYSIS ##
  ##############################################
  # For each gene, get the changes in rank between normal and tumor. 
  tumor_rank = patient_sample[order(patient_sample[,1], decreasing = T),1,drop=F]
  tumor_rank = cbind(tumor_rank, 1:length(tumor_rank))
  tumor_rank = tumor_rank[order(rownames(tumor_rank)),]
  
  normal_avg = as.matrix(future_apply(normal_samples2, 1, mean)) # Because we have more than one normal sample, get the rank of the average expression of the gene across all the samples.
  normal_rank = normal_samples2[order(normal_avg[,1], decreasing = T),1,drop=F]
  normal_rank = cbind(normal_rank, 1:length(normal_rank))
  normal_rank = normal_rank[order(rownames(normal_rank)),]
  
  identical(rownames(normal_rank), rownames(tumor_rank))
  rank_dif = as.matrix(tumor_rank[,2] - normal_rank[,2])
  rownames(rank_dif) = rownames(normal_rank) # rank_dif is now a data frame with the ranks of each gene. 
  
  # Select DEGs as the genes with rank differences >= 2SDs +/- the mean. 
  if(deg_type=="All") {
    deg_names = rownames(rank_dif)
  } else {
    lower_bound = mean(rank_dif) - deg_cutoff*sd(rank_dif)
    upper_bound = mean(rank_dif) + deg_cutoff*sd(rank_dif)
    upreg_degs = rownames(rank_dif[rank_dif[,1] > upper_bound,,drop=F])
    downreg_degs = rownames(rank_dif[rank_dif[,1] < lower_bound,,drop=F])
    deg_names = c(upreg_degs, downreg_degs)
  }
  
  # Create the table of differentially expressed genes. 
  degs = rank_dif[rownames(rank_dif) %in% deg_names,,drop=F]
  
  # Create the table of intensities.
  intensities = patient_sample[rownames(patient_sample) %in% deg_names,,drop=F]
  identical(rownames(intensities), rownames(degs)) # These are the two tables we'll be adding to deg_list[[sample]], so make sure they match. 
    
  # Add the table of differentially expressed genes to the list. 
  deg_list[[GSM]][["DEGs"]] = degs
  deg_list[[GSM]][["Intensity"]] = intensities
  
  # Remove all the samples expression matrices and clean up the memory. 
  rm(patient_sample, normal_samples2)
  gc()
  
}
#})
names(deg_list) = deg_list_names

# Save the list of DEGs.
saveRDS(deg_list, deg_list_filename)
```

## Expression: network construction
### All genes
```{r}
deg_type = "All"
if(deg_type == "All")  {
  all_genes = "all_genes"
} else if(deg_type == "SD") {
  all_genes = paste0(deg_cutoff, "SD")
} else {
  all_genes = paste0(deg_type)
}

# Load the list of DEG genes for each patient sample if it is not loaded already. 
deg_list_filename = filename_generator(data_dir = data_dir, data_source = "NCI-60", data_type = "Expression", data_subtype = "DEG_list", extension = ".rds", processing_stage = "Processed", processing = preprocessing_method, gene_identifier = id_type, DE_criterion = all_genes, full_path = T)
deg_list = readRDS(deg_list_filename)

# https://www.biostars.org/p/190137/#222651
# Instantiate STRINGdb reference class. We will set a very stringent threshold (default 400) and of course choose humans as our species. Do it outside the for() loop so we don't have to instantiate it every time. 
string_db = STRINGdb$new(version="10", species=9606, score_threshold=400, input_directory=folder_generator(
  data_dir = data_dir,
  data_source = "STRING-DB",
  data_type = "Network",
  processing_stage = "Raw"
))
#system.time({
for(GSM in names(deg_list)) {
  network_filename = filename_generator(data_dir = data_dir, data_source = "NCI-60", data_type = "Expression", data_subtype = "disease_network", extension = ".rds", data_set = GSE, sample = GSM, processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, DE_criterion = "all_genes", full_path = T)
  if(file.exists(network_filename)) next
  
  # Set up a list to hold the network, the mapping, and the hits. 
  network_list = list()
  
  # Differential gene expression data.
  de_genes = as.data.frame(deg_list[[GSM]][["DEGs"]])
  de_genes$GeneSymbol = rownames(de_genes)
  colnames(de_genes)[1] = "RankChange"
  
  # Map gene names from the table of differentially expressed genes to STRING identifiers. 
  #system.time({
  mapped = string_db$map(de_genes, "GeneSymbol", removeUnmappedRows=TRUE)
  #}) # Time: user system elapsed 7.412   0.248   7.978 
  hits = mapped$STRING_id # These are the hits. To select the top n hits, simply subset using [1:n]. Because we start with ~150 genes, which should be enough to make a decent PPI network, we will just use all of these genes without subsetting. 
    # Plot the network, showing the number of proteins (genes), the number of interactions, and the p-value (probability that we would get, by chance, as many interactions as we did in   this network.)
    # string_db$plot_network(hits)

  # As of 05/17/2021, we no longer have to create a subnetwork. ... I think.
  # Create an iGraph network object. This is the disease network, which we can now run iGraph functions on.
  #system.time({
  #network = string_db$get_subnetwork(hits) # user system elapsed 0.017   0.066   0.192
  #})
  # Save network to list.
  #network_list[["Network"]] = network 
  network_list[["Map"]] = mapped
  network_list[["Hits"]] = hits
  
  # New addition 01/29/2021; need the intensity for the WINTHER score.
  # Add intensity.
  intensity = as.data.frame(deg_list[[GSM]][["Intensity"]])
  intensity = intensity[rownames(intensity) %in% mapped$GeneSymbol,,drop=F]
  colnames(intensity) = "Intensity"
  network_list[["Intensity"]] = intensity
  
  # Save the list to RDS.
  saveRDS(network_list, network_filename)
  
  # Clean up.
  rm(network_list)
  gc()
}
#})
```

### Rank-difference cutoff
```{r}
deg_type = "SD"
if(deg_type == "All")  {
  all_genes = "all_genes"
} else if(deg_type == "SD") {
  all_genes = paste0(deg_cutoff, "SD")
} else {
  all_genes = paste0(deg_type)
}

# Load the list of DEG genes for each patient sample if it is not loaded already. 
deg_list_filename = filename_generator(data_dir = data_dir, data_source = "NCI-60", data_type = "Expression", data_subtype = "DEG_list", extension = ".rds", processing_stage = "Processed", processing = preprocessing_method, gene_identifier = id_type, DE_criterion = all_genes, full_path = T)
deg_list = readRDS(deg_list_filename)

# https://www.biostars.org/p/190137/#222651
# Instantiate STRINGdb reference class. We will set a very stringent threshold (default 400) and of course choose humans as our species. Do it outside the for() loop so we don't have to instantiate it every time. 
string_db = STRINGdb$new(version="10", species=9606, score_threshold=400, input_directory=folder_generator(
  data_dir = data_dir,
  data_source = "STRING-DB",
  data_type = "Network",
  processing_stage = "Raw"
))
#system.time({
for(GSM in names(deg_list)) {
  network_filename = filename_generator(data_dir = data_dir, data_source = "NCI-60", data_type = "Expression", data_subtype = "disease-network", extension = ".rds", data_set = GSE, sample = GSM, processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, DE_criterion = all_genes, full_path = F)
  if(file.exists(network_filename)) next
  
  # Set up a list to hold the network, the mapping, and the hits. 
  network_list = list()
  
  # Differential gene expression data.
  de_genes = as.data.frame(deg_list[[GSM]][["DEGs"]])
  de_genes$GeneSymbol = rownames(de_genes)
  colnames(de_genes)[1] = "RankChange"
  
  # Map gene names from the table of differentially expressed genes to STRING identifiers. 
  #system.time({
  mapped = string_db$map(de_genes, "GeneSymbol", removeUnmappedRows=TRUE)
  #}) # Time: user system elapsed 7.412   0.248   7.978 
  hits = mapped$STRING_id # These are the hits. To select the top n hits, simply subset using [1:n]. Because we start with ~150 genes, which should be enough to make a decent PPI network, we will just use all of these genes without subsetting. 
    # Plot the network, showing the number of proteins (genes), the number of interactions, and the p-value (probability that we would get, by chance, as many interactions as we did in   this network.)
    # string_db$plot_network(hits)

  # As of 05/17/2021, we no longer have to create a subnetwork. ... I think.
  # Create an iGraph network object. This is the disease network, which we can now run iGraph functions on.
  #system.time({
  #network = string_db$get_subnetwork(hits) # user system elapsed 0.017   0.066   0.192
  #})
  # Save network to list.
  #network_list[["Network"]] = network 
  network_list[["Map"]] = mapped
  network_list[["Hits"]] = hits
  
  # New addition 01/29/2021; need the intensity for the WINTHER score.
  # Add intensity.
  intensity = as.data.frame(deg_list[[GSM]][["Intensity"]])
  intensity = intensity[rownames(intensity) %in% mapped$GeneSymbol,,drop=F]
  colnames(intensity) = "Intensity"
  network_list[["Intensity"]] = intensity
  
  # Save the list to RDS.
  saveRDS(network_list, network_filename)
  
  # Clean up.
  rm(network_list)
  gc()
}
#})
```

# GDSC
## Drug data
### Creation of drug list
The drug list was manually created and consists of all the drugs that have either a DrugBank or KEGG ID or both. It covers both GDSC1 and GDSC2 ... I think. 
```{r}
GDSC_drug_list = read.csv(filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids"), stringsAsFactors = F)
GDSC_drugs = GDSC_drug_list$drug_name %>% unique
# length(GDSC_drugs) == length(unique(GDSC_drugs))

# Save to file. 
write.table(GDSC_drugs, filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", extension = ".tsv", processing_stage = "Raw", additional_info = "names"), row.names = F, col.names = F, quote = F)
```

### CTD
#### Filtering
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Load the CTD data.
GDSC_drug_cgixns_CTD_raw = read.csv(paste0(folder_generator(data_dir, data_source = "GDSC", data_type = "Drugs", processing_stage = "Processed"), "CTD_chem_cgixns_1632082857803.csv"))

# Filter drugs to include the following: 1) has data, 2) is human, 3) has no cotreatment stuff, 4) includes information on increasing/decreasing activity/expression (not just "affects.")
GDSC_drug_cgixns_CTD_filtered = GDSC_drug_cgixns_CTD_raw %>% dplyr::filter(!base::grepl("found", Input) & 
                                          OrganismID == "9606" &
                                          !base::grepl("reaction", InteractionActions) & 
                                          !base::grepl("response", InteractionActions) & 
                                          !base::grepl("cotreatment", InteractionActions) &
                                          (
                                            base::grepl("increases\\^activity", InteractionActions) |
                                              base::grepl("increases\\^expression", InteractionActions) |
                                              base::grepl("decreases\\^activity", InteractionActions) |
                                              base::grepl("decreases\\^expression", InteractionActions)
                                            )
                                        )

# Save the filtered data.
GDSC_drug_cgixns_CTD_filtered_filename = paste0(folder_generator(data_dir, data_source = "GDSC", data_type = "Drugs", processing_stage = "Processed"), "GDSC_CTD_chem_cgixns_1632082857803_filtered.rds")
saveRDS(GDSC_drug_cgixns_CTD_filtered, GDSC_drug_cgixns_CTD_filtered_filename)
```

#### Target extraction
```{r echo = FALSE, eval=TRUE, include=FALSE}
GDSC_drug_cgixns_CTD_filtered_filename = paste0(folder_generator(data_dir, data_source = "GDSC", data_type = "Drugs", processing_stage = "Processed"), "GDSC_CTD_chem_cgixns_1632082857803_filtered.rds")

# Naming the modified function "getTargets2," how creative. 
getTargets2 = function(drug) {
  # For drug "drug," get the targets. 
  print(paste0("Getting targets for drug ", drug, "."))
  
  # Create an empty table to be returned for drugs without entries.
  empty_table = data.frame(
    Drug = character(),
    Target = character(),
    Effect = character(),
    stringsAsFactors = F
  )
  
  # Load the chemical-gene interactions from CTD (saved as a CSV file in /Data/CTD/GDSC.)
  possibleError = tryCatch(
    {
      # GDSC_drug_cgixns_CTD_filtered should already be loaded in the global environment. 
      # Keep only the interactions for the drug "drug" and found in humans.
      regex = paste0("^", drug, "$")
      CTD_subset = GDSC_drug_cgixns_CTD_filtered[GDSC_drug_cgixns_CTD_filtered$OrganismID=="9606" & (GDSC_drug_cgixns_CTD_filtered$ChemicalName==drug | GDSC_drug_cgixns_CTD_filtered$Input==drug | base::grepl(regex, GDSC_drug_cgixns_CTD_filtered$Input, ignore.case = T) | base::grepl(regex, GDSC_drug_cgixns_CTD_filtered$ChemicalName, ignore.case = T)),,drop=F]
    }, error=function(cond) {
      message(paste0("For getTargets(), there was a problem retrieving the chemical-gene interactions for the drug ", drug, ":"))
      message(cond)
    }
  )
  
  if(inherits(possibleError, "error") | !exists("CTD_subset")) {
    print(paste0("For getTargets(), there was a problem retrieving the chemical-gene interactions for the drug ", drug, "."))
    return(empty_table)
  }
  
  else {
    if(nrow(CTD_subset) < 1) return(empty_table)
    
    # We want only the interactions that include "[chemical name] (and not an analog) ... results in decreased/increased action/expression of [X protein/mRNA]."
    # regex = paste0(drug, " (?!\\banalog\\b)(binds to and results in |results in(\\s| (de|in)creased [^\\s]+ of and results in ))(de|in)creased (activity|expression) of") # Yes, there should be no space between "(?!\\banalog\\b)" and "results."
    # Standardize the drug name. 
    drug = CTD_subset$ChemicalName
    drug = drug[complete.cases(drug)][1]
  
    regex1 = paste0(" (?!\\banalog\\b)") # This will be set to negative, because we do NOT want the analogs. Just the drug itself. 
    regex2 = "(the reaction \\[|susceptibility to|co-treated|modified form)" # This will be set to negative, because we do NOT want the other drug-chemical interactions that the drug in question affects OR direct gene effects affected by other drugs. Just the direct gene effects. We also don't want co-treatments (for right now.) Finally, we don't want the modified forms of proteins. 
    regex3 = "results in (de|in)creased (activity|expression) of" # This will be set to positive, because we want to make sure that this phrase is present. 
    regex4 = "\\[" # We do NOT want something like "Carboplatin results in increased activity of [NFKB1 protein binds to RELA protein]"
    # We will use the regexPipes library to do this. 
    interactions = CTD_subset$Interaction %>% regexPipes::grep(drug, fixed = T, value = T) %>% regexPipes::grep(regex1, perl = T, value = T) %>% regexPipes::grep(regex2, value = T, invert = T) %>% regexPipes::grep(regex3, value = T) %>% regexPipes::grep(regex4, value = T, invert = T)
    # CTD_subset = CTD_subset[grep(regex, CTD_subset$Interaction, perl = T),,drop=F]
    
    # Build a data frame to hold the targets and the direction the drug affects the target in.
    # We won't distinguish between mRNA and protein here. 
    # Populate the data frame with the targets.
    targets = future_lapply(interactions, FUN = extractTarget, drug = drug)
    targets = as.data.frame(do.call(rbind, targets), stringsAsFactors = F)
    if(nrow(targets) > 0) {
      colnames(targets) = c("Drug", "Target", "Effect")
      targets$Effect = as.integer(as.character(targets$Effect))
      
      # Remove duplicates
      targets = unique(targets)
    }
    
  rm(CTD_subset)
  
  return(targets)
  }
}

# Check the format of the data frames that calcNetworkScore() uses. 

# Get the vector of drugs.
# Update 08/16/2021: now including even the drugs without KEGG pathways.
drugs = read.csv(GDSC_drugs_filename, stringsAsFactors = F) %>% dplyr::filter(exclude != "Y") %>% dplyr::select(drug_name) %>% unlist() %>% unique() %>% str_to_lower()
# Replace "venotoclax" with "venetoclax."
drugs[drugs=="venotoclax"] = "venetoclax"

# Load the file. 
if(!exists("GDSC_drug_cgixns_CTD_filtered")) GDSC_drug_cgixns_CTD_filtered = readRDS(GDSC_drug_cgixns_CTD_filtered_filename)

# Get the targets.
GDSC_drug_target_data_CTD = future_lapply(drugs, FUN = getTargets2) # Returns a list. 
names(GDSC_drug_target_data_CTD) = drugs

# Rename the drugs in the tables and get the drugs that have entries.
drugs_with_CTD_entries = c()
for(drug in names(GDSC_drug_target_data_CTD)) {
  if(nrow(GDSC_drug_target_data_CTD[[drug]]) > 0) {
    GDSC_drug_target_data_CTD[[drug]]$Drug = drug
    drugs_with_CTD_entries = c(drugs_with_CTD_entries, drug)
  }
}
# Keep only the drugs with entries.
GDSC_drug_target_data_CTD = GDSC_drug_target_data_CTD[drugs_with_CTD_entries]

# Save the list. 
# New list with 71 entries (previously 53) saved 08/16/2021.
GDSC_drug_target_data_CTD_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "CTD", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(GDSC_drug_target_data_CTD, GDSC_drug_target_data_CTD_filename)
```


### DrugBank
DrugBank data was downloaded as an XML file from [...] on [...]. The data was migrated to a MySQL database for easier retrieval. See the Supplemental Data section for detailed methods. 

```{r echo = FALSE, eval=TRUE, include=FALSE}
# Update 08/16/2021: now including even the drugs without KEGG pathways.
GDSC_drugs_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
GDSC_drugs = read.csv(GDSC_drugs_filename)
drugs = GDSC_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(drug_name) %>% unlist %>% unique %>% str_to_lower
DB_ids = GDSC_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(DB_id) %>% unlist %>% unique

GDSC_drug_target_data_DrugBank_tmp = data.frame(
  Drug = character(),
  Target = character(),
  Effect = numeric(),
  stringsAsFactors = F
)

# Get the targets of the drugs from the MySQL database. 

# Get all the possible pharmacological actions. 
#query = "SELECT PharmacologicalAction FROM DrugTargets.DrugBank;"
#res = dbSendQuery(DrugTargetsDB, query)
#pharm_actions = dbFetch(res) %>% unlist() %>% unique()
#View(pharm_actions)
#dbClearResult(res)
inhibitory_actions = c("inhibitor", "antagonist", "antibody", "inverse agonist", "inhibitory allosteric modulator", "negative modulator", "blocker", "weak inhibitor", "downregulator", "partial antagonist", "suppressor", "inactivator", "degradation", "incorporation into and destabilization", "inhibition of synthesis")
activating_actions = c("activator", "agonist", "stimulator", "potentiator", "inducer", "positive allosteric modulator", "partial agonist", "positive modulator")
        
# https://programminghistorian.org/en/lessons/getting-started-with-mysql-using-r#create-an-r-script-that-connects-to-the-database
# Make the connection to the MySQL database. 
# The connection method below uses a password stored in a settings file.
user_password = "Kibougaaru2020"
DrugTargetsDB = dbConnect(RMariaDB::MariaDB(), 
                          user='root', 
                          password=user_password, 
                          dbname='DrugTargets', 
                          host='localhost')
dbListTables(DrugTargetsDB)

# Make the queries. 
for(db_id in DB_ids) {
  query = paste0("SELECT DrugName, TargetName, Organism, PharmacologicalAction FROM DrugTargets.DrugBank WHERE DrugBankID = '", db_id, "';")
  res = dbSendQuery(DrugTargetsDB, query)
  drug_data = dbFetch(res)
  dbClearResult(res)
  
  if(nrow(drug_data) < 1) next
  
  # Get the drug name.
  drug_name = GDSC_drugs %>% dplyr::filter(DB_id==db_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  
  # Select the entries with "Human" in the Organism column.
  drug_data = drug_data %>% dplyr::filter(base::grepl("Human", Organism))
  
  # For each target, get the effect.
  for(target in unique(drug_data$TargetName)) {
    # Get the number of effects.
    drug_actions = drug_data %>% dplyr::filter(TargetName == target) %>% dplyr::select(PharmacologicalAction) %>% unique()
    
    if(length(drug_actions) > 0) {
      # Convert the pharmacological actions to -1, 0, or 1. 
      inhibitory = ifelse(sum(drug_actions %in% inhibitory_actions) > 0, T, F)
      activating = ifelse(sum(drug_actions %in% activating_actions) > 0, T, F)
      if(inhibitory & !activating) {
        drug_action_numeric = -1
      } else if(activating & !inhibitory) {
        drug_action_numeric = 1
      } else {
        drug_action_numeric = 0
      }
        
      # Add to the table.
      GDSC_drug_target_data_DrugBank_tmp = rbind(GDSC_drug_target_data_DrugBank_tmp, data.frame(
        Drug = drug_name,
        Target = target,
        Effect = drug_action_numeric,
        stringsAsFactors = F
      ))
    }
  }
}
# Disconnect
dbDisconnect(DrugTargetsDB)

# Save the temporary table.
GDSC_drug_target_data_DrugBank_tmp_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "DrugBank", extension = ".rds", processing_stage = "Processed", additional_info = "target_data_tmp")
saveRDS(GDSC_drug_target_data_DrugBank_tmp, GDSC_drug_target_data_DrugBank_tmp_filename)

# Make sure all the drug names in GDSC_drug_target_data_DrugBank_tmp match the names in drugs. (We will need to do some manual correction, more than likely.)
setdiff(unique(GDSC_drug_target_data_DrugBank_tmp$Drug), drugs)
setdiff(drugs, unique(GDSC_drug_target_data_DrugBank_tmp$Drug))

# Convert the targets in GDSC_drug_target_data_DrugBank_tmp to ENTREZ IDs.
hs = org.Hs.eg.db
keys = GDSC_drug_target_data_DrugBank_tmp$Target %>% as.character()
x = AnnotationDbi::select(hs, 
               keys = keys,
               columns = c("SYMBOL", "ENTREZID"),
               keytype = "SYMBOL") %>% .[complete.cases(.),] %>% distinct()

# Remove any ENTREZIDs that don't have corresponding KEGG entries.
entrez_no_kegg = c()
for(entrez_id in unique(x$ENTREZID)) {
  print(paste0("Checking if gene ", entrez_id, " has a KEGG entry."))
  
  possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
        entrez_test = keggGet(paste0("hsa:", entrez_id))
    }, error=function(cond) {
        message(cond)
    }
    )
  if(inherits(possibleError, "error") | !exists("entrez_test")) {
      entrez_no_kegg = c(entrez_no_kegg, entrez_id)
  }
  
  rm(entrez_test)
}
x = x %>% dplyr::filter(!(ENTREZID %in% entrez_no_kegg))
# Convert to ENTREZ.
# https://stackoverflow.com/a/3905442
a = x$SYMBOL
b = x$ENTREZID
GDSC_drug_target_data_DrugBank_tmp$Target = b[match(GDSC_drug_target_data_DrugBank_tmp$Target, a)]
GDSC_drug_target_data_DrugBank = GDSC_drug_target_data_DrugBank_tmp %>% .[complete.cases(.),]

# We won't need to convert to list to match CTD format until we merge the DrugBank and KEGG data.

# Merge.
#GDSC_drug_target_data_DrugBank = rbind(GDSC_drug_target_data_DrugBank, GDSC_drug_target_data_DrugBank_tmp)

# Change everything to sentence caps. 
#GDSC_drug_target_data_DrugBank$Drug = str_to_sentence(GDSC_drug_target_data_DrugBank$Drug)

# Filter out targets that already exist (i.e. keep only unique rows.)
#GDSC_drug_target_data_DrugBank = GDSC_drug_target_data_DrugBank %>% distinct()

# 11 Aug 2021: replace venotoclax -> venetoclax.
GDSC_drug_target_data_DrugBank$Drug = GDSC_drug_target_data_DrugBank$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")

# Save.
# Update 08/16/2021: now including even the drugs without KEGG pathways.
GDSC_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
write.table(GDSC_drug_target_data_DrugBank, GDSC_drug_target_data_DrugBank_filename, sep=",", row.names=F)
```

### KEGG
KEGG data was downloaded using the KEGGREST package in R (3.6.3.) Since KEGG does not provide the pharmacological effects of drugs on the target (e.g. whether the drug acts as an antagonist or agonist), 

```{r echo = FALSE, eval=TRUE, include=FALSE}
GDSC_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
GDSC_drug_target_data_DrugBank = read.csv(GDSC_drug_target_data_DrugBank_filename)

GDSC_drugs_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
GDSC_drugs = read.csv(GDSC_drugs_filename, stringsAsFactors = F)
kegg_ids = GDSC_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(KEGG_id) %>% unlist %>% unique %>% .[!is.na(.)]

GDSC_drug_target_data_KEGG = data.frame(
  Drug = character(),
  Target = character(),
  Effect = character()
)
# Table to hold the mutant/fusion protein targets. 
GDSC_drug_target_data_KEGG_v = data.frame( # v = variation. 
  Drug = character(),
  Target = character()
)
for(kegg_drug_id in kegg_ids) {
  drug = GDSC_drugs %>% dplyr::filter(KEGG_id==kegg_drug_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  print(paste0("Getting the KEGG targets for drug ", drug, "."))

    # Get the pathways affected.
  if(!is.null(kegg_drug_id) & !is.na(kegg_drug_id)) {
    
    possibleError = tryCatch(
    {
      kegg_pathways = keggGet(kegg_drug_id)[[1]]$TARGET
    }, error=function(cond) {
      message(paste0("There was a problem retrieving the drug-target data from KEGG for the drug ", drug, ":"))
      message(cond)
    }
  )
  
    if(inherits(possibleError, "error")) {
      print(paste0("There was a problem retrieving the drug-target data from KEGG for the drug ", drug, ":"))
      next
    }
  
    else {
      if(class(kegg_pathways)=="list") {
        # Get the mutant/fusion protein targets and add them to a separate table. 
        kegg_targets = kegg_pathways$TARGET
        v_targets = kegg_targets %>% regexPipes::grep("\\*", value = T) %>% str_split(" ") %>% unlist %>% regexPipes::grep("\\[HSA\\:", value = T) %>% regexPipes::gsub("\\[HSA\\:", "") %>% regexPipes::gsub("\\]", "") # This assumes that drugs can't target both a mutant and non-mutant form. ... 
        GDSC_drug_target_data_KEGG_v = rbind(GDSC_drug_target_data_KEGG_v, data.frame(
          Drug = rep(drug, length(v_targets)),
          Target = v_targets
        ))
        
        # Now get the rest of the targets from the pathways. 
        kegg_pathways = kegg_pathways$PATHWAY
      
        # Keep only the signal-transduction and disease-associated pathways (hsa03xxx, hsa04xxx and hsa05xxx.) 
        kegg_pathway_names = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("[[:space:]]+.+$", "")
      
        # Get the targets of the drug and filter the targets to include only the ones that are not already present in the DB table.
        drug_targets_DrugBank = GDSC_drug_target_data_DrugBank %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist
        targets = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("hsa0[345][[:digit:]]{3}", "") %>% regexPipes::gsub("[[:space:]]+.+$", "") %>% regexPipes::gsub("[()]", "") %>% str_split("\\+") %>% unlist() %>% unique() #%>% .[!(. %in% drug_targets_DrugBank)] As of 2022-06-05, we are no longer removing the drug targets present in the DrugBank table at this step. We will wait until the "Merging DrugBank and KEGG" step to do that, because we need all the KEGG targets present when we do the TRRUST stuff. 
      
        # Add to the table.
        GDSC_drug_target_data_KEGG = rbind(GDSC_drug_target_data_KEGG, data.frame(
          Drug = rep(drug, length(targets)),
          Target = targets,
          Effect = rep(-1, length(targets)) # I'm assuming most of the drugs are inhibitors. ... 
        ))
      }
    }
  } 
  
}

# Keep only unique rows.
GDSC_drug_target_data_KEGG = GDSC_drug_target_data_KEGG %>% distinct()

# For the most part, the drugs are inhibitors, but for two drug-target pairs, fulvestrant and 2100, and phenformin and 5563, we will have to manually update them. 
GDSC_drug_target_data_KEGG = GDSC_drug_target_data_KEGG
GDSC_drug_target_data_KEGG[GDSC_drug_target_data_KEGG$Drug=="fulvestrant" & GDSC_drug_target_data_KEGG$Target=="2100","Effect"] = 0
GDSC_drug_target_data_KEGG[GDSC_drug_target_data_KEGG$Drug=="phenformin" & GDSC_drug_target_data_KEGG$Target=="5563","Effect"] = 1

# 11 Aug 2021: replace venotoclax -> venetoclax.
GDSC_drug_target_data_KEGG$Drug = GDSC_drug_target_data_KEGG$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")
GDSC_drug_target_data_KEGG_v$Drug = GDSC_drug_target_data_KEGG_v$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")

# Remove the following drugs from the _v table, since they do not target mutant but overexpressed/fusion proteins: trastuzumab, lapatinib, crizotinib. Well, maybe keep crizo in the _v table for consistency? It looks like we did that for the network scores? 
GDSC_drug_target_data_KEGG_v$Effect = -1
for(drug in c("lapatinib")) {
  # Add the appropriate row to non-_v table.
  GDSC_drug_target_data_KEGG = rbind(GDSC_drug_target_data_KEGG, GDSC_drug_target_data_KEGG_v %>% dplyr::filter(Drug==drug))
}
GDSC_drug_target_data_KEGG_v = GDSC_drug_target_data_KEGG_v %>% dplyr::filter(!(Drug %in% c("lapatinib")))

# Save. 
GDSC_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
GDSC_drug_target_data_KEGG_v_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_data", processing_stage = "Processed")
write.table(GDSC_drug_target_data_KEGG, GDSC_drug_target_data_KEGG_filename, sep=",", row.names=F)
write.table(GDSC_drug_target_data_KEGG_v, GDSC_drug_target_data_KEGG_v_filename, sep=",", row.names=F)
```

### Merging DrugBank and KEGG
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Load the Drugbank and KEGG target information.
GDSC_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
GDSC_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
GDSC_drug_target_data_KEGG_v_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_data", processing_stage = "Processed")
GDSC_drug_target_data_KEGG = read.csv(GDSC_drug_target_data_KEGG_filename)
GDSC_drug_target_data_KEGG_v = read.csv(GDSC_drug_target_data_KEGG_v_filename)
GDSC_drug_target_data_DrugBank = read.csv(GDSC_drug_target_data_DrugBank_filename)

# Merge the Drugbank and KEGG target tables. 
GDSC_drug_target_data_DrugBank_KEGG = rbind(GDSC_drug_target_data_DrugBank, GDSC_drug_target_data_KEGG) %>% distinct()
# Consolidate duplicate rows (i.e., rows with the same target but different effects).
# https://stackoverflow.com/a/10180178
GDSC_drug_target_data_DrugBank_KEGG = GDSC_drug_target_data_DrugBank_KEGG %>% dplyr::select(Drug, Target, Effect) %>% ddply(.(Drug, Target), numcolwise(sum))
#rownames(GDSC_drug_target_data_DrugBank_KEGG) = GDSC_drug_target_data_DrugBank_KEGG$Target
# Because of the consolidation in the previous step, we might have effect values > 1 or < -1. Set the ceiling and floor to be 1 and -1, respectively. 
GDSC_drug_target_data_DrugBank_KEGG$Effect = ifelse(GDSC_drug_target_data_DrugBank_KEGG$Effect > 1, 1, GDSC_drug_target_data_DrugBank_KEGG$Effect)
GDSC_drug_target_data_DrugBank_KEGG$Effect = ifelse(GDSC_drug_target_data_DrugBank_KEGG$Effect < -1, -1, GDSC_drug_target_data_DrugBank_KEGG$Effect)

# Remove all the entries from the Drugbank targets that are also present in the variant KEGG table (i.e. the ones that have mutations/fusions.)
GDSC_drug_target_data_DrugBank_KEGG = GDSC_drug_target_data_DrugBank_KEGG %>% .[!(paste(.$Drug, .$Target, sep="_") %in% paste(GDSC_drug_target_data_KEGG_v$Drug, GDSC_drug_target_data_KEGG_v$Target, sep="_")),]

# Convert from Entrez ID to HUGO gene symbol. 
hs = org.Hs.eg.db
keys = GDSC_drug_target_data_DrugBank_KEGG$Target %>% as.character
x = AnnotationDbi::select(hs, 
                          keys = keys,
                          columns = c("SYMBOL", "ENTREZID"),
                          keytype = "ENTREZID") %>% .[complete.cases(.),]
GDSC_drug_target_data_DrugBank_KEGG$Target = x %>% .[match(GDSC_drug_target_data_DrugBank_KEGG$Target, .$ENTREZID),] %>% .$SYMBOL

# Split the dataframe into a list, to match the CTD drug-target-data format and the format that most of the calcNetworkScores() functions use. 
GDSC_drug_target_data_DrugBank_KEGG = split(GDSC_drug_target_data_DrugBank_KEGG , f = GDSC_drug_target_data_DrugBank_KEGG$Drug)

# Remove all entries in the list whose tables have 0 rows. (28 June 2021.)
for(entry in names(GDSC_drug_target_data_DrugBank_KEGG)) {
  if(nrow(GDSC_drug_target_data_DrugBank_KEGG[[entry]]) < 1) {
    GDSC_drug_target_data_DrugBank_KEGG[[entry]] = NULL
  } 
}

# Save.
GDSC_drug_target_data_DrugBank_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "DrugBank_KEGG", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(GDSC_drug_target_data_DrugBank_KEGG, GDSC_drug_target_data_DrugBank_KEGG_filename)
```

### TRRUST
#### Target pathways from KEGG
```{r}
# From KEGG, get the pathways targeted by each drug. 
GDSC_drugs_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
GDSC_drugs = read.csv(GDSC_drugs_filename, stringsAsFactors = F)
drugs = GDSC_drugs %>% dplyr::select(drug_name) %>% unlist %>% unique %>% str_to_lower
GDSC_drug_target_pathway_data_KEGG = data.frame(
  Drug = character(),
  PathwayName = character(),
  PathwayID = character(),
  Target = character(),
  stringsAsFactors = F
)
GDSC_drug_target_pathway_data_KEGG_v = data.frame(
  Drug = character(),
  PathwayName = character(),
  PathwayID = character(),
  Target = character(),
  stringsAsFactors = F
)
kegg_ids = GDSC_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(KEGG_id) %>% unlist %>% unique %>% .[!is.na(.)]
for(kegg_drug_id in kegg_ids) {
  drug = GDSC_drugs %>% dplyr::filter(KEGG_id==kegg_drug_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  print(paste0("Getting KEGG pathways for drug ", drug, "."))
  
  if(!is.null(kegg_drug_id)) {
    kegg_drug_id = kegg_drug_id %>% str_trim
    kegg_pathways = keggGet(kegg_drug_id)[[1]]$TARGET
    
    if(class(kegg_pathways)=="list") {
      # Get the targets of the drug.
      kegg_targets = kegg_pathways$TARGET
      
      # Get the mutant/fusion protein targets and add them to a separate table. 
      v_targets = kegg_targets %>% regexPipes::grep("\\*", value = T) %>% str_split(" ") %>% unlist %>% regexPipes::grep("\\[HSA\\:", value = T) %>% regexPipes::gsub("\\[HSA\\:", "") %>% regexPipes::gsub("\\]", "") # This assumes that drugs can't target both a mutant and non-mutant form. ... 
      GDSC_drug_target_pathway_data_KEGG_v = rbind(GDSC_drug_target_pathway_data_KEGG_v, data.frame(
        Drug = rep(drug, length(v_targets)),
        PathwayName = rep(NA, length(v_targets)),
        PathwayID = rep(NA, length(v_targets)),
        Target = v_targets
      ))
      
      # Now get the rest of the targets from the pathways. 
      kegg_pathways = kegg_pathways$PATHWAY
      
      # Get the names of the pathways.
      kegg_pathway_names = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>%  regexPipes::gsub("^[[:alnum:]]+\\(.*\\)[[:space:]]*", "") %>% str_to_upper() %>% regexPipes::gsub("[[:space:]]", "_") %>% paste0("KEGG_", .)
      # Get the KEGG IDs of the pathways.
      KEGG_pathway_ids = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("\\(.+$", "")
      # Get the targets in those pathways. 
      kegg_pathway_targets = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("hsa0[345][[:digit:]]{3}\\(", "") %>% regexPipes::gsub("\\).+$", "") %>% str_split("\\+")
      if(length(kegg_pathway_targets) < 1) {
        print(paste0("There are no applicable KEGG pathways for drug ", drug, ". Skipping to the next one."))
        next
      }
      names(kegg_pathway_targets) = KEGG_pathway_ids
      
      # Create the vectors for the drugs, pathway names, pathway IDs, and targets.
      target_vector = kegg_pathway_targets %>% unlist
      pathway_id_vector = c()
      for(name in names(kegg_pathway_targets)) {
        pathway_id_vector = c(pathway_id_vector, rep(name, length(kegg_pathway_targets[[name]])))
      }
      pathway_name_vector = c()
      for(i in 1:length(kegg_pathway_targets)) {
        pathway_name_vector = c(pathway_name_vector, rep(kegg_pathway_names[i], length(kegg_pathway_targets[[i]])))
      }
  
      if(length(kegg_pathway_names)==length(KEGG_pathway_ids)) {
        GDSC_drug_target_pathway_data_KEGG = rbind(GDSC_drug_target_pathway_data_KEGG, data.frame(
          Drug = rep(drug, length(pathway_name_vector)),
          PathwayName = pathway_name_vector,
          PathwayID = pathway_id_vector,
          Target = target_vector,
          stringsAsFactors = F
        ))
      } # End if(length(kegg_pathway_names)==length(KEGG_pathway_ids)). 
    } # End if(class(kegg_pathways)=="list"). 
  } # End if(!is.null(kegg_drug_id)). 

}

# Currently, the normal target table has ALL the records. We will remove from it all the mutant protein targets. (This is different from what we did in the KEGG protein target section.)
# Add RecordID field to both _v and normal target tables.
GDSC_drug_target_pathway_data_KEGG$RecordID = paste(GDSC_drug_target_pathway_data_KEGG$Drug, GDSC_drug_target_pathway_data_KEGG$Target, sep = "_")
GDSC_drug_target_pathway_data_KEGG_v$RecordID = paste(GDSC_drug_target_pathway_data_KEGG_v$Drug, GDSC_drug_target_pathway_data_KEGG_v$Target, sep = "_")

# Remove the following drugs from the _v table, since they do not target mutant but overexpressed/fusion proteins: trastuzumab, lapatinib, crizotinib.
GDSC_drug_target_pathway_data_KEGG_v = GDSC_drug_target_pathway_data_KEGG_v %>% dplyr::filter(!(Drug %in% c("trastuzumab", "lapatinib", "crizotinib")))
# Now filter the normal table by the _v table.
# But first save the _v stuff!
tmp = GDSC_drug_target_pathway_data_KEGG %>% dplyr::filter(RecordID %in% GDSC_drug_target_pathway_data_KEGG_v$RecordID)
GDSC_drug_target_pathway_data_KEGG = GDSC_drug_target_pathway_data_KEGG %>% dplyr::filter(!(RecordID %in% GDSC_drug_target_pathway_data_KEGG_v$RecordID))
GDSC_drug_target_pathway_data_KEGG_v = tmp

rm(tmp)

# Save to file.
GDSC_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
GDSC_drug_target_pathway_data_KEGG_v_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_pathway_data", processing_stage = "Processed")
write.table(GDSC_drug_target_pathway_data_KEGG, GDSC_drug_target_pathway_data_KEGG_filename, sep=",", row.names=F)
write.table(GDSC_drug_target_pathway_data_KEGG_v, GDSC_drug_target_pathway_data_KEGG_v_filename, sep=",", row.names=F)
```

#### Genes downstream of each drug target
```{r}
# Get all the targeted pathways. 
GDSC_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
GDSC_drug_target_pathway_data_KEGG = read.csv(GDSC_drug_target_pathway_data_KEGG_filename)
# We no longer have to remove drug-target-pathway combinations involving mutant/fusion proteins in this step, since we did it in the last one. 08/21/2021.
KEGG_pathway_ids = GDSC_drug_target_pathway_data_KEGG$PathwayID %>% unique() 
# Get all the direct targets of the drugs.
GDSC_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
GDSC_drug_target_data_KEGG = read.csv(GDSC_drug_target_data_KEGG_filename)
GDSC_drug_targets_KEGG = GDSC_drug_target_data_KEGG$Target %>% unique() %>% paste0("hsa:", .)

# For each pathway, get the nodes downstream of each target. 
GDSC_drug_target_downstream_node_data_KEGG = data.frame(
  Pathway = character(),
  Target = character(),
  DownstreamNodes = character(),
  Effects = numeric(),
  stringsAsFactors = F
)
for(pathway in KEGG_pathway_ids) {
  print(paste0("Working on pathway ", pathway, "."))
  
  # Load the KGML file. 
  #kgml = keggGet("hsa04010", option = "kgml")
  #parsed_kgml = parseKGML(kgml)
  #pathway_graph = KEGGpathway2Graph(parsed_kgml)
  kgml = keggGet(pathway, option = "kgml")

  # Convert the KGML file into an iGraph object.
  # First convert to a graphNEL object.
  graphNEL = parseKGML2Graph(kgml, expandGenes = T, genesOnly = F) # PI3K signaling occurs through PIP3, which is a lipid. ... 
  #graphNEL_layout = layoutGraph(graphNEL)
  #renderGraph(graphNEL_layout)
  
  # For MAPK pathway only--create a directed edge between the RTK node and the GRB2 node, and between the GRB2 node and the SOS node. 
  rtk_nodes = c("hsa:1436","hsa:1956","hsa:1969","hsa:2064","hsa:2065","hsa:2066","hsa:2260","hsa:2261","hsa:2263","hsa:2264","hsa:2321","hsa:2322","hsa:2324","hsa:3480","hsa:3643","hsa:3791","hsa:3815","hsa:4233","hsa:4804","hsa:4914","hsa:4915","hsa:5156","hsa:5159","hsa:7010")
  grb2_node = "hsa:2885"
  sos_nodes = c("hsa:6654","hsa:6655")
  if(pathway=="hsa04010") {
    graphNEL = addEdge(rtk_nodes, grb2_node, graphNEL, 1)
    graphNEL = addEdge(grb2_node, sos_nodes, graphNEL, 1)
  }
  
  # Next, weight the edges by whether they are inhibitory or activating. 
  # @_@
  # For each edge in the graph (pathway_graph or graphNEL), use the KEGG edge data to determine whether it is an activating or inhibitory edge. If it is activating, leave it alone. Otherwise, set it to -1. 
  kegg_edge_data = getKEGGedgeData(graphNEL)
  kegg_edges = edges(graphNEL)
  kegg_edge_weights = edgeWeights(graphNEL)
  # Generate a list of all the edges. 
  all_edges = c()
  for(first_node in names(kegg_edges)) {
    if(length(kegg_edges[[first_node]]) > 0) all_edges = c(all_edges, paste0(first_node, "~", kegg_edges[[first_node]]))
  }
        
  for(edge in all_edges) {
    first_node = str_split(edge, "~") %>% unlist %>% .[1]
    second_node = str_split(edge, "~") %>% unlist %>% .[2]
    edge_data = getKEGGedgeData(graphNEL)[[edge]] # This will be NULL for the edges we added on, since we only added the edges, not any metadata. 
    if(!is.null(edge_data)) {
      if(length(getSubtype(edge_data)) > 0) {
        edge_subtype = getName(getSubtype(getKEGGedgeData(graphNEL)[[edge]])$subtype) # "activation" or "inhibition".
        } else {
          edge_subtype = "activation"
        }
    } else {
        edge_subtype = "activation"
      }
    
    if(edge_subtype=="inhibition") kegg_edge_weights[[first_node]][second_node] = -1
  }
  #edgeWeights(graphNEL) = kegg_edge_weights
  # Above line of code doesn't work--see comment below. 
  
  # Then convert to iGraph.
  igraph = graph_from_graphnel(graphNEL, name = TRUE, weight = TRUE,
  unlist.attrs = TRUE)
  # Set the weights of the iGraph to be kegg_edge_weights.
  # (We can't change the weights of a graphNEL object, apparently, so we have to do it this way. ... Of course, this assumes that the edges are in the same order in igraph as they are once you unlist kegg_edge_weights. ... If we ever update any of the packages used here, we will have to 2x check this.)
  edge_attr(igraph)$weight = unlist(kegg_edge_weights)
  
  # Get the downstream nodes of the target of the drug. 
  # https://rdrr.io/github/robertness/lucy/man/get_downstream_nodes.html 
  GDSC_drug_targets_KEGG_i = GDSC_drug_targets_KEGG %>% .[. %in% names(V(igraph))]
  for(drug_target in GDSC_drug_targets_KEGG_i) {
    print(paste0("Working on target ", drug_target, " in pathway ", pathway, "."))
    
    w = V(igraph)[drug_target]
     possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      downstream_nodes = V(igraph)[get_downstream_nodes(igraph, w)]
    }, error=function(cond) {
      message(paste0("There was a problem getting the nodes downstream from target ", drug_target, ":"))
      message(cond)
    }
  )
    if(inherits(possibleError, "error") | !exists("downstream_nodes")) {
      print(paste0("Skipping drug target ", drug_target, "."))
      next
    }
    
    # Check if there are any downstream nodes. If not, move on to the next target.
    if(length(downstream_nodes) < 1) {
      print(paste0("Target ", drug_target, " has no downstream nodes. Moving on!"))
      next
    }
    downstream_node_names = downstream_nodes %>% names() # %>% paste(collapse=",")
    
    # Determine the effect of the target on each node? (I.e. upregulated or downregulated. ... This is important, but can we do it without having to do it manually??)
    # Get all the edges between the target and the downstream nodes. 
    #all_paths = all_simple_paths(igraph, from = V(igraph)[drug_target], to = downstream_nodes, mode = "out")
    possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      all_paths = shortest_paths(igraph, from = V(igraph)[drug_target], to = downstream_nodes, weights = rep(1, length(unlist(kegg_edge_weights)))) %>% .$vpath # Have to set the weights to all be positive; otherwise, the algorithm doesn't work. Using all_simple_paths returns all possible paths. 
    }, error=function(cond) {
      message(paste0("There was a problem getting the shortest paths from target ", drug_target, ":"))
      message(cond)
    }
  )
    if(inherits(possibleError, "error") | !exists("all_paths")) {
      print(paste0("Skipping drug target ", drug_target, "."))
      next
    }

    effects = c()
    for(i in 1:length(all_paths)) {
      # Get path i. 
      path = all_paths[[i]] %>% names()
      # Because of the way get.edge.ids works, we need to duplicate all inner vertices (vertices that are not the first or last) in path in order to get all the edges that make up the path.
      if(length(path) > 2) {
        vertices = c(path[1], rep(path[2:(length(path)-1)], each = 2), path[length(path)])
      } else {
        vertices = path
      }
      # Get the IDs of the edges connecting vertices in the path. 
      edge_ids = get.edge.ids(igraph, vertices, directed = TRUE, error = FALSE,
  multi = FALSE)
      # Get the weights of those edges.
      weights = edge_attr(igraph, "weight", index = E(igraph)[edge_ids])
      # Multiply them together. 
      # https://stackoverflow.com/a/62561005
      effect = ifelse(prod(weights) < 0, -1, 1)
      # If < 0, then -1; if > 0, then 1.
      effects = c(effects, effect)
    }
    
    # Add to the table. 
    GDSC_drug_target_downstream_node_data_KEGG = rbind(GDSC_drug_target_downstream_node_data_KEGG, data.frame(
    Pathway = rep(pathway, length(downstream_nodes)),
    Target = rep(drug_target, length(downstream_nodes)),
    DownstreamNodes = names(downstream_nodes),
    Effects = effects,
    stringsAsFactors = F
    ))
    
    # Remove old "downstream_nodes" and "all_paths" so that the error checks can be triggered properly.
    rm(downstream_nodes, all_paths)
  }
    
}

# Save.
GDSC_drug_target_downstream_node_data_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_downstream_node_data", processing_stage = "Processed")
write.table(GDSC_drug_target_downstream_node_data_KEGG, GDSC_drug_target_downstream_node_data_KEGG_filename, sep=",", row.names=F)
```

#### Transcription factors and their targets for each pathway
```{r}
GDSC_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
GDSC_drug_target_pathway_data_KEGG = read.csv(GDSC_drug_target_pathway_data_KEGG_filename)

KEGG_pathways_complete_filename = paste0(folder_generator(data_dir, data_source = "GSEA-MSigDB", data_type = "Misc", processing_stage = "Raw"), "c2.cp.kegg.v7.1.symbols.gmt")
KEGG_pathways_complete = GSA.read.gmt(KEGG_pathways_complete_filename)
GDSC_drug_target_downstream_node_data_KEGG = read.csv(GDSC_drug_target_downstream_node_data_KEGG_filename)

# Load the TRRUST data. 
TRRUST_data_filename = paste0(folder_generator(data_dir, data_source = "TRRUST", data_type = "Misc", processing_stage = "Raw"), "trrust_rawdata.human.tsv")
TRRUST_data = read.table(TRRUST_data_filename, header = F)
colnames(TRRUST_data) = c("TF", "Target",	"ModeOfRegulation",	"PMID")
# Exclude all unknown interactions from the TRRUST data. 
TRRUST_data = TRRUST_data %>% dplyr::filter(ModeOfRegulation != "Unknown")

# For each unique pathway in GDSC_drug_target_pathway_data_KEGG, get the transcription factors from that pathway. 
GDSC_drug_target_txnal_target_data_KEGG_TRRUST = data.frame(
  Pathway = character(),
  DrugTarget = character(),
  TFentrez = character(),
  TFsymbol = character(),
  TranscriptionalTarget = character(),
  ModeOfRegulation = character(),
  stringsAsFactors = F
)

for(pathway in unique(GDSC_drug_target_pathway_data_KEGG$PathwayID)) {
  # Get the drug targets in that pathway. 
  pathway_drug_targets = GDSC_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Pathway==pathway) %>% dplyr::select(Target) %>% unlist() %>% unique()
  
  for(drug_target in pathway_drug_targets) {
    # Get the nodes downstream of that target. Remove any nodes that are not genes. 
    downstream_nodes = GDSC_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Pathway==pathway & Target == drug_target & regexPipes::grepl(.$DownstreamNodes, "hsa\\:")) %>% dplyr::select(DownstreamNodes, Effects) %>% distinct()
  
    if(nrow(downstream_nodes) < 1) {
      print(paste0("Target ", drug_target, " has no downstream gene nodes. Skipping this one!"))
      next
    }
    
    # Convert the downstream nodes from their KEGG ID to their gene name. 
    hs = org.Hs.eg.db
    keys = downstream_nodes$DownstreamNodes %>% unlist() %>% regexPipes::gsub("hsa\\:", "")
    x = AnnotationDbi::select(hs, 
               keys = keys,
               columns = c("SYMBOL", "ENTREZID"),
               keytype = "ENTREZID") %>% .[complete.cases(.),]
    # We will be back-converting from symbols to ENTREZ IDs, so make sure that each symbol maps to only ONE ENTREZ ID. 
    # ... Which, come to think of it, shouldn't be a problem, since we started out with ENTREZ IDs, and I don't think KEGG had duplicates. ... 
  
    # Get the transcription factors.
    # https://stackoverflow.com/questions/10586652/r-preserve-order-when-using-matching-operators-in
    tfs = intersect(unique(TRRUST_data$TF), x$SYMBOL)
    if(length(tfs) < 1) {
      print(paste0("Target ", drug_target, " has no downstream transcription factors. Skipping this one!"))
      next
    }
    
    tfs_entrez = x %>% .[match(tfs, .$SYMBOL),] %>% .$ENTREZID %>% paste0("hsa:", .)
    names(tfs_entrez) = tfs
  
    # Get the targets of those transcription factors.
    for(tf in tfs) {
      txn_target = TRRUST_data %>% dplyr::filter(TF==tf) %>% dplyr::select(TF, Target, ModeOfRegulation)
    
      # Add to the table if there are any transcriptional targets. 
      GDSC_drug_target_txnal_target_data_KEGG_TRRUST = rbind(GDSC_drug_target_txnal_target_data_KEGG_TRRUST, data.frame(
        Pathway = rep(pathway, nrow(txn_target)),
        DrugTarget = rep(drug_target, nrow(txn_target)),
        TFentrez = rep(tfs_entrez[tf], nrow(txn_target)),
        TFsymbol = txn_target$TF,
        TranscriptionalTarget = txn_target$Target,
        ModeOfRegulation = txn_target$ModeOfRegulation,
        stringsAsFactors = F
        ))
    }
    
  }
  
}

# Add an effect column.
GDSC_drug_target_txnal_target_data_KEGG_TRRUST$Effect = ifelse(GDSC_drug_target_txnal_target_data_KEGG_TRRUST$ModeOfRegulation=="Repression", -1, 1)

# Save.
GDSC_drug_target_txnal_target_data_KEGG_TRRUST_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG_TRRUST", extension = ".csv", additional_info = "target_txnal_target_data", processing_stage = "Processed")
write.table(GDSC_drug_target_txnal_target_data_KEGG_TRRUST, GDSC_drug_target_txnal_target_data_KEGG_TRRUST_filename, sep=",", row.names=F)
```

#### Final effects of drugs on downstream targets
Combine the data from GDSC_drug_target_data_KEGG, drug_genes_table and GDSC_drug_target_txnal_target_data_KEGG_TRRUST (i.e. multiply the effects) to get the final effect of the drug on each of its transcriptional targets. 
```{r}
GDSC_drug_target_txnal_target_data_KEGG_TRRUST_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG_TRRUST", extension = ".csv", additional_info = "target_txnal_target_data", processing_stage = "Processed")
GDSC_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
GDSC_drug_target_downstream_node_data_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_downstream_node_data", processing_stage = "Processed")
GDSC_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")

GDSC_drug_target_txnal_target_data_KEGG_TRRUST = read.csv(GDSC_drug_target_txnal_target_data_KEGG_TRRUST_filename)
GDSC_drug_target_pathway_data_KEGG = read.csv(GDSC_drug_target_pathway_data_KEGG_filename)
GDSC_drug_target_downstream_node_data_KEGG = read.csv(GDSC_drug_target_downstream_node_data_KEGG_filename)
GDSC_drug_target_data_KEGG = read.csv(GDSC_drug_target_data_KEGG_filename)

GDSC_drug_target_data_TRRUST = data.frame(
  Drug = character(),
  Target = character(),
  Effect = numeric(),
  stringsAsFactors = F
)

# Indirect targets. 
for(drug in unique(GDSC_drug_target_data_KEGG$Drug)) {
  # For each drug, get its corresponding targets from GDSC_drug_target_data_KEGG. 
  drug_targets = GDSC_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist() %>% paste0("hsa:", .)
  
  # Get the pathways this drug is involved in. We are going to restrict transcriptional effects to the pathways the drug is known to be involved in. (E.g., if drug A targets EGFR, even if EGFR is involved in multiple pathways, we will only consider the pathways that drug A has listed in KEGG.)
  drug_pathways = GDSC_drug_target_pathway_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(PathwayID) %>% unlist() %>% unique
  
  for(drug_target in drug_targets) {
    # Get the effect of the drug on this target.
    target_edited = drug_target %>% regexPipes::gsub("hsa\\:", "")
    fx_drug_on_target = GDSC_drug_target_data_KEGG %>% dplyr::filter(Drug==drug & Target==target_edited) %>% dplyr::select(Effect) %>% unlist()
    
    # For each drug target, get the TFs that are downstream of that target. 
    tfs = GDSC_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & Pathway %in% drug_pathways) %>% dplyr::select(TFentrez) %>% unlist() %>% as.character() %>% unique() # Pathway %in% drug_pathways ensures that only the downstream TFs in the pathways associated with that drug are chosen.
    
    # For each TF, get the downstream transcriptional targets from GDSC_drug_target_txnal_target_data_KEGG_TRRUST.
    for(tf in tfs) {
      txn_targets = GDSC_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & Pathway %in% drug_pathways & TFentrez==tf) %>% dplyr::select(TranscriptionalTarget) %>% unlist() %>% as.character() %>% unique() # Pathway %in% drug_pathways ensures that only the downstream txnal targets in the pathways associated with that drug are chosen.
    
      # For each downstream transcriptional target, calculate the final effect. 
      # Use GDSC_drug_target_downstream_node_data_KEGG.
      for(txn_target in txn_targets) {
        print(paste0("Calculating effect of drug ", drug, " on target ", txn_target, "."))
        # Final effect = effect of drug on target (fx_drug_on_target, already calculated in outer loop) * effect of drug target on TF (from GDSC_drug_target_downstream_node_data_KEGG) (fx_drug_target_on_tf) * effect of TF on transcriptional target (from GDSC_drug_target_txnal_target_data_KEGG_TRRUST) (fx_tf_on_txn_target).
        fx_drug_target_on_tf = GDSC_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Target == drug_target & DownstreamNodes == tf & Pathway %in% drug_pathways) %>% dplyr::select(Effects) %>% unlist()
        fx_tf_on_txn_target = GDSC_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & TFentrez==tf & TranscriptionalTarget == txn_target & Pathway %in% drug_pathways) %>% dplyr::select(Effect) %>% unlist()
        final_effect = prod(fx_drug_on_target, fx_drug_target_on_tf, fx_tf_on_txn_target)
        
        GDSC_drug_target_data_TRRUST = rbind(GDSC_drug_target_data_TRRUST, data.frame(
          Drug = drug,
          Target = txn_target,
          Effect = final_effect,
          stringsAsFactors = F
          ))
        }
    }
  }
}

# Direct targets. 
colnames(GDSC_drug_target_data_TRRUST)[3] = "Effect"
hs = org.Hs.eg.db
keys = unique(GDSC_drug_target_data_KEGG$Target) %>% as.character()
x = AnnotationDbi::select(hs, 
           keys = keys,
           columns = c("SYMBOL", "ENTREZID"),
           keytype = "ENTREZID") %>% .[complete.cases(.),] %>% distinct()
for(drug in unique(GDSC_drug_target_data_KEGG$Drug)) {
  # For each drug, get its corresponding targets and effects from GDSC_drug_target_data_KEGG. 
  drug_targets = GDSC_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist()
  final_effects = GDSC_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Effect) %>% unlist()
  
  # Convert to gene symbol.
  #keggGet(kegg_drug_id) %>% .[[1]] %>% .$NAME %>% str_split(",") %>% .[[1]] %>% .[1]
  a = x$ENTREZID
  b = x$SYMBOL
  target_ids = b[match(drug_targets, a)]
  # Alternative: 
  #target_ids = c()
  #for(target in unique(GDSC_drug_target_data_KEGG$Target)) {
  #  print(paste0("Getting gene ID for target ", target, "."))
  #  target_ids = c(target_ids, keggGet(paste0("hsa:",target)) %>% .[[1]] %>% .$NAME %>% str_split(",") %>% .[[1]] %>% .[1])
  #}
  
  # Add to GDSC_drug_target_data_TRRUST. 
  GDSC_drug_target_data_TRRUST = rbind(GDSC_drug_target_data_TRRUST, data.frame(
          Drug = rep(drug, length(final_effects)),
          Target = target_ids,
          Effect = final_effects,
          stringsAsFactors = F
          ))
}

# Keep only unique rows.
GDSC_drug_target_data_TRRUST = GDSC_drug_target_data_TRRUST %>% distinct()

# Split the dataframe into a list, to match the CTD drug-target-data format and the format that most of the calcNetworkScores() functions use. 
GDSC_drug_target_data_TRRUST = split(GDSC_drug_target_data_TRRUST , f = GDSC_drug_target_data_TRRUST$Drug)

# Remove all entries in the list whose tables have 0 rows. (28 June 2021.)
for(entry in names(GDSC_drug_target_data_TRRUST)) {
  if(nrow(GDSC_drug_target_data_TRRUST[[entry]]) < 1) {
    GDSC_drug_target_data_TRRUST[[entry]] = NULL
  } 
}

# Save.
GDSC_drug_target_data_TRRUST_filename = filename_generator(data_dir, data_source = "GDSC", data_type = "Drugs", data_set = "TRRUST", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(GDSC_drug_target_data_TRRUST, GDSC_drug_target_data_TRRUST_filename)
#write.table(GDSC_drug_target_data_TRRUST, paste0(data_dir, "Processed_data/GDSC/GDSC_kegg_drug_final_effects.csv"), sep = ",", row.names = F)
```

## pData
```{r}
# Load CTD drug data. 
if(!exists("GDSC_drug_target_data_CTD")) GDSC_drug_target_data_CTD = readRDS(GDSC_drug_target_data_CTD_filename)
# Load DrugBank drug data. 
if(!exists("GDSC_drug_target_data_DrugBank_KEGG")) GDSC_drug_target_data_DrugBank_KEGG = readRDS(GDSC_drug_target_data_DrugBank_KEGG_filename)
# Load TRRUST drug data. 
if(!exists("GDSC_drug_target_data_TRRUST")) GDSC_drug_target_data_TRRUST = readRDS(GDSC_drug_target_data_TRRUST_filename)

# Load the dictionary for the standardization of NCI-60 cell-line names.
NCI60_cell_line_name_dict = read.csv(NCI60_cell_line_name_dict_filename)
# Load the GDSC data.
GDSC1 = read.csv(GDSC_1_filename)
GDSC2 = read.csv(GDSC_2_filename)
GDSC2$Drug.name = str_to_lower(GDSC2$Drug.name)
GDSC1$Drug.name = str_to_lower(GDSC1$Drug.name)

# See how many of the NCI-60 cell lines are in the GDSC data.
GDSC2_cell_lines = GDSC2$Cell.line.name %>% unique
NCI60_cell_lines_GDSC = NCI60_cell_line_name_dict$GDSC_name 
sum(GDSC2_cell_lines %in% NCI60_cell_lines_GDSC)
intersect(GDSC2_cell_lines, NCI60_cell_lines_GDSC)
setdiff(NCI60_cell_lines_GDSC, GDSC2_cell_lines)

GDSC1_cell_lines = GDSC1$Cell.line.name %>% unique
NCI60_cell_lines_GDSC = NCI60_cell_line_name_dict$GDSC_name 
sum(GDSC1_cell_lines %in% NCI60_cell_lines_GDSC)
intersect(GDSC1_cell_lines, NCI60_cell_lines_GDSC)
setdiff(NCI60_cell_lines_GDSC, GDSC1_cell_lines)

# Subset the GDSC data for the following analyses, divided by where we got the drug-target data from:
# 1) protein targets from KEGG/DrugBank,
# Get a list of all the drugs that have protein targets.
drugs_with_protein_targets = GDSC_drug_target_data_DrugBank_KEGG %>% names %>% unique %>% as.character
GDSC2_subset_KEGG_DB_targets = GDSC2 %>% dplyr::filter(Drug.name %in% drugs_with_protein_targets & Cell.line.name %in% NCI60_cell_lines_GDSC)
GDSC1_subset_KEGG_DB_targets = GDSC1 %>% dplyr::filter(Drug.name %in% drugs_with_protein_targets & Cell.line.name %in% NCI60_cell_lines_GDSC)
setdiff(drugs_with_protein_targets, GDSC2$Drug.name %>% unique)
GDSC1_subset_KEGG_DB_targets$Drug.name %>% unique %>% length
GDSC2_subset_KEGG_DB_targets$Drug.name %>% unique %>% length
saveRDS(GDSC1_subset_KEGG_DB_targets, GDSC1_subset_KEGG_DB_targets_filename)
saveRDS(GDSC2_subset_KEGG_DB_targets, GDSC2_subset_KEGG_DB_targets_filename)

# 2) transcriptional targets from TRRUST (via analysis of pathways in KEGG),
drugs_with_txnal_targets = GDSC_drug_target_data_TRRUST %>% names %>% unique %>% as.character
GDSC1_subset_TRRUST_targets = GDSC1 %>% dplyr::filter(Drug.name %in% drugs_with_txnal_targets & Cell.line.name %in% NCI60_cell_lines_GDSC)
GDSC2_subset_TRRUST_targets = GDSC2 %>% dplyr::filter(Drug.name %in% drugs_with_txnal_targets & Cell.line.name %in% NCI60_cell_lines_GDSC)
GDSC1_subset_TRRUST_targets$Drug.name %>% unique %>% length
GDSC2_subset_TRRUST_targets$Drug.name %>% unique %>% length
saveRDS(GDSC1_subset_TRRUST_targets, GDSC1_subset_TRRUST_targets_filename)
saveRDS(GDSC2_subset_TRRUST_targets, GDSC2_subset_TRRUST_targets_filename)

# 3) protein and transcriptional targets from CTD. 
GDSC_drug_target_data_CTD_table = do.call(rbind, GDSC_drug_target_data_CTD)
# Correct the names. 
GDSC_name_corrections = read_xls(GDSC_name_corrections_filename)
a = GDSC_name_corrections$drug_name_corrected %>% as.character %>% str_to_lower()
b = GDSC_name_corrections$drug_name %>% as.character %>% str_to_lower()
GDSC_drug_target_data_CTD_table$Drug = b[match(GDSC_drug_target_data_CTD_table$Drug, a)]
drugs_with_CTD_targets = GDSC_drug_target_data_CTD_table %>% .$Drug %>% unique %>% as.character
GDSC1_subset_CTD_targets = GDSC1 %>% dplyr::filter(Drug.name %in% drugs_with_CTD_targets & Cell.line.name %in% NCI60_cell_lines_GDSC)
GDSC2_subset_CTD_targets = GDSC2 %>% dplyr::filter(Drug.name %in% drugs_with_CTD_targets & Cell.line.name %in% NCI60_cell_lines_GDSC)
GDSC1_subset_CTD_targets$Drug.name %>% unique %>% length
GDSC2_subset_CTD_targets$Drug.name %>% unique %>% length
saveRDS(GDSC1_subset_CTD_targets, GDSC1_subset_CTD_targets_filename)
saveRDS(GDSC2_subset_CTD_targets, GDSC2_subset_CTD_targets_filename)

# Generation of final pData file.
# All pData has at the least the following columns:
# Drugs, Sample, Dataset
# The GDSC pData will also contain the IC50. 
GDSC_subsets = list()
GDSC_subsets[["GDSC1_subset_KEGG_DB_targets"]] = GDSC1_subset_KEGG_DB_targets_filename
GDSC_subsets[["GDSC2_subset_KEGG_DB_targets"]] = GDSC2_subset_KEGG_DB_targets_filename
GDSC_subsets[["GDSC1_subset_TRRUST_targets"]] = GDSC1_subset_TRRUST_targets_filename
GDSC_subsets[["GDSC2_subset_TRRUST_targets"]] = GDSC2_subset_TRRUST_targets_filename
GDSC_subsets[["GDSC1_subset_CTD_targets"]] = GDSC1_subset_CTD_targets_filename
GDSC_subsets[["GDSC2_subset_CTD_targets"]] = GDSC2_subset_CTD_targets_filename

# For cell-line name correction.
a = NCI60_cell_line_name_dict$GDSC_name %>% as.character
b = NCI60_cell_line_name_dict$Standardized_name %>% as.character
for(subset in names(GDSC_subsets)) {
  print(paste0("Working on set ", subset, "."))
  
  # Load the data.
  pData = readRDS(GDSC_subsets[[subset]])
  
  # Keep only the selected columns. 
  pData = pData[,c("Drug.name", "Cell.line.name", "IC50")]
  # Rename the the columns. 
  colnames(pData) = c("Drugs", "Sample", "IC50")
  
  # Add a column (Dataset).
  pData$Dataset = subset %>% str_split("_") %>% unlist %>% .[1] %>% as.character
  
  # Correct the cell-line names.
  pData$Sample = b[match(pData$Sample, a)]
  
  # Save. 
  print(paste0("Saving set ", subset, "."))
  saveRDS(pData, GDSC_subsets[[subset]])
  
}
```

### Name correction
```{r}
# 11 August 2021 - change "venotoclax" to "venetoclax". 
GDSC_subsets = list()
GDSC_subsets[["GDSC1_subset_KEGG_DB_targets"]] = GDSC1_subset_KEGG_DB_targets_filename
GDSC_subsets[["GDSC2_subset_KEGG_DB_targets"]] = GDSC2_subset_KEGG_DB_targets_filename
GDSC_subsets[["GDSC1_subset_TRRUST_targets"]] = GDSC1_subset_TRRUST_targets_filename
GDSC_subsets[["GDSC2_subset_TRRUST_targets"]] = GDSC2_subset_TRRUST_targets_filename
GDSC_subsets[["GDSC1_subset_CTD_targets"]] = GDSC1_subset_CTD_targets_filename
GDSC_subsets[["GDSC2_subset_CTD_targets"]] = GDSC2_subset_CTD_targets_filename

for(subset in names(GDSC_subsets)) {
  print(paste0("Working on set ", subset, "."))
  
  # Load the data.
  pData = readRDS(GDSC_subsets[[subset]])
  
  # Correction: venotoclax -> venetoclax.
  pData$Drugs = pData$Drugs %>% regexPipes::gsub("venotoclax", "venetoclax")
  
  # Save. 
  print(paste0("Saving set ", subset, "."))
  saveRDS(pData, GDSC_subsets[[subset]])
  
}
```

# ALMANAC
## pData
We will performing the following:
1) Replace NSCs with drug names.
2) Keep only the highest concentrations of drugs.
3) Correct the ExpectedGrowth. 

### Import of raw data and basic cleaning
```{r}
# Load the raw data.
ALMANAC_dat_raw = read.csv(ALMANAC_dat_raw = read.csv(paste0(folder_generator(data_dir, data_source = "ALMANAC", data_type = "pData", processing_stage = "Raw"), "ComboDrugGrowth_Nov2017.csv"), stringsAsFactors = F), stringsAsFactors = F)

# Correct the percent growth.
# Keep the corrected percent growth in ALMANAC_dat_raw, because we will need it when we split off into both ALMANAC_dat and single_agent_growth. 
pData = ALMANAC_dat_raw
pData$PERCENTGROWTHCORRECTED = round(100 * (pData$TESTVALUE - pData$TZVALUE) / (pData$CONTROLVALUE - pData$TZVALUE), 3)

# Save intermediate pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed1"))
rm(pData)
gc()
```

### Standardization of drug names
```{r}
# Load the pData from the last step.
pData = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed1"))

# Load the NSC-to-drug-name mapping.
nsc_drug_name_mapping = read.csv(paste0(folder_generator(data_dir, data_source = "ALMANAC", data_type = "Metadata", processing_stage = "Raw"), "NSC_chemical_names_dictionary.csv"), stringsAsFactors = F)

# Correct names.
# https://stackoverflow.com/a/3905442
a = nsc_drug_name_mapping$NSC
b = nsc_drug_name_mapping$Name
pData$DRUGNAME1 = b[match(pData$NSC1, a)]
pData$DRUGNAME2 = b[match(pData$NSC2, a)]

# Merge names into single column. 
pData$DRUGS = paste(pData$DRUGNAME1, pData$DRUGNAME2, sep="_")

# Check.
#sum(is.na(pData$DRUGNAME1)) + sum(is.na(pData$DRUGNAME2))

# Save intermediate pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed2"))
rm(pData)
gc()
```

### Standardization of cell-line names
(See data_preparation_functions.R.)
```{r}
# Read the pData from the last step.
pData = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed2"))

# Convert pData to a data.table. 
setDT(pData)

# Standardize the cell-line names so they match those in the NCI-60 data. Specifically, make the following changes manually:
# Remove the forward slashes when they're not part of the cell name.
# When slashes (forward or backslashes) are part of the cell name, change them to dashes. 
NCI60_names = read.csv(paste0(folder_generator(data_dir, data_source = "NCI-60", data_type = "Metadata", processing_stage = "Processed"), "NCI-60_cell_line_names_ALMANAC_GEO_GDSC_CCLE.csv"), colClasses = rep("character", 5)) # Maps the different cell line names to the standardized names.
pData$CELLNAME = as.factor(base::gsub("NCI/", "NCI-", pData$CELLNAME))
pData$CELLNAME = as.factor(base::gsub("/.+$", "", pData$CELLNAME))
pData$CELLNAME = as.factor(base::gsub("\\\032", "", pData$CELLNAME))
pData$CELLNAME = as.factor(base::gsub("HL-60\\(TB\\)", "HL-60", pData$CELLNAME))
setdiff(NCI60_names$ALMANAC_name, pData$CELLNAME)
setdiff(pData$CELLNAME, NCI60_names$ALMANAC_name)

# Now we can standardize using the table.
# Replace a with b. 
a = NCI60_names$ALMANAC_name
b = NCI60_names$Standardized_name
names(b) = a
pData$CELLNAME = b[match(pData$CELLNAME, a)]
# Check.
sum(is.na(unique(pData$CELLNAME)))==0

# Make sure the order of the cell lines in the ALMANAC data matches those in the eset. 
cols = c("CELLNAME", "NSC1", "NSC2")
setkeyv(pData, cols, verbose=getOption("datatable.verbose"))
# identical(unique(as.character(pData$CELLNAME)), colnames(exprs(GSE32474)))
# Well, the order may be the same, but the ALMANAC data has 2 more cell lines than the GEO data.

# Save intermediate pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed3"))
rm(pData)
gc()
```

### Addition of cancer types
This must be conducted AFTER the standardization of cell-line names! 
```{r}
# Read the pData from the last step.
pData = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed3"))

# Load the mapping file.
NCI60_cancer_types = read.csv(paste0(folder_generator(data_dir, data_source = "NCI-60", data_type = "Metadata", processing_stage = "Processed"), "NCI-60_cancer_types.csv"))

# Create the vector of cancer types.
a = NCI60_cancer_types$CellLine %>% as.character
b = NCI60_cancer_types$TissueType %>% as.character
names(b) = a
pData$CANCERTYPE = b[match(pData$CELLNAME, a)]
unique(pData$CANCERTYPE)

# Save intermediate pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed4"))
rm(pData)
gc()
```

### Branching of data
Data (pData) branches into pData (containing the combinations) and single_agent_growth (containing the single-agent performances.)
```{r}
# Read the pData from the last step.
pData = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed4"))

# Keep only the valid rows and the combinations. 
pData = pData %>% dplyr::filter(VALID=="Y" & !is.na(NSC2))

# Save intermediate pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed5"))
rm(pData)
gc()
```

### Filtering of concentrations
We will keep only the best performance of each drug combination. 
```{r}
# Read the pData from the last step.
pData = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed5"))

# https://community.rstudio.com/t/summarise-max-but-keep-all-columns/52449/4
pData = pData %>% 
  group_by(CELLNAME, NSC1, NSC2) %>% 
  mutate(BESTPERCENTGROWTH = min(PERCENTGROWTH)) %>% 
  ungroup() %>% 
  dplyr::filter(PERCENTGROWTH==BESTPERCENTGROWTH)

# Save intermediate pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed6"))
rm(pData)
gc()
```

### Calculation of corrected ExpectedGrowthCorrected
```{r}
# Read the pData from the last step.
pData = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed6"))

# Get the single-agent performance. 
pData_intermed_ALMANAC_4 = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Intermed4")) # 4 because that's where we branched.
single_agent_growth = pData_intermed_ALMANAC_4 %>% 
  dplyr::filter(is.na(NSC2)) %>%
  group_by(NSC1, CELLNAME) %>% 
  mutate(BESTPERCENTGROWTH = min(PERCENTGROWTHCORRECTED)) %>% 
  ungroup() %>% 
  dplyr::filter(PERCENTGROWTHCORRECTED==BESTPERCENTGROWTH)

# Create a column that will serve as a unique identifier for a given cell line x single drug combination. 
# This column will have to be in both single_agent_growth and pData, as it will be the link between the two. 
single_agent_growth$CELLNAMENSC = paste(single_agent_growth$CELLNAME, single_agent_growth$NSC1, sep = "_")
pData$CELLNAMENSC1 = paste(pData$CELLNAME, pData$NSC1, sep = "_")
pData$CELLNAMENSC2 = paste(pData$CELLNAME, pData$NSC2, sep = "_")
# Create a function that will get the single-agent performance from single_agent_growth based on the unique identifier created immediately above. 
getSingleAgentPercentGrowth = function(cellnamedrugcombo) {
  return(single_agent_growth %>% dplyr::filter(CELLNAMENSC==cellnamedrugcombo) %>% dplyr::select(BESTPERCENTGROWTH) %>% unlist())
}

# Add the single-agent performance to pData. 
a = single_agent_growth$CELLNAMENSC
b = single_agent_growth$BESTPERCENTGROWTH
names(b) = a
pData$DRUG1PERCENTGROWTH = b[match(pData$CELLNAMENSC1, a)]
pData$DRUG2PERCENTGROWTH = b[match(pData$CELLNAMENSC2, a)]

# Calculate the expected percent growth. 
calcExpectedPercentGrowth = function(i, dataset) {
  print(paste0("Calculating corrected ExpectedGrowth for row ", i, " of ", nrow(dataset), "."))
  drugA = dataset[i, "NSC1"] %>% unlist
  drugB = dataset[i, "NSC2"] %>% unlist
  cellname = dataset[i, "CELLNAME"] %>% unlist

  # Calculate the ExpectedGrowth.
  # Get the growth (PERCENTGROWTHCORRECTED) of drug 1 and drug 2 for cell line cell_line. 
  drugAGrowth = single_agent_growth %>% dplyr::filter(NSC1==drugA & CELLNAME == cellname) %>% dplyr::select(BESTPERCENTGROWTH) %>% unlist()
  drugBGrowth = single_agent_growth %>% dplyr::filter(NSC1==drugB & CELLNAME == cellname) %>% dplyr::select(BESTPERCENTGROWTH) %>% unlist()
  
  # Calculate the ExpectedGrowth per Holbeck et al's equation. 
  if(is.finite(drugAGrowth) & is.finite(drugBGrowth)) {
    if(drugAGrowth <= 0 | drugBGrowth <= 0) {
      ExpectedGrowthCorrected = min(drugAGrowth, drugBGrowth)
    } else {
      drugAGrowth = min(drugAGrowth, 100) # This truncates the growth fraction at 1. I.e., it does not allow for growth in excess of 100%. The same with the next line.
      drugBGrowth = min(drugBGrowth, 100)
      ExpectedGrowthCorrected = drugAGrowth * drugBGrowth / 100      }
    } else {
      ExpectedGrowthCorrected = NA
    } # End if/else drugAGrowth and drugBGrowth are both defined.
  
  return(ExpectedGrowthCorrected)
  
}

system.time({
pData$EXPECTEDGROWTHCORRECTED = sapply(1:nrow(pData), calcExpectedPercentGrowth, pData)
})

# Calculate the corrected ComboScore using the corrected percent growth and the corrected expected growth. 
pData$COMBOSCORECORRECTED = pData$EXPECTEDGROWTHCORRECTED - pData$PERCENTGROWTHCORRECTED

# Save pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed"))
saveRDS(single_agent_growth, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed_singles"))

# Update 08/21/2021: rename columns to match those expected by calcNetworkScores.R
# Combos.
ALMANAC_pData = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed"))
ALMANAC_pData$Dataset = "ALMANAC"
ALMANAC_pData = ALMANAC_pData %>% dplyr::rename(Sample = CELLNAME)
saveRDS(ALMANAC_pData, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed"))
# Singles.
ALMANAC_pData_singles = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed_singles"))
ALMANAC_pData_singles$Dataset = "ALMANAC"
ALMANAC_pData_singles = ALMANAC_pData_singles %>% dplyr::rename(Sample = CELLNAME)
saveRDS(ALMANAC_pData_singles, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed_singles"))
rm(ALMANAC_pData, pData, ALMANAC_pData_singles)
gc()

# Update 08/21/2021: convert all drug names to lower-case.
# Combos.
ALMANAC_pData = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed"))
ALMANAC_pData = ALMANAC_pData %>% dplyr::rename(Drugs = DRUGS)
ALMANAC_pData$Drugs = ALMANAC_pData$Drugs %>% str_to_lower()
saveRDS(ALMANAC_pData, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed"))
rm(ALMANAC_pData)
# Singles.
ALMANAC_pData_singles = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed_singles"))
ALMANAC_pData_singles = ALMANAC_pData_singles %>% dplyr::rename(Drugs = DRUGS)
ALMANAC_pData_singles$Drugs = ALMANAC_pData_singles$Drugs %>% regexPipes::gsub("_NA", "") %>% str_to_lower()
saveRDS(ALMANAC_pData_singles, filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed_singles"))
rm(ALMANAC_pData_singles)
gc()
```

## Drug data
### Creation of drug list
```{r}
ALMANAC_pData = readRDS(filename_generator(data_dir, data_source = "ALMANAC", data_type = "pData", extension = ".rds", processing_stage = "Processed"))
ALMANAC_drugs = union(ALMANAC_pData$DRUGNAME1, ALMANAC_pData$DRUGNAME2)
# length(ALMANAC_drugs) == length(unique(ALMANAC_drugs))

# Save to file. 
write.table(ALMANAC_drugs, filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", extension = ".tsv", processing_stage = "Raw", additional_info = "names"), row.names = F, col.names = F, quote = F)
```

### CTD
#### Filtering
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Load the CTD data.
ALMANAC_drug_cgixns_CTD_raw = read.csv(paste0(folder_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", processing_stage = "Processed"), "CTD_chem_cgixns_1631950517461.csv"))

# Filter drugs to include the following: 1) has data, 2) is human, 3) has no cotreatment stuff, 4) includes information on increasing/decreasing activity/expression (not just "affects.")
ALMANAC_drug_cgixns_CTD_filtered = ALMANAC_drug_cgixns_CTD_raw %>% dplyr::filter(!base::grepl("found", Input) & 
                                          OrganismID == "9606" &
                                          !base::grepl("reaction", InteractionActions) & 
                                          !base::grepl("response", InteractionActions) & 
                                          !base::grepl("cotreatment", InteractionActions) &
                                          (
                                            base::grepl("increases\\^activity", InteractionActions) |
                                              base::grepl("increases\\^expression", InteractionActions) |
                                              base::grepl("decreases\\^activity", InteractionActions) |
                                              base::grepl("decreases\\^expression", InteractionActions)
                                            )
                                        )

# Save the filtered data.
ALMANAC_drug_cgixns_CTD_filtered_filename = paste0(folder_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", processing_stage = "Processed"), "ALMANAC_CTD_chem_cgixns_1631950517461_filtered.rds")
saveRDS(ALMANAC_drug_cgixns_CTD_filtered, ALMANAC_drug_cgixns_CTD_filtered_filename)
```

#### Target extraction
```{r echo = FALSE, eval=TRUE, include=FALSE}
ALMANAC_drug_cgixns_CTD_filtered_filename = paste0(folder_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", processing_stage = "Processed"), "ALMANAC_CTD_chem_cgixns_1631950517461_filtered.rds")

# Naming the modified function "getTargets2," how creative. 
getTargets2 = function(drug) {
  # For drug "drug," get the targets. 
  print(paste0("Getting targets for drug ", drug, "."))
  
  # Create an empty table to be returned for drugs without entries.
  empty_table = data.frame(
    Drug = character(),
    Target = character(),
    Effect = character(),
    stringsAsFactors = F
  )
  
  # Load the chemical-gene interactions from CTD (saved as a CSV file in /Data/CTD/ALMANAC.)
  possibleError = tryCatch(
    {
      # ALMANAC_drug_cgixns_CTD_filtered should already be loaded in the global environment. 
      # Keep only the interactions for the drug "drug" and found in humans.
      regex = paste0("^", drug, "$")
      CTD_subset = ALMANAC_drug_cgixns_CTD_filtered[ALMANAC_drug_cgixns_CTD_filtered$OrganismID=="9606" & (ALMANAC_drug_cgixns_CTD_filtered$ChemicalName==drug | ALMANAC_drug_cgixns_CTD_filtered$Input==drug | base::grepl(regex, ALMANAC_drug_cgixns_CTD_filtered$Input, ignore.case = T) | base::grepl(regex, ALMANAC_drug_cgixns_CTD_filtered$ChemicalName, ignore.case = T)),,drop=F]
    }, error=function(cond) {
      message(paste0("For getTargets(), there was a problem retrieving the chemical-gene interactions for the drug ", drug, ":"))
      message(cond)
    }
  )
  
  if(inherits(possibleError, "error") | !exists("CTD_subset")) {
    print(paste0("For getTargets(), there was a problem retrieving the chemical-gene interactions for the drug ", drug, "."))
    return(empty_table)
  }
  
  else {
    if(nrow(CTD_subset) < 1) return(empty_table)
    
    # We want only the interactions that include "[chemical name] (and not an analog) ... results in decreased/increased action/expression of [X protein/mRNA]."
    # regex = paste0(drug, " (?!\\banalog\\b)(binds to and results in |results in(\\s| (de|in)creased [^\\s]+ of and results in ))(de|in)creased (activity|expression) of") # Yes, there should be no space between "(?!\\banalog\\b)" and "results."
    # Standardize the drug name. 
    drug = CTD_subset$ChemicalName
    drug = drug[complete.cases(drug)][1]
  
    regex1 = paste0(" (?!\\banalog\\b)") # This will be set to negative, because we do NOT want the analogs. Just the drug itself. 
    regex2 = "(the reaction \\[|susceptibility to|co-treated|modified form)" # This will be set to negative, because we do NOT want the other drug-chemical interactions that the drug in question affects OR direct gene effects affected by other drugs. Just the direct gene effects. We also don't want co-treatments (for right now.) Finally, we don't want the modified forms of proteins. 
    regex3 = "results in (de|in)creased (activity|expression) of" # This will be set to positive, because we want to make sure that this phrase is present. 
    regex4 = "\\[" # We do NOT want something like "Carboplatin results in increased activity of [NFKB1 protein binds to RELA protein]"
    # We will use the regexPipes library to do this. 
    interactions = CTD_subset$Interaction %>% regexPipes::grep(drug, fixed = T, value = T) %>% regexPipes::grep(regex1, perl = T, value = T) %>% regexPipes::grep(regex2, value = T, invert = T) %>% regexPipes::grep(regex3, value = T) %>% regexPipes::grep(regex4, value = T, invert = T)
    # CTD_subset = CTD_subset[grep(regex, CTD_subset$Interaction, perl = T),,drop=F]
    
    # Build a data frame to hold the targets and the direction the drug affects the target in.
    # We won't distinguish between mRNA and protein here. 
    # Populate the data frame with the targets.
    targets = future_lapply(interactions, FUN = extractTarget, drug = drug)
    targets = as.data.frame(do.call(rbind, targets), stringsAsFactors = F)
    if(nrow(targets) > 0) {
      colnames(targets) = c("Drug", "Target", "Effect")
      targets$Effect = as.integer(as.character(targets$Effect))
      
      # Remove duplicates
      targets = unique(targets)
    }
    
  rm(CTD_subset)
  
  return(targets)
  }
}

# Check the format of the data frames that calcNetworkScore() uses. 

# Get the vector of drugs.
# Update 08/16/2021: now including even the drugs without KEGG pathways.
ALMANAC_drugs_filename = paste0(data_dir, "ALMANAC/Drugs/Processed/ALMANAC_drug_ids_processed.csv")
drugs = read.csv(ALMANAC_drugs_filename, stringsAsFactors = F)
colnames(drugs)[1] = "drug_name"
drugs = drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(drug_name) %>% unlist() %>% unique() %>% str_to_lower()
# Replace "venotoclax" with "venetoclax."
drugs[drugs=="venotoclax"] = "venetoclax"

# Load the file. 
if(!exists("ALMANAC_drug_cgixns_CTD_filtered")) ALMANAC_drug_cgixns_CTD_filtered = readRDS(ALMANAC_drug_cgixns_CTD_filtered_filename)

# Get the targets.
ALMANAC_drug_target_data_CTD = future_lapply(drugs, FUN = getTargets2) # Returns a list. 
names(ALMANAC_drug_target_data_CTD) = drugs

# Rename the drugs in the tables and get the drugs that have entries.
drugs_with_CTD_entries = c()
for(drug in names(ALMANAC_drug_target_data_CTD)) {
  if(nrow(ALMANAC_drug_target_data_CTD[[drug]]) > 0) {
    ALMANAC_drug_target_data_CTD[[drug]]$Drug = drug
    drugs_with_CTD_entries = c(drugs_with_CTD_entries, drug)
  }
}
# Keep only the drugs with entries.
ALMANAC_drug_target_data_CTD = ALMANAC_drug_target_data_CTD[drugs_with_CTD_entries]

# Save the list. 
# New list with 71 entries (previously 53) saved 08/16/2021.
ALMANAC_drug_target_data_CTD_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "CTD", extension = ".rds", processing_stage = "Processed", additional_info = "target_data")
saveRDS(ALMANAC_drug_target_data_CTD, ALMANAC_drug_target_data_CTD_filename)
```


### DrugBank
DrugBank data was downloaded as an XML file from [...] on [...]. The data was migrated to a MySQL database for easier retrieval. See the Supplemental Data section for detailed methods. 

```{r echo = FALSE, eval=TRUE, include=FALSE}
# Update 08/16/2021: now including even the drugs without KEGG pathways.
ALMANAC_drugs_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
ALMANAC_drugs = read.csv(ALMANAC_drugs_filename)
drugs = ALMANAC_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(drug_name) %>% unlist %>% unique %>% str_to_lower
DB_ids = ALMANAC_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(DB_id) %>% unlist %>% unique

ALMANAC_drug_target_data_DrugBank_tmp = data.frame(
  Drug = character(),
  Target = character(),
  Effect = numeric(),
  stringsAsFactors = F
)

# Get the targets of the drugs from the MySQL database. 

# Get all the possible pharmacological actions. 
#query = "SELECT PharmacologicalAction FROM DrugTargets.DrugBank;"
#res = dbSendQuery(DrugTargetsDB, query)
#pharm_actions = dbFetch(res) %>% unlist() %>% unique()
#View(pharm_actions)
#dbClearResult(res)
inhibitory_actions = c("inhibitor", "antagonist", "antibody", "inverse agonist", "inhibitory allosteric modulator", "negative modulator", "blocker", "weak inhibitor", "downregulator", "partial antagonist", "suppressor", "inactivator", "degradation", "incorporation into and destabilization", "inhibition of synthesis")
activating_actions = c("activator", "agonist", "stimulator", "potentiator", "inducer", "positive allosteric modulator", "partial agonist", "positive modulator")
        
# https://programminghistorian.org/en/lessons/getting-started-with-mysql-using-r#create-an-r-script-that-connects-to-the-database
# Make the connection to the MySQL database. 
# The connection method below uses a password stored in a settings file.
user_password = "Kibougaaru2020"
DrugTargetsDB = dbConnect(RMariaDB::MariaDB(), 
                          user='root', 
                          password=user_password, 
                          dbname='DrugTargets', 
                          host='localhost')
dbListTables(DrugTargetsDB)

# Make the queries. 
for(db_id in DB_ids) {
  query = paste0("SELECT DrugName, TargetName, Organism, PharmacologicalAction FROM DrugTargets.DrugBank WHERE DrugBankID = '", db_id, "';")
  res = dbSendQuery(DrugTargetsDB, query)
  drug_data = dbFetch(res)
  dbClearResult(res)
  
  if(nrow(drug_data) < 1) next
  
  # Get the drug name.
  drug_name = ALMANAC_drugs %>% dplyr::filter(DB_id==db_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  
  # Select the entries with "Human" in the Organism column.
  drug_data = drug_data %>% dplyr::filter(base::grepl("Human", Organism))
  
  # For each target, get the effect.
  for(target in unique(drug_data$TargetName)) {
    # Get the number of effects.
    drug_actions = drug_data %>% dplyr::filter(TargetName == target) %>% dplyr::select(PharmacologicalAction) %>% unique()
    
    if(length(drug_actions) > 0) {
      # Convert the pharmacological actions to -1, 0, or 1. 
      inhibitory = ifelse(sum(drug_actions %in% inhibitory_actions) > 0, T, F)
      activating = ifelse(sum(drug_actions %in% activating_actions) > 0, T, F)
      if(inhibitory & !activating) {
        drug_action_numeric = -1
      } else if(activating & !inhibitory) {
        drug_action_numeric = 1
      } else {
        drug_action_numeric = 0
      }
        
      # Add to the table.
      ALMANAC_drug_target_data_DrugBank_tmp = rbind(ALMANAC_drug_target_data_DrugBank_tmp, data.frame(
        Drug = drug_name,
        Target = target,
        Effect = drug_action_numeric,
        stringsAsFactors = F
      ))
    }
  }
}
# Disconnect
dbDisconnect(DrugTargetsDB)

# Save the temporary table.
ALMANAC_drug_target_data_DrugBank_tmp_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "DrugBank", extension = ".rds", processing_stage = "Processed", additional_info = "target_data_tmp")
saveRDS(ALMANAC_drug_target_data_DrugBank_tmp, ALMANAC_drug_target_data_DrugBank_tmp_filename)

# Make sure all the drug names in ALMANAC_drug_target_data_DrugBank_tmp match the names in drugs. (We will need to do some manual correction, more than likely.)
setdiff(unique(ALMANAC_drug_target_data_DrugBank_tmp$Drug), drugs)
setdiff(drugs, unique(ALMANAC_drug_target_data_DrugBank_tmp$Drug))

# Convert the targets in ALMANAC_drug_target_data_DrugBank_tmp to ENTREZ IDs.
hs = org.Hs.eg.db
keys = ALMANAC_drug_target_data_DrugBank_tmp$Target %>% as.character()
x = AnnotationDbi::select(hs, 
               keys = keys,
               columns = c("SYMBOL", "ENTREZID"),
               keytype = "SYMBOL") %>% .[complete.cases(.),] %>% distinct()

# Remove any ENTREZIDs that don't have corresponding KEGG entries.
entrez_no_kegg = c()
for(entrez_id in unique(x$ENTREZID)) {
  print(paste0("Checking if gene ", entrez_id, " has a KEGG entry."))
  
  possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
        entrez_test = keggGet(paste0("hsa:", entrez_id))
    }, error=function(cond) {
        message(cond)
    }
    )
  if(inherits(possibleError, "error") | !exists("entrez_test")) {
      entrez_no_kegg = c(entrez_no_kegg, entrez_id)
  }
  
  rm(entrez_test)
}
x = x %>% dplyr::filter(!(ENTREZID %in% entrez_no_kegg))
# Convert to ENTREZ.
# https://stackoverflow.com/a/3905442
a = x$SYMBOL
b = x$ENTREZID
ALMANAC_drug_target_data_DrugBank_tmp$Target = b[match(ALMANAC_drug_target_data_DrugBank_tmp$Target, a)]
ALMANAC_drug_target_data_DrugBank = ALMANAC_drug_target_data_DrugBank_tmp %>% .[complete.cases(.),]

# We won't need to convert to list to match CTD format until we merge the DrugBank and KEGG data.

# Merge.
#ALMANAC_drug_target_data_DrugBank = rbind(ALMANAC_drug_target_data_DrugBank, ALMANAC_drug_target_data_DrugBank_tmp)

# Change everything to sentence caps. 
#ALMANAC_drug_target_data_DrugBank$Drug = str_to_sentence(ALMANAC_drug_target_data_DrugBank$Drug)

# Filter out targets that already exist (i.e. keep only unique rows.)
#ALMANAC_drug_target_data_DrugBank = ALMANAC_drug_target_data_DrugBank %>% distinct()

# 11 Aug 2021: replace venotoclax -> venetoclax.
ALMANAC_drug_target_data_DrugBank$Drug = ALMANAC_drug_target_data_DrugBank$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")

# Save.
# Update 08/16/2021: now including even the drugs without KEGG pathways.
ALMANAC_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
write.table(ALMANAC_drug_target_data_DrugBank, ALMANAC_drug_target_data_DrugBank_filename, sep=",", row.names=F)
```

### KEGG
KEGG data was downloaded using the KEGGREST package in R (3.6.3.) Since KEGG does not provide the pharmacological effects of drugs on the target (e.g. whether the drug acts as an antagonist or agonist), 

```{r echo = FALSE, eval=TRUE, include=FALSE}
ALMANAC_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
ALMANAC_drug_target_data_DrugBank = read.csv(ALMANAC_drug_target_data_DrugBank_filename)

ALMANAC_drugs_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
ALMANAC_drugs = read.csv(ALMANAC_drugs_filename, stringsAsFactors = F)
kegg_ids = ALMANAC_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(KEGG_id) %>% unlist %>% unique %>% .[!is.na(.)]

ALMANAC_drug_target_data_KEGG = data.frame(
  Drug = character(),
  Target = character(),
  Effect = character()
)
# Table to hold the mutant/fusion protein targets. 
ALMANAC_drug_target_data_KEGG_v = data.frame( # v = variation. 
  Drug = character(),
  Target = character()
)
for(kegg_drug_id in kegg_ids) {
  drug = ALMANAC_drugs %>% dplyr::filter(KEGG_id==kegg_drug_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  print(paste0("Getting the KEGG targets for drug ", drug, "."))

    # Get the pathways affected.
  if(!is.null(kegg_drug_id) & !is.na(kegg_drug_id)) {
    
    possibleError = tryCatch(
    {
      kegg_pathways = keggGet(kegg_drug_id)[[1]]$TARGET
    }, error=function(cond) {
      message(paste0("There was a problem retrieving the drug-target data from KEGG for the drug ", drug, ":"))
      message(cond)
    }
  )
  
    if(inherits(possibleError, "error")) {
      print(paste0("There was a problem retrieving the drug-target data from KEGG for the drug ", drug, ":"))
      next
    }
  
    else {
      if(class(kegg_pathways)=="list") {
        # Get the mutant/fusion protein targets and add them to a separate table. 
        kegg_targets = kegg_pathways$TARGET
        v_targets = kegg_targets %>% regexPipes::grep("\\*", value = T) %>% str_split(" ") %>% unlist %>% regexPipes::grep("\\[HSA\\:", value = T) %>% regexPipes::gsub("\\[HSA\\:", "") %>% regexPipes::gsub("\\]", "") # This assumes that drugs can't target both a mutant and non-mutant form. ... 
        ALMANAC_drug_target_data_KEGG_v = rbind(ALMANAC_drug_target_data_KEGG_v, data.frame(
          Drug = rep(drug, length(v_targets)),
          Target = v_targets
        ))
        
        # Now get the rest of the targets from the pathways. 
        kegg_pathways = kegg_pathways$PATHWAY
      
        # Keep only the signal-transduction and disease-associated pathways (hsa03xxx, hsa04xxx and hsa05xxx.) 
        kegg_pathway_names = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("[[:space:]]+.+$", "")
      
        # Get the targets of the drug and filter the targets to include only the ones that are not already present in the DB table.
        drug_targets_DrugBank = ALMANAC_drug_target_data_DrugBank %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist
        targets = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("hsa0[345][[:digit:]]{3}", "") %>% regexPipes::gsub("[[:space:]]+.+$", "") %>% regexPipes::gsub("[()]", "") %>% str_split("\\+") %>% unlist() %>% unique() #%>% .[!(. %in% drug_targets_DrugBank)] As of 2022-06-05, we are no longer removing the drug targets present in the DrugBank table at this step. We will wait until the "Merging DrugBank and KEGG" step to do that, because we need all the KEGG targets present when we do the TRRUST stuff. 
      
        # Add to the table.
        ALMANAC_drug_target_data_KEGG = rbind(ALMANAC_drug_target_data_KEGG, data.frame(
          Drug = rep(drug, length(targets)),
          Target = targets,
          Effect = rep(-1, length(targets)) # I'm assuming most of the drugs are inhibitors. ... 
        ))
      }
    }
  } 
  
}

# Keep only unique rows.
ALMANAC_drug_target_data_KEGG = ALMANAC_drug_target_data_KEGG %>% distinct()

# For the most part, the drugs are inhibitors, but for two drug-target pairs, fulvestrant and 2100, and phenformin and 5563, we will have to manually update them. 
# ... No phenformin in ALMANAC, though. That's in GDSC. 
ALMANAC_drug_target_data_KEGG = ALMANAC_drug_target_data_KEGG
ALMANAC_drug_target_data_KEGG[ALMANAC_drug_target_data_KEGG$Drug=="fulvestrant" & ALMANAC_drug_target_data_KEGG$Target=="2100","Effect"] = 0
#ALMANAC_drug_target_data_KEGG[ALMANAC_drug_target_data_KEGG$Drug=="phenformin" & ALMANAC_drug_target_data_KEGG$Target=="5563","Effect"] = 1

# 11 Aug 2021: replace venotoclax -> venetoclax.
ALMANAC_drug_target_data_KEGG$Drug = ALMANAC_drug_target_data_KEGG$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")
ALMANAC_drug_target_data_KEGG_v$Drug = ALMANAC_drug_target_data_KEGG_v$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")

# Remove the following drugs from the _v table, since they do not target mutant but overexpressed/fusion proteins: trastuzumab, lapatinib, crizotinib. Well, maybe keep crizo in the _v table for consistency? It looks like we did that for the network scores? 
ALMANAC_drug_target_data_KEGG_v$Effect = -1
for(drug in c("lapatinib")) {
  # Add the appropriate row to non-_v table.
  ALMANAC_drug_target_data_KEGG = rbind(ALMANAC_drug_target_data_KEGG, ALMANAC_drug_target_data_KEGG_v %>% dplyr::filter(Drug==drug))
}
ALMANAC_drug_target_data_KEGG_v = ALMANAC_drug_target_data_KEGG_v %>% dplyr::filter(!(Drug %in% c("lapatinib")))

# Save. 
ALMANAC_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
ALMANAC_drug_target_data_KEGG_v_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_data", processing_stage = "Processed")
write.table(ALMANAC_drug_target_data_KEGG, ALMANAC_drug_target_data_KEGG_filename, sep=",", row.names=F)
write.table(ALMANAC_drug_target_data_KEGG_v, ALMANAC_drug_target_data_KEGG_v_filename, sep=",", row.names=F)
```

### Merging DrugBank and KEGG
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Load the Drugbank and KEGG target information.
ALMANAC_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
ALMANAC_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
ALMANAC_drug_target_data_KEGG_v_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_data", processing_stage = "Processed")
ALMANAC_drug_target_data_KEGG = read.csv(ALMANAC_drug_target_data_KEGG_filename)
ALMANAC_drug_target_data_KEGG_v = read.csv(ALMANAC_drug_target_data_KEGG_v_filename)
ALMANAC_drug_target_data_DrugBank = read.csv(ALMANAC_drug_target_data_DrugBank_filename)

# Merge the Drugbank and KEGG target tables. 
ALMANAC_drug_target_data_DrugBank_KEGG = rbind(ALMANAC_drug_target_data_DrugBank, ALMANAC_drug_target_data_KEGG) %>% distinct()
# Consolidate duplicate rows (i.e., rows with the same target but different effects).
# https://stackoverflow.com/a/10180178
ALMANAC_drug_target_data_DrugBank_KEGG = ALMANAC_drug_target_data_DrugBank_KEGG %>% dplyr::select(Drug, Target, Effect) %>% ddply(.(Drug, Target), numcolwise(sum))
#rownames(ALMANAC_drug_target_data_DrugBank_KEGG) = ALMANAC_drug_target_data_DrugBank_KEGG$Target
# Because of the consolidation in the previous step, we might have effect values > 1 or < -1. Set the ceiling and floor to be 1 and -1, respectively. 
ALMANAC_drug_target_data_DrugBank_KEGG$Effect = ifelse(ALMANAC_drug_target_data_DrugBank_KEGG$Effect > 1, 1, ALMANAC_drug_target_data_DrugBank_KEGG$Effect)
ALMANAC_drug_target_data_DrugBank_KEGG$Effect = ifelse(ALMANAC_drug_target_data_DrugBank_KEGG$Effect < -1, -1, ALMANAC_drug_target_data_DrugBank_KEGG$Effect)

# Remove all the entries from the Drugbank targets that are also present in the variant KEGG table (i.e. the ones that have mutations/fusions.)
ALMANAC_drug_target_data_DrugBank_KEGG = ALMANAC_drug_target_data_DrugBank_KEGG %>% .[!(paste(.$Drug, .$Target, sep="_") %in% paste(ALMANAC_drug_target_data_KEGG_v$Drug, ALMANAC_drug_target_data_KEGG_v$Target, sep="_")),]

# Convert from Entrez ID to HUGO gene symbol. 
hs = org.Hs.eg.db
keys = ALMANAC_drug_target_data_DrugBank_KEGG$Target %>% as.character
x = AnnotationDbi::select(hs, 
                          keys = keys,
                          columns = c("SYMBOL", "ENTREZID"),
                          keytype = "ENTREZID") %>% .[complete.cases(.),]
ALMANAC_drug_target_data_DrugBank_KEGG$Target = x %>% .[match(ALMANAC_drug_target_data_DrugBank_KEGG$Target, .$ENTREZID),] %>% .$SYMBOL

# Split the dataframe into a list, to match the CTD drug-target-data format and the format that most of the calcNetworkScores() functions use. 
ALMANAC_drug_target_data_DrugBank_KEGG = split(ALMANAC_drug_target_data_DrugBank_KEGG , f = ALMANAC_drug_target_data_DrugBank_KEGG$Drug)

# Remove all entries in the list whose tables have 0 rows. (28 June 2021.)
for(entry in names(ALMANAC_drug_target_data_DrugBank_KEGG)) {
  if(nrow(ALMANAC_drug_target_data_DrugBank_KEGG[[entry]]) < 1) {
    ALMANAC_drug_target_data_DrugBank_KEGG[[entry]] = NULL
  } 
}

# Save.
ALMANAC_drug_target_data_DrugBank_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "DrugBank_KEGG", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(ALMANAC_drug_target_data_DrugBank_KEGG, ALMANAC_drug_target_data_DrugBank_KEGG_filename)
```

### TRRUST
#### Target pathways from KEGG
```{r}
# From KEGG, get the pathways targeted by each drug. 
ALMANAC_drugs_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
ALMANAC_drugs = read.csv(ALMANAC_drugs_filename, stringsAsFactors = F)
drugs = ALMANAC_drugs %>% dplyr::select(drug_name) %>% unlist %>% unique %>% str_to_lower
ALMANAC_drug_target_pathway_data_KEGG = data.frame(
  Drug = character(),
  PathwayName = character(),
  PathwayID = character(),
  Target = character(),
  stringsAsFactors = F
)
ALMANAC_drug_target_pathway_data_KEGG_v = data.frame(
  Drug = character(),
  PathwayName = character(),
  PathwayID = character(),
  Target = character(),
  stringsAsFactors = F
)
kegg_ids = ALMANAC_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(KEGG_id) %>% unlist %>% unique %>% .[!is.na(.)]
for(kegg_drug_id in kegg_ids) {
  drug = ALMANAC_drugs %>% dplyr::filter(KEGG_id==kegg_drug_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  print(paste0("Getting KEGG pathways for drug ", drug, "."))
  
  if(!is.null(kegg_drug_id)) {
    kegg_drug_id = kegg_drug_id %>% str_trim
    kegg_pathways = keggGet(kegg_drug_id)[[1]]$TARGET
    
    if(class(kegg_pathways)=="list") {
      # Get the targets of the drug.
      kegg_targets = kegg_pathways$TARGET
      
      # Get the mutant/fusion protein targets and add them to a separate table. 
      v_targets = kegg_targets %>% regexPipes::grep("\\*", value = T) %>% str_split(" ") %>% unlist %>% regexPipes::grep("\\[HSA\\:", value = T) %>% regexPipes::gsub("\\[HSA\\:", "") %>% regexPipes::gsub("\\]", "") # This assumes that drugs can't target both a mutant and non-mutant form. ... 
      ALMANAC_drug_target_pathway_data_KEGG_v = rbind(ALMANAC_drug_target_pathway_data_KEGG_v, data.frame(
        Drug = rep(drug, length(v_targets)),
        PathwayName = rep(NA, length(v_targets)),
        PathwayID = rep(NA, length(v_targets)),
        Target = v_targets
      ))
      
      # Now get the rest of the targets from the pathways. 
      kegg_pathways = kegg_pathways$PATHWAY
      
      # Get the names of the pathways.
      kegg_pathway_names = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>%  regexPipes::gsub("^[[:alnum:]]+\\(.*\\)[[:space:]]*", "") %>% str_to_upper() %>% regexPipes::gsub("[[:space:]]", "_") %>% paste0("KEGG_", .)
      # Get the KEGG IDs of the pathways.
      KEGG_pathway_ids = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("\\(.+$", "")
      # Get the targets in those pathways. 
      kegg_pathway_targets = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("hsa0[345][[:digit:]]{3}\\(", "") %>% regexPipes::gsub("\\).+$", "") %>% str_split("\\+")
      if(length(kegg_pathway_targets) < 1) {
        print(paste0("There are no applicable KEGG pathways for drug ", drug, ". Skipping to the next one."))
        next
      }
      names(kegg_pathway_targets) = KEGG_pathway_ids
      
      # Create the vectors for the drugs, pathway names, pathway IDs, and targets.
      target_vector = kegg_pathway_targets %>% unlist
      pathway_id_vector = c()
      for(name in names(kegg_pathway_targets)) {
        pathway_id_vector = c(pathway_id_vector, rep(name, length(kegg_pathway_targets[[name]])))
      }
      pathway_name_vector = c()
      for(i in 1:length(kegg_pathway_targets)) {
        pathway_name_vector = c(pathway_name_vector, rep(kegg_pathway_names[i], length(kegg_pathway_targets[[i]])))
      }
  
      if(length(kegg_pathway_names)==length(KEGG_pathway_ids)) {
        ALMANAC_drug_target_pathway_data_KEGG = rbind(ALMANAC_drug_target_pathway_data_KEGG, data.frame(
          Drug = rep(drug, length(pathway_name_vector)),
          PathwayName = pathway_name_vector,
          PathwayID = pathway_id_vector,
          Target = target_vector,
          stringsAsFactors = F
        ))
      } # End if(length(kegg_pathway_names)==length(KEGG_pathway_ids)). 
    } # End if(class(kegg_pathways)=="list"). 
  } # End if(!is.null(kegg_drug_id)). 

}

# Currently, the normal target table has ALL the records. We will remove from it all the mutant protein targets. (This is different from what we did in the KEGG protein target section.)
# Add RecordID field to both _v and normal target tables.
ALMANAC_drug_target_pathway_data_KEGG$RecordID = paste(ALMANAC_drug_target_pathway_data_KEGG$Drug, ALMANAC_drug_target_pathway_data_KEGG$Target, sep = "_")
ALMANAC_drug_target_pathway_data_KEGG_v$RecordID = paste(ALMANAC_drug_target_pathway_data_KEGG_v$Drug, ALMANAC_drug_target_pathway_data_KEGG_v$Target, sep = "_")

# Remove the following drugs from the _v table, since they do not target mutant but overexpressed/fusion proteins: trastuzumab, lapatinib, crizotinib.
ALMANAC_drug_target_pathway_data_KEGG_v = ALMANAC_drug_target_pathway_data_KEGG_v %>% dplyr::filter(!(Drug %in% c("trastuzumab", "lapatinib", "crizotinib")))
# Now filter the normal table by the _v table.
# But first save the _v stuff!
tmp = ALMANAC_drug_target_pathway_data_KEGG %>% dplyr::filter(RecordID %in% ALMANAC_drug_target_pathway_data_KEGG_v$RecordID)
ALMANAC_drug_target_pathway_data_KEGG = ALMANAC_drug_target_pathway_data_KEGG %>% dplyr::filter(!(RecordID %in% ALMANAC_drug_target_pathway_data_KEGG_v$RecordID))
ALMANAC_drug_target_pathway_data_KEGG_v = tmp

rm(tmp)

# Save to file.
ALMANAC_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
ALMANAC_drug_target_pathway_data_KEGG_v_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_pathway_data", processing_stage = "Processed")
write.table(ALMANAC_drug_target_pathway_data_KEGG, ALMANAC_drug_target_pathway_data_KEGG_filename, sep=",", row.names=F)
write.table(ALMANAC_drug_target_pathway_data_KEGG_v, ALMANAC_drug_target_pathway_data_KEGG_v_filename, sep=",", row.names=F)
```

#### Genes downstream of each drug target
```{r}
# Get all the targeted pathways. 
ALMANAC_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
ALMANAC_drug_target_pathway_data_KEGG = read.csv(ALMANAC_drug_target_pathway_data_KEGG_filename)
# We no longer have to remove drug-target-pathway combinations involving mutant/fusion proteins in this step, since we did it in the last one. 08/21/2021.
KEGG_pathway_ids = ALMANAC_drug_target_pathway_data_KEGG$PathwayID %>% unique() 
# Get all the direct targets of the drugs.
ALMANAC_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
ALMANAC_drug_target_data_KEGG = read.csv(ALMANAC_drug_target_data_KEGG_filename)
ALMANAC_drug_targets_KEGG = ALMANAC_drug_target_data_KEGG$Target %>% unique() %>% paste0("hsa:", .)

# For each pathway, get the nodes downstream of each target. 
ALMANAC_drug_target_downstream_node_data_KEGG = data.frame(
  Pathway = character(),
  Target = character(),
  DownstreamNodes = character(),
  Effects = numeric(),
  stringsAsFactors = F
)
for(pathway in KEGG_pathway_ids) {
  print(paste0("Working on pathway ", pathway, "."))
  
  # Load the KGML file. 
  #kgml = keggGet("hsa04010", option = "kgml")
  #parsed_kgml = parseKGML(kgml)
  #pathway_graph = KEGGpathway2Graph(parsed_kgml)
  kgml = keggGet(pathway, option = "kgml")

  # Convert the KGML file into an iGraph object.
  # First convert to a graphNEL object.
  graphNEL = parseKGML2Graph(kgml, expandGenes = T, genesOnly = F) # PI3K signaling occurs through PIP3, which is a lipid. ... 
  #graphNEL_layout = layoutGraph(graphNEL)
  #renderGraph(graphNEL_layout)
  
  # For MAPK pathway only--create a directed edge between the RTK node and the GRB2 node, and between the GRB2 node and the SOS node. 
  rtk_nodes = c("hsa:1436","hsa:1956","hsa:1969","hsa:2064","hsa:2065","hsa:2066","hsa:2260","hsa:2261","hsa:2263","hsa:2264","hsa:2321","hsa:2322","hsa:2324","hsa:3480","hsa:3643","hsa:3791","hsa:3815","hsa:4233","hsa:4804","hsa:4914","hsa:4915","hsa:5156","hsa:5159","hsa:7010")
  grb2_node = "hsa:2885"
  sos_nodes = c("hsa:6654","hsa:6655")
  if(pathway=="hsa04010") {
    graphNEL = addEdge(rtk_nodes, grb2_node, graphNEL, 1)
    graphNEL = addEdge(grb2_node, sos_nodes, graphNEL, 1)
  }
  
  # Next, weight the edges by whether they are inhibitory or activating. 
  # @_@
  # For each edge in the graph (pathway_graph or graphNEL), use the KEGG edge data to determine whether it is an activating or inhibitory edge. If it is activating, leave it alone. Otherwise, set it to -1. 
  kegg_edge_data = getKEGGedgeData(graphNEL)
  kegg_edges = edges(graphNEL)
  kegg_edge_weights = edgeWeights(graphNEL)
  # Generate a list of all the edges. 
  all_edges = c()
  for(first_node in names(kegg_edges)) {
    if(length(kegg_edges[[first_node]]) > 0) all_edges = c(all_edges, paste0(first_node, "~", kegg_edges[[first_node]]))
  }
        
  for(edge in all_edges) {
    first_node = str_split(edge, "~") %>% unlist %>% .[1]
    second_node = str_split(edge, "~") %>% unlist %>% .[2]
    edge_data = getKEGGedgeData(graphNEL)[[edge]] # This will be NULL for the edges we added on, since we only added the edges, not any metadata. 
    if(!is.null(edge_data)) {
      if(length(getSubtype(edge_data)) > 0) {
        edge_subtype = getName(getSubtype(getKEGGedgeData(graphNEL)[[edge]])$subtype) # "activation" or "inhibition".
        } else {
          edge_subtype = "activation"
        }
    } else {
        edge_subtype = "activation"
      }
    
    if(edge_subtype=="inhibition") kegg_edge_weights[[first_node]][second_node] = -1
  }
  #edgeWeights(graphNEL) = kegg_edge_weights
  # Above line of code doesn't work--see comment below. 
  
  # Then convert to iGraph.
  igraph = graph_from_graphnel(graphNEL, name = TRUE, weight = TRUE,
  unlist.attrs = TRUE)
  # Set the weights of the iGraph to be kegg_edge_weights.
  # (We can't change the weights of a graphNEL object, apparently, so we have to do it this way. ... Of course, this assumes that the edges are in the same order in igraph as they are once you unlist kegg_edge_weights. ... If we ever update any of the packages used here, we will have to 2x check this.)
  edge_attr(igraph)$weight = unlist(kegg_edge_weights)
  
  # Get the downstream nodes of the target of the drug. 
  # https://rdrr.io/github/robertness/lucy/man/get_downstream_nodes.html 
  ALMANAC_drug_targets_KEGG_i = ALMANAC_drug_targets_KEGG %>% .[. %in% names(V(igraph))]
  for(drug_target in ALMANAC_drug_targets_KEGG_i) {
    print(paste0("Working on target ", drug_target, " in pathway ", pathway, "."))
    
    w = V(igraph)[drug_target]
     possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      downstream_nodes = V(igraph)[get_downstream_nodes(igraph, w)]
    }, error=function(cond) {
      message(paste0("There was a problem getting the nodes downstream from target ", drug_target, ":"))
      message(cond)
    }
  )
    if(inherits(possibleError, "error") | !exists("downstream_nodes")) {
      print(paste0("Skipping drug target ", drug_target, "."))
      next
    }
    
    # Check if there are any downstream nodes. If not, move on to the next target.
    if(length(downstream_nodes) < 1) {
      print(paste0("Target ", drug_target, " has no downstream nodes. Moving on!"))
      next
    }
    downstream_node_names = downstream_nodes %>% names() # %>% paste(collapse=",")
    
    # Determine the effect of the target on each node? (I.e. upregulated or downregulated. ... This is important, but can we do it without having to do it manually??)
    # Get all the edges between the target and the downstream nodes. 
    #all_paths = all_simple_paths(igraph, from = V(igraph)[drug_target], to = downstream_nodes, mode = "out")
    possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      all_paths = shortest_paths(igraph, from = V(igraph)[drug_target], to = downstream_nodes, weights = rep(1, length(unlist(kegg_edge_weights)))) %>% .$vpath # Have to set the weights to all be positive; otherwise, the algorithm doesn't work. Using all_simple_paths returns all possible paths. 
    }, error=function(cond) {
      message(paste0("There was a problem getting the shortest paths from target ", drug_target, ":"))
      message(cond)
    }
  )
    if(inherits(possibleError, "error") | !exists("all_paths")) {
      print(paste0("Skipping drug target ", drug_target, "."))
      next
    }

    effects = c()
    for(i in 1:length(all_paths)) {
      # Get path i. 
      path = all_paths[[i]] %>% names()
      # Because of the way get.edge.ids works, we need to duplicate all inner vertices (vertices that are not the first or last) in path in order to get all the edges that make up the path.
      if(length(path) > 2) {
        vertices = c(path[1], rep(path[2:(length(path)-1)], each = 2), path[length(path)])
      } else {
        vertices = path
      }
      # Get the IDs of the edges connecting vertices in the path. 
      edge_ids = get.edge.ids(igraph, vertices, directed = TRUE, error = FALSE,
  multi = FALSE)
      # Get the weights of those edges.
      weights = edge_attr(igraph, "weight", index = E(igraph)[edge_ids])
      # Multiply them together. 
      # https://stackoverflow.com/a/62561005
      effect = ifelse(prod(weights) < 0, -1, 1)
      # If < 0, then -1; if > 0, then 1.
      effects = c(effects, effect)
    }
    
    # Add to the table. 
    ALMANAC_drug_target_downstream_node_data_KEGG = rbind(ALMANAC_drug_target_downstream_node_data_KEGG, data.frame(
    Pathway = rep(pathway, length(downstream_nodes)),
    Target = rep(drug_target, length(downstream_nodes)),
    DownstreamNodes = names(downstream_nodes),
    Effects = effects,
    stringsAsFactors = F
    ))
    
    # Remove old "downstream_nodes" and "all_paths" so that the error checks can be triggered properly.
    rm(downstream_nodes, all_paths)
  }
    
}

# Save.
ALMANAC_drug_target_downstream_node_data_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_downstream_node_data", processing_stage = "Processed")
write.table(ALMANAC_drug_target_downstream_node_data_KEGG, ALMANAC_drug_target_downstream_node_data_KEGG_filename, sep=",", row.names=F)
```

#### Transcription factors and their targets for each pathway
```{r}
ALMANAC_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
ALMANAC_drug_target_pathway_data_KEGG = read.csv(ALMANAC_drug_target_pathway_data_KEGG_filename)

KEGG_pathways_complete_filename = paste0(folder_generator(data_dir, data_source = "GSEA-MSigDB", data_type = "Misc", processing_stage = "Raw"), "c2.cp.kegg.v7.1.symbols.gmt")
KEGG_pathways_complete = GSA.read.gmt(KEGG_pathways_complete_filename)
ALMANAC_drug_target_downstream_node_data_KEGG = read.csv(ALMANAC_drug_target_downstream_node_data_KEGG_filename)

# Load the TRRUST data. 
TRRUST_data_filename = paste0(folder_generator(data_dir, data_source = "TRRUST", data_type = "Misc", processing_stage = "Raw"), "trrust_rawdata.human.tsv")
TRRUST_data = read.table(TRRUST_data_filename, header = F)
colnames(TRRUST_data) = c("TF", "Target",	"ModeOfRegulation",	"PMID")
# Exclude all unknown interactions from the TRRUST data. 
TRRUST_data = TRRUST_data %>% dplyr::filter(ModeOfRegulation != "Unknown")

# For each unique pathway in ALMANAC_drug_target_pathway_data_KEGG, get the transcription factors from that pathway. 
ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST = data.frame(
  Pathway = character(),
  DrugTarget = character(),
  TFentrez = character(),
  TFsymbol = character(),
  TranscriptionalTarget = character(),
  ModeOfRegulation = character(),
  stringsAsFactors = F
)

for(pathway in unique(ALMANAC_drug_target_pathway_data_KEGG$PathwayID)) {
  # Get the drug targets in that pathway. 
  pathway_drug_targets = ALMANAC_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Pathway==pathway) %>% dplyr::select(Target) %>% unlist() %>% unique()
  
  for(drug_target in pathway_drug_targets) {
    # Get the nodes downstream of that target. Remove any nodes that are not genes. 
    downstream_nodes = ALMANAC_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Pathway==pathway & Target == drug_target & regexPipes::grepl(.$DownstreamNodes, "hsa\\:")) %>% dplyr::select(DownstreamNodes, Effects) %>% distinct()
  
    if(nrow(downstream_nodes) < 1) {
      print(paste0("Target ", drug_target, " has no downstream gene nodes. Skipping this one!"))
      next
    }
    
    # Convert the downstream nodes from their KEGG ID to their gene name. 
    hs = org.Hs.eg.db
    keys = downstream_nodes$DownstreamNodes %>% unlist() %>% regexPipes::gsub("hsa\\:", "")
    x = AnnotationDbi::select(hs, 
               keys = keys,
               columns = c("SYMBOL", "ENTREZID"),
               keytype = "ENTREZID") %>% .[complete.cases(.),]
    # We will be back-converting from symbols to ENTREZ IDs, so make sure that each symbol maps to only ONE ENTREZ ID. 
    # ... Which, come to think of it, shouldn't be a problem, since we started out with ENTREZ IDs, and I don't think KEGG had duplicates. ... 
  
    # Get the transcription factors.
    # https://stackoverflow.com/questions/10586652/r-preserve-order-when-using-matching-operators-in
    tfs = intersect(unique(TRRUST_data$TF), x$SYMBOL)
    if(length(tfs) < 1) {
      print(paste0("Target ", drug_target, " has no downstream transcription factors. Skipping this one!"))
      next
    }
    
    tfs_entrez = x %>% .[match(tfs, .$SYMBOL),] %>% .$ENTREZID %>% paste0("hsa:", .)
    names(tfs_entrez) = tfs
  
    # Get the targets of those transcription factors.
    for(tf in tfs) {
      txn_target = TRRUST_data %>% dplyr::filter(TF==tf) %>% dplyr::select(TF, Target, ModeOfRegulation)
    
      # Add to the table if there are any transcriptional targets. 
      ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST = rbind(ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST, data.frame(
        Pathway = rep(pathway, nrow(txn_target)),
        DrugTarget = rep(drug_target, nrow(txn_target)),
        TFentrez = rep(tfs_entrez[tf], nrow(txn_target)),
        TFsymbol = txn_target$TF,
        TranscriptionalTarget = txn_target$Target,
        ModeOfRegulation = txn_target$ModeOfRegulation,
        stringsAsFactors = F
        ))
    }
    
  }
  
}

# Add an effect column.
ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST$Effect = ifelse(ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST$ModeOfRegulation=="Repression", -1, 1)

# Save.
ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG_TRRUST", extension = ".csv", additional_info = "target_txnal_target_data", processing_stage = "Processed")
write.table(ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST, ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST_filename, sep=",", row.names=F)
```

#### Final effects of drugs on downstream targets
Combine the data from ALMANAC_drug_target_data_KEGG, drug_genes_table and ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST (i.e. multiply the effects) to get the final effect of the drug on each of its transcriptional targets. 
```{r}
ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG_TRRUST", extension = ".csv", additional_info = "target_txnal_target_data", processing_stage = "Processed")
ALMANAC_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
ALMANAC_drug_target_downstream_node_data_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_downstream_node_data", processing_stage = "Processed")
ALMANAC_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")

ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST = read.csv(ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST_filename)
ALMANAC_drug_target_pathway_data_KEGG = read.csv(ALMANAC_drug_target_pathway_data_KEGG_filename)
ALMANAC_drug_target_downstream_node_data_KEGG = read.csv(ALMANAC_drug_target_downstream_node_data_KEGG_filename)
ALMANAC_drug_target_data_KEGG = read.csv(ALMANAC_drug_target_data_KEGG_filename)

ALMANAC_drug_target_data_TRRUST = data.frame(
  Drug = character(),
  Target = character(),
  Effect = numeric(),
  stringsAsFactors = F
)

# Indirect targets. 
for(drug in unique(ALMANAC_drug_target_data_KEGG$Drug)) {
  # For each drug, get its corresponding targets from ALMANAC_drug_target_data_KEGG. 
  drug_targets = ALMANAC_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist() %>% paste0("hsa:", .)
  
  # Get the pathways this drug is involved in. We are going to restrict transcriptional effects to the pathways the drug is known to be involved in. (E.g., if drug A targets EGFR, even if EGFR is involved in multiple pathways, we will only consider the pathways that drug A has listed in KEGG.)
  drug_pathways = ALMANAC_drug_target_pathway_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(PathwayID) %>% unlist() %>% unique
  
  for(drug_target in drug_targets) {
    # Get the effect of the drug on this target.
    target_edited = drug_target %>% regexPipes::gsub("hsa\\:", "")
    fx_drug_on_target = ALMANAC_drug_target_data_KEGG %>% dplyr::filter(Drug==drug & Target==target_edited) %>% dplyr::select(Effect) %>% unlist()
    
    # For each drug target, get the TFs that are downstream of that target. 
    tfs = ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & Pathway %in% drug_pathways) %>% dplyr::select(TFentrez) %>% unlist() %>% as.character() %>% unique() # Pathway %in% drug_pathways ensures that only the downstream TFs in the pathways associated with that drug are chosen.
    
    # For each TF, get the downstream transcriptional targets from ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST.
    for(tf in tfs) {
      txn_targets = ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & Pathway %in% drug_pathways & TFentrez==tf) %>% dplyr::select(TranscriptionalTarget) %>% unlist() %>% as.character() %>% unique() # Pathway %in% drug_pathways ensures that only the downstream txnal targets in the pathways associated with that drug are chosen.
    
      # For each downstream transcriptional target, calculate the final effect. 
      # Use ALMANAC_drug_target_downstream_node_data_KEGG.
      for(txn_target in txn_targets) {
        print(paste0("Calculating effect of drug ", drug, " on target ", txn_target, "."))
        # Final effect = effect of drug on target (fx_drug_on_target, already calculated in outer loop) * effect of drug target on TF (from ALMANAC_drug_target_downstream_node_data_KEGG) (fx_drug_target_on_tf) * effect of TF on transcriptional target (from ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST) (fx_tf_on_txn_target).
        fx_drug_target_on_tf = ALMANAC_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Target == drug_target & DownstreamNodes == tf & Pathway %in% drug_pathways) %>% dplyr::select(Effects) %>% unlist()
        fx_tf_on_txn_target = ALMANAC_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & TFentrez==tf & TranscriptionalTarget == txn_target & Pathway %in% drug_pathways) %>% dplyr::select(Effect) %>% unlist()
        final_effect = prod(fx_drug_on_target, fx_drug_target_on_tf, fx_tf_on_txn_target)
        
        ALMANAC_drug_target_data_TRRUST = rbind(ALMANAC_drug_target_data_TRRUST, data.frame(
          Drug = drug,
          Target = txn_target,
          Effect = final_effect,
          stringsAsFactors = F
          ))
        }
    }
  }
}

# Direct targets. 
colnames(ALMANAC_drug_target_data_TRRUST)[3] = "Effect"
hs = org.Hs.eg.db
keys = unique(ALMANAC_drug_target_data_KEGG$Target) %>% as.character()
x = AnnotationDbi::select(hs, 
           keys = keys,
           columns = c("SYMBOL", "ENTREZID"),
           keytype = "ENTREZID") %>% .[complete.cases(.),] %>% distinct()
for(drug in unique(ALMANAC_drug_target_data_KEGG$Drug)) {
  # For each drug, get its corresponding targets and effects from ALMANAC_drug_target_data_KEGG. 
  drug_targets = ALMANAC_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist()
  final_effects = ALMANAC_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Effect) %>% unlist()
  
  # Convert to gene symbol.
  #keggGet(kegg_drug_id) %>% .[[1]] %>% .$NAME %>% str_split(",") %>% .[[1]] %>% .[1]
  a = x$ENTREZID
  b = x$SYMBOL
  target_ids = b[match(drug_targets, a)]
  # Alternative: 
  #target_ids = c()
  #for(target in unique(ALMANAC_drug_target_data_KEGG$Target)) {
  #  print(paste0("Getting gene ID for target ", target, "."))
  #  target_ids = c(target_ids, keggGet(paste0("hsa:",target)) %>% .[[1]] %>% .$NAME %>% str_split(",") %>% .[[1]] %>% .[1])
  #}
  
  # Add to ALMANAC_drug_target_data_TRRUST. 
  ALMANAC_drug_target_data_TRRUST = rbind(ALMANAC_drug_target_data_TRRUST, data.frame(
          Drug = rep(drug, length(final_effects)),
          Target = target_ids,
          Effect = final_effects,
          stringsAsFactors = F
          ))
}

# Keep only unique rows.
ALMANAC_drug_target_data_TRRUST = ALMANAC_drug_target_data_TRRUST %>% distinct()

# Split the dataframe into a list, to match the CTD drug-target-data format and the format that most of the calcNetworkScores() functions use. 
ALMANAC_drug_target_data_TRRUST = split(ALMANAC_drug_target_data_TRRUST , f = ALMANAC_drug_target_data_TRRUST$Drug)

# Remove all entries in the list whose tables have 0 rows. (28 June 2021.)
for(entry in names(ALMANAC_drug_target_data_TRRUST)) {
  if(nrow(ALMANAC_drug_target_data_TRRUST[[entry]]) < 1) {
    ALMANAC_drug_target_data_TRRUST[[entry]] = NULL
  } 
}

# Save.
ALMANAC_drug_target_data_TRRUST_filename = filename_generator(data_dir, data_source = "ALMANAC", data_type = "Drugs", data_set = "TRRUST", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(ALMANAC_drug_target_data_TRRUST, ALMANAC_drug_target_data_TRRUST_filename)
#write.table(ALMANAC_drug_target_data_TRRUST, paste0(data_dir, "Processed_data/ALMANAC/ALMANAC_kegg_drug_final_effects.csv"), sep = ",", row.names = F)
```

# O'Neil
## pData
### Import of raw data and basic cleaning
```{r}
# Load the raw data.
ONeil_dat_raw = read.csv(paste0(folder_generator(data_dir, data_source = "ONeil", data_type = "pData", processing_stage = "Raw"), "156849_1_supp_1_w2lrww.csv"), stringsAsFactors = F)
pData = ONeil_dat_raw

# Get the drug names.
ONeil_drug_names = pData %>% dplyr::select(drugA_name, drugB_name) %>% unlist %>% as.character %>% unique
write.table(ONeil_drug_names, paste0(folder_generator(data_dir, data_source = "ONeil", data_type = "Metadata", processing_stage = "Raw"), "ONeil_chemical_names_dictionary.csv"), row.names = F, col.names = F)

# Save intermediate pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ONeil", data_type = "pData", extension = ".rds", processing_stage = "Intermed1"))
rm(pData)
gc()
```

### Standardization of drug names
```{r}
# Load the pData from the last step.
pData = readRDS(filename_generator(data_dir, data_source = "ONeil", data_type = "pData", extension = ".rds", processing_stage = "Intermed1"))

# Load the ONeil-to-drug-name mapping.
ONeil_drug_name_mapping = read.csv(paste0(folder_generator(data_dir, data_source = "ONeil", data_type = "Metadata", processing_stage = "Processed"), "ONeil_chemical_names_dictionary.csv"), header = T, stringsAsFactors = F)

# Correct names.
# https://stackoverflow.com/a/3905442
a = ONeil_drug_name_mapping$Original
b = ONeil_drug_name_mapping$Corrected
pData$drugA_name = b[match(pData$drugA_name, a)]
pData$drugB_name = b[match(pData$drugB_name, a)]

# Merge names into single column. 
pData$combination_name = paste(pData$drugA_name, pData$drugB_name, sep="_")

# Check.
#sum(is.na(pData$drugA_name)) + sum(is.na(pData$drugB_name))

# Save intermediate pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ONeil", data_type = "pData", extension = ".rds", processing_stage = "Intermed2"))
rm(pData)
gc()
```

### Standardization of cell-line names
```{r}
# Read the pData from the last step.
pData = readRDS(filename_generator(data_dir, data_source = "ONeil", data_type = "pData", extension = ".rds", processing_stage = "Intermed2"))

# Get the cell line names.
ONeil_cell_line_names = pData %>% dplyr::select(cell_line) %>% unlist %>% as.character %>% unique
write.table(ONeil_cell_line_names, paste0(folder_generator(data_dir, data_source = "ONeil", data_type = "Metadata", processing_stage = "Raw"), "ONeil_cell_line_names.csv"), row.names = F, col.names = F)

# Convert pData to a data.table. 
setDT(pData)

# Standardize the cell-line names so they match those in the NCI-60 data. Specifically, make the following changes manually:
# Remove the forward slashes when they're not part of the cell name.
# When slashes (forward or backslashes) are part of the cell name, change them to dashes. 
ONeil_names = read.csv(paste0(folder_generator(data_dir, data_source = "ONeil", data_type = "Metadata", processing_stage = "Processed"), "ONeil_cell_line_names_dictionary.csv"), colClasses = rep("character", 3)) # Maps the different cell line names to the standardized names.

# Now we can standardize using the table.
# Replace a with b. 
a = ONeil_names$Original
b = ONeil_names$Corrected
names(b) = a
pData$cell_line = b[match(pData$cell_line, a)]
# Check.
sum(is.na(unique(pData$cell_line)))==0

# Make sure the order of the cell lines in the ALMANAC data matches those in the eset. 
cols = c("cell_line", "drugA_name", "drugB_name")
setkeyv(pData, cols, verbose=getOption("datatable.verbose"))

# Save intermediate pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ONeil", data_type = "pData", extension = ".rds", processing_stage = "Intermed3"))
rm(pData)
gc()
```

### Addition of cancer types
This must be conducted AFTER the standardization of cell-line names! 
```{r}
# Read the pData from the last step.
pData = readRDS(filename_generator(data_dir, data_source = "ONeil", data_type = "pData", extension = ".rds", processing_stage = "Intermed3"))

# Load the mapping file.
ONeil_cancer_types = read.csv(paste0(folder_generator(data_dir, data_source = "ONeil", data_type = "Metadata", processing_stage = "Processed"), "ONeil_cancer_types.csv"))

# Create the vector of cancer types.
a = ONeil_cancer_types$CellLine %>% as.character
b = ONeil_cancer_types$TissueType %>% as.character
names(b) = a
pData$cancer_type = b[match(pData$cell_line, a)]
unique(pData$cancer_type)

# Save intermediate pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ONeil", data_type = "pData", extension = ".rds", processing_stage = "Intermed4"))
rm(pData)
gc()
```

### Filtering of concentrations
We will keep only the best performance of each drug combination. 
```{r}
# Read the pData from the last step.
pData = readRDS(filename_generator(data_dir, data_source = "ONeil", data_type = "pData", extension = ".rds", processing_stage = "Intermed4"))

# Convert viability columns to numeric.
pData[pData=="NULL"] = NA
# https://stackoverflow.com/a/37833702/8497173
changeCols = paste0("viability", 2:4)
pData[,(changeCols):= lapply(.SD, as.numeric), .SDcols = changeCols]

# https://community.rstudio.com/t/summarise-max-but-keep-all-columns/52449/4
# https://stackoverflow.com/a/50352840/8497173
pData = pData %>% 
  mutate(viability_mean = rowMeans(dplyr::select(., viability1:viability4), na.rm = T)) %>%
  group_by(cell_line, drugA_name, drugB_name) %>% 
  mutate(viability_mean_best = min(viability_mean)) %>% 
  ungroup() %>% 
  dplyr::filter(viability_mean==viability_mean_best)

# Unique to O'Neil (2021-11-04).
# Change all drug names to lower case.
pData$drugA_name = str_to_lower(pData$drugA_name)
pData$drugB_name = str_to_lower(pData$drugB_name)
pData$combination_name = str_to_lower(pData$combination_name)

# Save processed pData.
saveRDS(pData, filename_generator(data_dir, data_source = "ONeil", data_type = "pData", extension = ".rds", processing_stage = "Processed"))
rm(pData)
gc()
```

## Drug data
### Creation of drug list
```{r}
ONeil_pData = readRDS(filename_generator(data_dir, data_source = "ONeil", data_type = "pData", extension = ".rds", processing_stage = "Processed"))
ONeil_drugs = union(ONeil_pData$drugA_name, ONeil_pData$drugB_name)
# length(ONeil_drugs) == length(unique(ONeil_drugs))

# Save to file. 
write.table(ONeil_drugs, filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", extension = ".tsv", processing_stage = "Raw", additional_info = "names"), row.names = F, col.names = F, quote = F)
```

### CTD
#### Filtering
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Load the CTD data.
ONeil_drug_cgixns_CTD_raw = read.csv(paste0(folder_generator(data_dir, data_source = "ONeil", data_type = "Drugs", processing_stage = "Processed"), "CTD_chem_cgixns_1635832327332.csv"))

# Filter drugs to include the following: 1) has data, 2) is human, 3) has no cotreatment stuff, 4) includes information on increasing/decreasing activity/expression (not just "affects.")
ONeil_drug_cgixns_CTD_filtered = ONeil_drug_cgixns_CTD_raw %>% dplyr::filter(!base::grepl("found", Input) & 
                                          OrganismID == "9606" &
                                          !base::grepl("reaction", InteractionActions) & 
                                          !base::grepl("response", InteractionActions) & 
                                          !base::grepl("cotreatment", InteractionActions) &
                                          (
                                            base::grepl("increases\\^activity", InteractionActions) |
                                              base::grepl("increases\\^expression", InteractionActions) |
                                              base::grepl("decreases\\^activity", InteractionActions) |
                                              base::grepl("decreases\\^expression", InteractionActions)
                                            )
                                        )

# Save the filtered data.
ONeil_drug_cgixns_CTD_filtered_filename = paste0(folder_generator(data_dir, data_source = "ONeil", data_type = "Drugs", processing_stage = "Processed"), "ONeil_CTD_chem_cgixns_1635832327332_filtered.rds")
saveRDS(ONeil_drug_cgixns_CTD_filtered, ONeil_drug_cgixns_CTD_filtered_filename)
```

### DrugBank
DrugBank data was downloaded as an XML file from [...] on [...]. The data was migrated to a MySQL database for easier retrieval. See the Supplemental Data section for detailed methods. 
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Update 08/16/2021: now including even the drugs without KEGG pathways.
ONeil_drugs_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
ONeil_drugs = read.csv(ONeil_drugs_filename)
drugs = ONeil_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(drug_name) %>% unlist %>% unique %>% str_to_lower
DB_ids = ONeil_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(DB_id) %>% unlist %>% unique

ONeil_drug_target_data_DrugBank_tmp = data.frame(
  Drug = character(),
  Target = character(),
  Effect = numeric(),
  stringsAsFactors = F
)

# Get the targets of the drugs from the MySQL database. 

# Get all the possible pharmacological actions. 
#query = "SELECT PharmacologicalAction FROM DrugTargets.DrugBank;"
#res = dbSendQuery(DrugTargetsDB, query)
#pharm_actions = dbFetch(res) %>% unlist() %>% unique()
#View(pharm_actions)
#dbClearResult(res)
inhibitory_actions = c("inhibitor", "antagonist", "antibody", "inverse agonist", "inhibitory allosteric modulator", "negative modulator", "blocker", "weak inhibitor", "downregulator", "partial antagonist", "suppressor", "inactivator", "degradation", "incorporation into and destabilization", "inhibition of synthesis")
activating_actions = c("activator", "agonist", "stimulator", "potentiator", "inducer", "positive allosteric modulator", "partial agonist", "positive modulator")
        
# https://programminghistorian.org/en/lessons/getting-started-with-mysql-using-r#create-an-r-script-that-connects-to-the-database
# Make the connection to the MySQL database. 
# The connection method below uses a password stored in a settings file.
user_password = "Kibougaaru2020"
DrugTargetsDB = dbConnect(RMariaDB::MariaDB(), 
                          user='root', 
                          password=user_password, 
                          dbname='DrugTargets', 
                          host='localhost')
dbListTables(DrugTargetsDB)

# Make the queries. 
for(db_id in DB_ids) {
  query = paste0("SELECT DrugName, TargetName, Organism, PharmacologicalAction FROM DrugTargets.DrugBank WHERE DrugBankID = '", db_id, "';")
  res = dbSendQuery(DrugTargetsDB, query)
  drug_data = dbFetch(res)
  dbClearResult(res)
  
  if(nrow(drug_data) < 1) next
  
  # Get the drug name.
  drug_name = ONeil_drugs %>% dplyr::filter(DB_id==db_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  
  # Select the entries with "Human" in the Organism column.
  drug_data = drug_data %>% dplyr::filter(base::grepl("Human", Organism))
  
  # For each target, get the effect.
  for(target in unique(drug_data$TargetName)) {
    # Get the number of effects.
    drug_actions = drug_data %>% dplyr::filter(TargetName == target) %>% dplyr::select(PharmacologicalAction) %>% unique()
    
    if(length(drug_actions) > 0) {
      # Convert the pharmacological actions to -1, 0, or 1. 
      inhibitory = ifelse(sum(drug_actions %in% inhibitory_actions) > 0, T, F)
      activating = ifelse(sum(drug_actions %in% activating_actions) > 0, T, F)
      if(inhibitory & !activating) {
        drug_action_numeric = -1
      } else if(activating & !inhibitory) {
        drug_action_numeric = 1
      } else {
        drug_action_numeric = 0
      }
        
      # Add to the table.
      ONeil_drug_target_data_DrugBank_tmp = rbind(ONeil_drug_target_data_DrugBank_tmp, data.frame(
        Drug = drug_name,
        Target = target,
        Effect = drug_action_numeric,
        stringsAsFactors = F
      ))
    }
  }
}
# Disconnect
dbDisconnect(DrugTargetsDB)

# Save the temporary table.
ONeil_drug_target_data_DrugBank_tmp_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "DrugBank", extension = ".rds", processing_stage = "Processed", additional_info = "target_data_tmp")
saveRDS(ONeil_drug_target_data_DrugBank_tmp, ONeil_drug_target_data_DrugBank_tmp_filename)

# Make sure all the drug names in ONeil_drug_target_data_DrugBank_tmp match the names in drugs. (We will need to do some manual correction, more than likely.)
setdiff(unique(ONeil_drug_target_data_DrugBank_tmp$Drug), drugs)
setdiff(drugs, unique(ONeil_drug_target_data_DrugBank_tmp$Drug))

# Convert the targets in ONeil_drug_target_data_DrugBank_tmp to ENTREZ IDs.
hs = org.Hs.eg.db
keys = ONeil_drug_target_data_DrugBank_tmp$Target %>% as.character()
x = AnnotationDbi::select(hs, 
               keys = keys,
               columns = c("SYMBOL", "ENTREZID"),
               keytype = "SYMBOL") %>% .[complete.cases(.),] %>% distinct()

# Remove any ENTREZIDs that don't have corresponding KEGG entries.
entrez_no_kegg = c()
for(entrez_id in unique(x$ENTREZID)) {
  print(paste0("Checking if gene ", entrez_id, " has a KEGG entry."))
  
  possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
        entrez_test = keggGet(paste0("hsa:", entrez_id))
    }, error=function(cond) {
        message(cond)
    }
    )
  if(inherits(possibleError, "error") | !exists("entrez_test")) {
      entrez_no_kegg = c(entrez_no_kegg, entrez_id)
  }
  
  rm(entrez_test)
}
x = x %>% dplyr::filter(!(ENTREZID %in% entrez_no_kegg))
# Convert to ENTREZ.
# https://stackoverflow.com/a/3905442
a = x$SYMBOL
b = x$ENTREZID
ONeil_drug_target_data_DrugBank_tmp$Target = b[match(ONeil_drug_target_data_DrugBank_tmp$Target, a)]
ONeil_drug_target_data_DrugBank = ONeil_drug_target_data_DrugBank_tmp %>% .[complete.cases(.),]

# We won't need to convert to list to match CTD format until we merge the DrugBank and KEGG data.

# Merge.
#ONeil_drug_target_data_DrugBank = rbind(ONeil_drug_target_data_DrugBank, ONeil_drug_target_data_DrugBank_tmp)

# Change everything to sentence caps. 
#ONeil_drug_target_data_DrugBank$Drug = str_to_sentence(ONeil_drug_target_data_DrugBank$Drug)

# Filter out targets that already exist (i.e. keep only unique rows.)
#ONeil_drug_target_data_DrugBank = ONeil_drug_target_data_DrugBank %>% distinct()

# 11 Aug 2021: replace venotoclax -> venetoclax.
ONeil_drug_target_data_DrugBank$Drug = ONeil_drug_target_data_DrugBank$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")

# Save.
# Update 08/16/2021: now including even the drugs without KEGG pathways.
ONeil_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
write.table(ONeil_drug_target_data_DrugBank, ONeil_drug_target_data_DrugBank_filename, sep=",", row.names=F)
```

### KEGG
KEGG data was downloaded using the KEGGREST package in R (3.6.3.) Since KEGG does not provide the pharmacological effects of drugs on the target (e.g. whether the drug acts as an antagonist or agonist), 

```{r echo = FALSE, eval=TRUE, include=FALSE}
ONeil_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
ONeil_drug_target_data_DrugBank = read.csv(ONeil_drug_target_data_DrugBank_filename)

ONeil_drugs_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
ONeil_drugs = read.csv(ONeil_drugs_filename, stringsAsFactors = F)
kegg_ids = ONeil_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(KEGG_id) %>% unlist %>% unique %>% .[!is.na(.)]

ONeil_drug_target_data_KEGG = data.frame(
  Drug = character(),
  Target = character(),
  Effect = character()
)
# Table to hold the mutant/fusion protein targets. 
ONeil_drug_target_data_KEGG_v = data.frame( # v = variation. 
  Drug = character(),
  Target = character()
)
for(kegg_drug_id in kegg_ids) {
  drug = ONeil_drugs %>% dplyr::filter(KEGG_id==kegg_drug_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  print(paste0("Getting the KEGG targets for drug ", drug, "."))

    # Get the pathways affected.
  if(!is.null(kegg_drug_id) & !is.na(kegg_drug_id)) {
    
    possibleError = tryCatch(
    {
      kegg_pathways = keggGet(kegg_drug_id)[[1]]$TARGET
    }, error=function(cond) {
      message(paste0("There was a problem retrieving the drug-target data from KEGG for the drug ", drug, ":"))
      message(cond)
    }
  )
  
    if(inherits(possibleError, "error")) {
      print(paste0("There was a problem retrieving the drug-target data from KEGG for the drug ", drug, ":"))
      next
    }
  
    else {
      if(class(kegg_pathways)=="list") {
        # Get the mutant/fusion protein targets and add them to a separate table. 
        kegg_targets = kegg_pathways$TARGET
        v_targets = kegg_targets %>% regexPipes::grep("\\*", value = T) %>% str_split(" ") %>% unlist %>% regexPipes::grep("\\[HSA\\:", value = T) %>% regexPipes::gsub("\\[HSA\\:", "") %>% regexPipes::gsub("\\]", "") # This assumes that drugs can't target both a mutant and non-mutant form. ... 
        ONeil_drug_target_data_KEGG_v = rbind(ONeil_drug_target_data_KEGG_v, data.frame(
          Drug = rep(drug, length(v_targets)),
          Target = v_targets
        ))
        
        # Now get the rest of the targets from the pathways. 
        kegg_pathways = kegg_pathways$PATHWAY
      
        # Keep only the signal-transduction and disease-associated pathways (hsa03xxx, hsa04xxx and hsa05xxx.) 
        kegg_pathway_names = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("[[:space:]]+.+$", "")
      
        # Get the targets of the drug and filter the targets to include only the ones that are not already present in the DB table.
        drug_targets_DrugBank = ONeil_drug_target_data_DrugBank %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist
        targets = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("hsa0[345][[:digit:]]{3}", "") %>% regexPipes::gsub("[[:space:]]+.+$", "") %>% regexPipes::gsub("[()]", "") %>% str_split("\\+") %>% unlist() %>% unique() #%>% .[!(. %in% drug_targets_DrugBank)] As of 2022-06-05, we are no longer removing the drug targets present in the DrugBank table at this step. We will wait until the "Merging DrugBank and KEGG" step to do that, because we need all the KEGG targets present when we do the TRRUST stuff. 
      
        # Add to the table.
        ONeil_drug_target_data_KEGG = rbind(ONeil_drug_target_data_KEGG, data.frame(
          Drug = rep(drug, length(targets)),
          Target = targets,
          Effect = rep(-1, length(targets)) # I'm assuming most of the drugs are inhibitors. ... 
        ))
      }
    }
  } 
  
}

# Keep only unique rows.
ONeil_drug_target_data_KEGG = ONeil_drug_target_data_KEGG %>% distinct()

# For the most part, the drugs are inhibitors, but for two drug-target pairs, fulvestrant and 2100, and phenformin and 5563, we will have to manually update them. 
# ... No phenformin in ONeil, though. That's in GDSC. 
ONeil_drug_target_data_KEGG = ONeil_drug_target_data_KEGG
ONeil_drug_target_data_KEGG[ONeil_drug_target_data_KEGG$Drug=="fulvestrant" & ONeil_drug_target_data_KEGG$Target=="2100","Effect"] = 0
#ONeil_drug_target_data_KEGG[ONeil_drug_target_data_KEGG$Drug=="phenformin" & ONeil_drug_target_data_KEGG$Target=="5563","Effect"] = 1

# 11 Aug 2021: replace venotoclax -> venetoclax.
ONeil_drug_target_data_KEGG$Drug = ONeil_drug_target_data_KEGG$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")
ONeil_drug_target_data_KEGG_v$Drug = ONeil_drug_target_data_KEGG_v$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")

# Remove the following drugs from the _v table, since they do not target mutant but overexpressed/fusion proteins: trastuzumab, lapatinib, crizotinib. Well, maybe keep crizo in the _v table for consistency? It looks like we did that for the network scores? 
ONeil_drug_target_data_KEGG_v$Effect = -1
for(drug in c("lapatinib")) {
  # Add the appropriate row to non-_v table.
  ONeil_drug_target_data_KEGG = rbind(ONeil_drug_target_data_KEGG, ONeil_drug_target_data_KEGG_v %>% dplyr::filter(Drug==drug))
}
ONeil_drug_target_data_KEGG_v = ONeil_drug_target_data_KEGG_v %>% dplyr::filter(!(Drug %in% c("lapatinib")))

# Save. 
ONeil_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
ONeil_drug_target_data_KEGG_v_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_data", processing_stage = "Processed")
write.table(ONeil_drug_target_data_KEGG, ONeil_drug_target_data_KEGG_filename, sep=",", row.names=F)
write.table(ONeil_drug_target_data_KEGG_v, ONeil_drug_target_data_KEGG_v_filename, sep=",", row.names=F)
```

### Merging DrugBank and KEGG
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Load the Drugbank and KEGG target information.
ONeil_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
ONeil_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
ONeil_drug_target_data_KEGG_v_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_data", processing_stage = "Processed")
ONeil_drug_target_data_KEGG = read.csv(ONeil_drug_target_data_KEGG_filename)
ONeil_drug_target_data_KEGG_v = read.csv(ONeil_drug_target_data_KEGG_v_filename)
ONeil_drug_target_data_DrugBank = read.csv(ONeil_drug_target_data_DrugBank_filename)

# Merge the Drugbank and KEGG target tables. 
ONeil_drug_target_data_DrugBank_KEGG = rbind(ONeil_drug_target_data_DrugBank, ONeil_drug_target_data_KEGG) %>% distinct()
# Consolidate duplicate rows (i.e., rows with the same target but different effects).
# https://stackoverflow.com/a/10180178
ONeil_drug_target_data_DrugBank_KEGG = ONeil_drug_target_data_DrugBank_KEGG %>% dplyr::select(Drug, Target, Effect) %>% ddply(.(Drug, Target), numcolwise(sum))
#rownames(ONeil_drug_target_data_DrugBank_KEGG) = ONeil_drug_target_data_DrugBank_KEGG$Target
# Because of the consolidation in the previous step, we might have effect values > 1 or < -1. Set the ceiling and floor to be 1 and -1, respectively. 
ONeil_drug_target_data_DrugBank_KEGG$Effect = ifelse(ONeil_drug_target_data_DrugBank_KEGG$Effect > 1, 1, ONeil_drug_target_data_DrugBank_KEGG$Effect)
ONeil_drug_target_data_DrugBank_KEGG$Effect = ifelse(ONeil_drug_target_data_DrugBank_KEGG$Effect < -1, -1, ONeil_drug_target_data_DrugBank_KEGG$Effect)

# Remove all the entries from the Drugbank targets that are also present in the variant KEGG table (i.e. the ones that have mutations/fusions.)
ONeil_drug_target_data_DrugBank_KEGG = ONeil_drug_target_data_DrugBank_KEGG %>% .[!(paste(.$Drug, .$Target, sep="_") %in% paste(ONeil_drug_target_data_KEGG_v$Drug, ONeil_drug_target_data_KEGG_v$Target, sep="_")),]

# Convert from Entrez ID to HUGO gene symbol. 
hs = org.Hs.eg.db
keys = ONeil_drug_target_data_DrugBank_KEGG$Target %>% as.character
x = AnnotationDbi::select(hs, 
                          keys = keys,
                          columns = c("SYMBOL", "ENTREZID"),
                          keytype = "ENTREZID") %>% .[complete.cases(.),]
ONeil_drug_target_data_DrugBank_KEGG$Target = x %>% .[match(ONeil_drug_target_data_DrugBank_KEGG$Target, .$ENTREZID),] %>% .$SYMBOL

# Split the dataframe into a list, to match the CTD drug-target-data format and the format that most of the calcNetworkScores() functions use. 
ONeil_drug_target_data_DrugBank_KEGG = split(ONeil_drug_target_data_DrugBank_KEGG , f = ONeil_drug_target_data_DrugBank_KEGG$Drug)

# Remove all entries in the list whose tables have 0 rows. (28 June 2021.)
for(entry in names(ONeil_drug_target_data_DrugBank_KEGG)) {
  if(nrow(ONeil_drug_target_data_DrugBank_KEGG[[entry]]) < 1) {
    ONeil_drug_target_data_DrugBank_KEGG[[entry]] = NULL
  } 
}

# Save.
ONeil_drug_target_data_DrugBank_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "DrugBank_KEGG", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(ONeil_drug_target_data_DrugBank_KEGG, ONeil_drug_target_data_DrugBank_KEGG_filename)
```

### TRRUST
#### Target pathways from KEGG
```{r}
# From KEGG, get the pathways targeted by each drug. 
ONeil_drugs_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
ONeil_drugs = read.csv(ONeil_drugs_filename, stringsAsFactors = F)
drugs = ONeil_drugs %>% dplyr::select(drug_name) %>% unlist %>% unique %>% str_to_lower
ONeil_drug_target_pathway_data_KEGG = data.frame(
  Drug = character(),
  PathwayName = character(),
  PathwayID = character(),
  Target = character(),
  stringsAsFactors = F
)
ONeil_drug_target_pathway_data_KEGG_v = data.frame(
  Drug = character(),
  PathwayName = character(),
  PathwayID = character(),
  Target = character(),
  stringsAsFactors = F
)
kegg_ids = ONeil_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(KEGG_id) %>% unlist %>% unique %>% .[!is.na(.)]
for(kegg_drug_id in kegg_ids) {
  drug = ONeil_drugs %>% dplyr::filter(KEGG_id==kegg_drug_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  print(paste0("Getting KEGG pathways for drug ", drug, "."))
  
  if(!is.null(kegg_drug_id)) {
    kegg_drug_id = kegg_drug_id %>% str_trim
    kegg_pathways = keggGet(kegg_drug_id)[[1]]$TARGET
    
    if(class(kegg_pathways)=="list") {
      # Get the targets of the drug.
      kegg_targets = kegg_pathways$TARGET
      
      # Get the mutant/fusion protein targets and add them to a separate table. 
      v_targets = kegg_targets %>% regexPipes::grep("\\*", value = T) %>% str_split(" ") %>% unlist %>% regexPipes::grep("\\[HSA\\:", value = T) %>% regexPipes::gsub("\\[HSA\\:", "") %>% regexPipes::gsub("\\]", "") # This assumes that drugs can't target both a mutant and non-mutant form. ... 
      ONeil_drug_target_pathway_data_KEGG_v = rbind(ONeil_drug_target_pathway_data_KEGG_v, data.frame(
        Drug = rep(drug, length(v_targets)),
        PathwayName = rep(NA, length(v_targets)),
        PathwayID = rep(NA, length(v_targets)),
        Target = v_targets
      ))
      
      # Now get the rest of the targets from the pathways. 
      kegg_pathways = kegg_pathways$PATHWAY
      
      # Get the names of the pathways.
      kegg_pathway_names = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>%  regexPipes::gsub("^[[:alnum:]]+\\(.*\\)[[:space:]]*", "") %>% str_to_upper() %>% regexPipes::gsub("[[:space:]]", "_") %>% paste0("KEGG_", .)
      # Get the KEGG IDs of the pathways.
      KEGG_pathway_ids = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("\\(.+$", "")
      # Get the targets in those pathways. 
      kegg_pathway_targets = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("hsa0[345][[:digit:]]{3}\\(", "") %>% regexPipes::gsub("\\).+$", "") %>% str_split("\\+")
      if(length(kegg_pathway_targets) < 1) {
        print(paste0("There are no applicable KEGG pathways for drug ", drug, ". Skipping to the next one."))
        next
      }
      names(kegg_pathway_targets) = KEGG_pathway_ids
      
      # Create the vectors for the drugs, pathway names, pathway IDs, and targets.
      target_vector = kegg_pathway_targets %>% unlist
      pathway_id_vector = c()
      for(name in names(kegg_pathway_targets)) {
        pathway_id_vector = c(pathway_id_vector, rep(name, length(kegg_pathway_targets[[name]])))
      }
      pathway_name_vector = c()
      for(i in 1:length(kegg_pathway_targets)) {
        pathway_name_vector = c(pathway_name_vector, rep(kegg_pathway_names[i], length(kegg_pathway_targets[[i]])))
      }
  
      if(length(kegg_pathway_names)==length(KEGG_pathway_ids)) {
        ONeil_drug_target_pathway_data_KEGG = rbind(ONeil_drug_target_pathway_data_KEGG, data.frame(
          Drug = rep(drug, length(pathway_name_vector)),
          PathwayName = pathway_name_vector,
          PathwayID = pathway_id_vector,
          Target = target_vector,
          stringsAsFactors = F
        ))
      } # End if(length(kegg_pathway_names)==length(KEGG_pathway_ids)). 
    } # End if(class(kegg_pathways)=="list"). 
  } # End if(!is.null(kegg_drug_id)). 

}

# Currently, the normal target table has ALL the records. We will remove from it all the mutant protein targets. (This is different from what we did in the KEGG protein target section.)
# Add RecordID field to both _v and normal target tables.
ONeil_drug_target_pathway_data_KEGG$RecordID = paste(ONeil_drug_target_pathway_data_KEGG$Drug, ONeil_drug_target_pathway_data_KEGG$Target, sep = "_")
ONeil_drug_target_pathway_data_KEGG_v$RecordID = paste(ONeil_drug_target_pathway_data_KEGG_v$Drug, ONeil_drug_target_pathway_data_KEGG_v$Target, sep = "_")

# Remove the following drugs from the _v table, since they do not target mutant but overexpressed/fusion proteins: trastuzumab, lapatinib, crizotinib.
ONeil_drug_target_pathway_data_KEGG_v = ONeil_drug_target_pathway_data_KEGG_v %>% dplyr::filter(!(Drug %in% c("Trastuzumab", "Lapatinib", "Crizotinib")))
# Now filter the normal table by the _v table.
# But first save the _v stuff!
tmp = ONeil_drug_target_pathway_data_KEGG %>% dplyr::filter(RecordID %in% ONeil_drug_target_pathway_data_KEGG_v$RecordID)
ONeil_drug_target_pathway_data_KEGG = ONeil_drug_target_pathway_data_KEGG %>% dplyr::filter(!(RecordID %in% ONeil_drug_target_pathway_data_KEGG_v$RecordID))
ONeil_drug_target_pathway_data_KEGG_v = tmp

rm(tmp)

# Save to file.
ONeil_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
ONeil_drug_target_pathway_data_KEGG_v_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_pathway_data", processing_stage = "Processed")
write.table(ONeil_drug_target_pathway_data_KEGG, ONeil_drug_target_pathway_data_KEGG_filename, sep=",", row.names=F)
write.table(ONeil_drug_target_pathway_data_KEGG_v, ONeil_drug_target_pathway_data_KEGG_v_filename, sep=",", row.names=F)
```

#### Genes downstream of each drug target
```{r}
# Get all the targeted pathways. 
ONeil_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
ONeil_drug_target_pathway_data_KEGG = read.csv(ONeil_drug_target_pathway_data_KEGG_filename)
# We no longer have to remove drug-target-pathway combinations involving mutant/fusion proteins in this step, since we did it in the last one. 08/21/2021.
KEGG_pathway_ids = ONeil_drug_target_pathway_data_KEGG$PathwayID %>% unique() 
# Get all the direct targets of the drugs.
ONeil_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
ONeil_drug_target_data_KEGG = read.csv(ONeil_drug_target_data_KEGG_filename)
ONeil_drug_targets_KEGG = ONeil_drug_target_data_KEGG$Target %>% unique() %>% paste0("hsa:", .)

# For each pathway, get the nodes downstream of each target. 
ONeil_drug_target_downstream_node_data_KEGG = data.frame(
  Pathway = character(),
  Target = character(),
  DownstreamNodes = character(),
  Effects = numeric(),
  stringsAsFactors = F
)
for(pathway in KEGG_pathway_ids) {
  print(paste0("Working on pathway ", pathway, "."))
  
  # Load the KGML file. 
  #kgml = keggGet("hsa04010", option = "kgml")
  #parsed_kgml = parseKGML(kgml)
  #pathway_graph = KEGGpathway2Graph(parsed_kgml)
  kgml = keggGet(pathway, option = "kgml")

  # Convert the KGML file into an iGraph object.
  # First convert to a graphNEL object.
  graphNEL = parseKGML2Graph(kgml, expandGenes = T, genesOnly = F) # PI3K signaling occurs through PIP3, which is a lipid. ... 
  #graphNEL_layout = layoutGraph(graphNEL)
  #renderGraph(graphNEL_layout)
  
  # For MAPK pathway only--create a directed edge between the RTK node and the GRB2 node, and between the GRB2 node and the SOS node. 
  rtk_nodes = c("hsa:1436","hsa:1956","hsa:1969","hsa:2064","hsa:2065","hsa:2066","hsa:2260","hsa:2261","hsa:2263","hsa:2264","hsa:2321","hsa:2322","hsa:2324","hsa:3480","hsa:3643","hsa:3791","hsa:3815","hsa:4233","hsa:4804","hsa:4914","hsa:4915","hsa:5156","hsa:5159","hsa:7010")
  grb2_node = "hsa:2885"
  sos_nodes = c("hsa:6654","hsa:6655")
  if(pathway=="hsa04010") {
    graphNEL = addEdge(rtk_nodes, grb2_node, graphNEL, 1)
    graphNEL = addEdge(grb2_node, sos_nodes, graphNEL, 1)
  }
  
  # Next, weight the edges by whether they are inhibitory or activating. 
  # @_@
  # For each edge in the graph (pathway_graph or graphNEL), use the KEGG edge data to determine whether it is an activating or inhibitory edge. If it is activating, leave it alone. Otherwise, set it to -1. 
  kegg_edge_data = getKEGGedgeData(graphNEL)
  kegg_edges = edges(graphNEL)
  kegg_edge_weights = edgeWeights(graphNEL)
  # Generate a list of all the edges. 
  all_edges = c()
  for(first_node in names(kegg_edges)) {
    if(length(kegg_edges[[first_node]]) > 0) all_edges = c(all_edges, paste0(first_node, "~", kegg_edges[[first_node]]))
  }
        
  for(edge in all_edges) {
    first_node = str_split(edge, "~") %>% unlist %>% .[1]
    second_node = str_split(edge, "~") %>% unlist %>% .[2]
    edge_data = getKEGGedgeData(graphNEL)[[edge]] # This will be NULL for the edges we added on, since we only added the edges, not any metadata. 
    if(!is.null(edge_data)) {
      if(length(getSubtype(edge_data)) > 0) {
        edge_subtype = getName(getSubtype(getKEGGedgeData(graphNEL)[[edge]])$subtype) # "activation" or "inhibition".
        } else {
          edge_subtype = "activation"
        }
    } else {
        edge_subtype = "activation"
      }
    
    if(edge_subtype=="inhibition") kegg_edge_weights[[first_node]][second_node] = -1
  }
  #edgeWeights(graphNEL) = kegg_edge_weights
  # Above line of code doesn't work--see comment below. 
  
  # Then convert to iGraph.
  igraph = graph_from_graphnel(graphNEL, name = TRUE, weight = TRUE,
  unlist.attrs = TRUE)
  # Set the weights of the iGraph to be kegg_edge_weights.
  # (We can't change the weights of a graphNEL object, apparently, so we have to do it this way. ... Of course, this assumes that the edges are in the same order in igraph as they are once you unlist kegg_edge_weights. ... If we ever update any of the packages used here, we will have to 2x check this.)
  edge_attr(igraph)$weight = unlist(kegg_edge_weights)
  
  # Get the downstream nodes of the target of the drug. 
  # https://rdrr.io/github/robertness/lucy/man/get_downstream_nodes.html 
  ONeil_drug_targets_KEGG_i = ONeil_drug_targets_KEGG %>% .[. %in% names(V(igraph))]
  for(drug_target in ONeil_drug_targets_KEGG_i) {
    print(paste0("Working on target ", drug_target, " in pathway ", pathway, "."))
    
    w = V(igraph)[drug_target]
     possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      downstream_nodes = V(igraph)[get_downstream_nodes(igraph, w)]
    }, error=function(cond) {
      message(paste0("There was a problem getting the nodes downstream from target ", drug_target, ":"))
      message(cond)
    }
  )
    if(inherits(possibleError, "error") | !exists("downstream_nodes")) {
      print(paste0("Skipping drug target ", drug_target, "."))
      next
    }
    
    # Check if there are any downstream nodes. If not, move on to the next target.
    if(length(downstream_nodes) < 1) {
      print(paste0("Target ", drug_target, " has no downstream nodes. Moving on!"))
      next
    }
    downstream_node_names = downstream_nodes %>% names() # %>% paste(collapse=",")
    
    # Determine the effect of the target on each node? (I.e. upregulated or downregulated. ... This is important, but can we do it without having to do it manually??)
    # Get all the edges between the target and the downstream nodes. 
    #all_paths = all_simple_paths(igraph, from = V(igraph)[drug_target], to = downstream_nodes, mode = "out")
    possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      all_paths = shortest_paths(igraph, from = V(igraph)[drug_target], to = downstream_nodes, weights = rep(1, length(unlist(kegg_edge_weights)))) %>% .$vpath # Have to set the weights to all be positive; otherwise, the algorithm doesn't work. Using all_simple_paths returns all possible paths. 
    }, error=function(cond) {
      message(paste0("There was a problem getting the shortest paths from target ", drug_target, ":"))
      message(cond)
    }
  )
    if(inherits(possibleError, "error") | !exists("all_paths")) {
      print(paste0("Skipping drug target ", drug_target, "."))
      next
    }

    effects = c()
    for(i in 1:length(all_paths)) {
      # Get path i. 
      path = all_paths[[i]] %>% names()
      # Because of the way get.edge.ids works, we need to duplicate all inner vertices (vertices that are not the first or last) in path in order to get all the edges that make up the path.
      if(length(path) > 2) {
        vertices = c(path[1], rep(path[2:(length(path)-1)], each = 2), path[length(path)])
      } else {
        vertices = path
      }
      # Get the IDs of the edges connecting vertices in the path. 
      edge_ids = get.edge.ids(igraph, vertices, directed = TRUE, error = FALSE,
  multi = FALSE)
      # Get the weights of those edges.
      weights = edge_attr(igraph, "weight", index = E(igraph)[edge_ids])
      # Multiply them together. 
      # https://stackoverflow.com/a/62561005
      effect = ifelse(prod(weights) < 0, -1, 1)
      # If < 0, then -1; if > 0, then 1.
      effects = c(effects, effect)
    }
    
    # Add to the table. 
    ONeil_drug_target_downstream_node_data_KEGG = rbind(ONeil_drug_target_downstream_node_data_KEGG, data.frame(
    Pathway = rep(pathway, length(downstream_nodes)),
    Target = rep(drug_target, length(downstream_nodes)),
    DownstreamNodes = names(downstream_nodes),
    Effects = effects,
    stringsAsFactors = F
    ))
    
    # Remove old "downstream_nodes" and "all_paths" so that the error checks can be triggered properly.
    rm(downstream_nodes, all_paths)
  }
    
}

# Save.
ONeil_drug_target_downstream_node_data_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_downstream_node_data", processing_stage = "Processed")
write.table(ONeil_drug_target_downstream_node_data_KEGG, ONeil_drug_target_downstream_node_data_KEGG_filename, sep=",", row.names=F)
```

#### Transcription factors and their targets for each pathway
```{r}
ONeil_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
ONeil_drug_target_pathway_data_KEGG = read.csv(ONeil_drug_target_pathway_data_KEGG_filename)

KEGG_pathways_complete_filename = paste0(folder_generator(data_dir, data_source = "GSEA-MSigDB", data_type = "Misc", processing_stage = "Raw"), "c2.cp.kegg.v7.1.symbols.gmt")
KEGG_pathways_complete = GSA.read.gmt(KEGG_pathways_complete_filename)
ONeil_drug_target_downstream_node_data_KEGG = read.csv(ONeil_drug_target_downstream_node_data_KEGG_filename)

# Load the TRRUST data. 
TRRUST_data_filename = paste0(folder_generator(data_dir, data_source = "TRRUST", data_type = "Misc", processing_stage = "Raw"), "trrust_rawdata.human.tsv")
TRRUST_data = read.table(TRRUST_data_filename, header = F)
colnames(TRRUST_data) = c("TF", "Target",	"ModeOfRegulation",	"PMID")
# Exclude all unknown interactions from the TRRUST data. 
TRRUST_data = TRRUST_data %>% dplyr::filter(ModeOfRegulation != "Unknown")

# For each unique pathway in ONeil_drug_target_pathway_data_KEGG, get the transcription factors from that pathway. 
ONeil_drug_target_txnal_target_data_KEGG_TRRUST = data.frame(
  Pathway = character(),
  DrugTarget = character(),
  TFentrez = character(),
  TFsymbol = character(),
  TranscriptionalTarget = character(),
  ModeOfRegulation = character(),
  stringsAsFactors = F
)

for(pathway in unique(ONeil_drug_target_pathway_data_KEGG$PathwayID)) {
  # Get the drug targets in that pathway. 
  pathway_drug_targets = ONeil_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Pathway==pathway) %>% dplyr::select(Target) %>% unlist() %>% unique()
  
  for(drug_target in pathway_drug_targets) {
    # Get the nodes downstream of that target. Remove any nodes that are not genes. 
    downstream_nodes = ONeil_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Pathway==pathway & Target == drug_target & regexPipes::grepl(.$DownstreamNodes, "hsa\\:")) %>% dplyr::select(DownstreamNodes, Effects) %>% distinct()
  
    if(nrow(downstream_nodes) < 1) {
      print(paste0("Target ", drug_target, " has no downstream gene nodes. Skipping this one!"))
      next
    }
    
    # Convert the downstream nodes from their KEGG ID to their gene name. 
    hs = org.Hs.eg.db
    keys = downstream_nodes$DownstreamNodes %>% unlist() %>% regexPipes::gsub("hsa\\:", "")
    x = AnnotationDbi::select(hs, 
               keys = keys,
               columns = c("SYMBOL", "ENTREZID"),
               keytype = "ENTREZID") %>% .[complete.cases(.),]
    # We will be back-converting from symbols to ENTREZ IDs, so make sure that each symbol maps to only ONE ENTREZ ID. 
    # ... Which, come to think of it, shouldn't be a problem, since we started out with ENTREZ IDs, and I don't think KEGG had duplicates. ... 
  
    # Get the transcription factors.
    # https://stackoverflow.com/questions/10586652/r-preserve-order-when-using-matching-operators-in
    tfs = intersect(unique(TRRUST_data$TF), x$SYMBOL)
    if(length(tfs) < 1) {
      print(paste0("Target ", drug_target, " has no downstream transcription factors. Skipping this one!"))
      next
    }
    
    tfs_entrez = x %>% .[match(tfs, .$SYMBOL),] %>% .$ENTREZID %>% paste0("hsa:", .)
    names(tfs_entrez) = tfs
  
    # Get the targets of those transcription factors.
    for(tf in tfs) {
      txn_target = TRRUST_data %>% dplyr::filter(TF==tf) %>% dplyr::select(TF, Target, ModeOfRegulation)
    
      # Add to the table if there are any transcriptional targets. 
      ONeil_drug_target_txnal_target_data_KEGG_TRRUST = rbind(ONeil_drug_target_txnal_target_data_KEGG_TRRUST, data.frame(
        Pathway = rep(pathway, nrow(txn_target)),
        DrugTarget = rep(drug_target, nrow(txn_target)),
        TFentrez = rep(tfs_entrez[tf], nrow(txn_target)),
        TFsymbol = txn_target$TF,
        TranscriptionalTarget = txn_target$Target,
        ModeOfRegulation = txn_target$ModeOfRegulation,
        stringsAsFactors = F
        ))
    }
    
  }
  
}

# Add an effect column.
ONeil_drug_target_txnal_target_data_KEGG_TRRUST$Effect = ifelse(ONeil_drug_target_txnal_target_data_KEGG_TRRUST$ModeOfRegulation=="Repression", -1, 1)

# Save.
ONeil_drug_target_txnal_target_data_KEGG_TRRUST_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG_TRRUST", extension = ".csv", additional_info = "target_txnal_target_data", processing_stage = "Processed")
write.table(ONeil_drug_target_txnal_target_data_KEGG_TRRUST, ONeil_drug_target_txnal_target_data_KEGG_TRRUST_filename, sep=",", row.names=F)
```

#### Final effects of drugs on downstream targets
Combine the data from ONeil_drug_target_data_KEGG, drug_genes_table and ONeil_drug_target_txnal_target_data_KEGG_TRRUST (i.e. multiply the effects) to get the final effect of the drug on each of its transcriptional targets. 
```{r}
ONeil_drug_target_txnal_target_data_KEGG_TRRUST_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG_TRRUST", extension = ".csv", additional_info = "target_txnal_target_data", processing_stage = "Processed")
ONeil_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
ONeil_drug_target_downstream_node_data_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_downstream_node_data", processing_stage = "Processed")
ONeil_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")

ONeil_drug_target_txnal_target_data_KEGG_TRRUST = read.csv(ONeil_drug_target_txnal_target_data_KEGG_TRRUST_filename)
ONeil_drug_target_pathway_data_KEGG = read.csv(ONeil_drug_target_pathway_data_KEGG_filename)
ONeil_drug_target_downstream_node_data_KEGG = read.csv(ONeil_drug_target_downstream_node_data_KEGG_filename)
ONeil_drug_target_data_KEGG = read.csv(ONeil_drug_target_data_KEGG_filename)

ONeil_drug_target_data_TRRUST = data.frame(
  Drug = character(),
  Target = character(),
  Effect = numeric(),
  stringsAsFactors = F
)

# Indirect targets. 
for(drug in unique(ONeil_drug_target_data_KEGG$Drug)) {
  # For each drug, get its corresponding targets from ONeil_drug_target_data_KEGG. 
  drug_targets = ONeil_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist() %>% paste0("hsa:", .)
  
  # Get the pathways this drug is involved in. We are going to restrict transcriptional effects to the pathways the drug is known to be involved in. (E.g., if drug A targets EGFR, even if EGFR is involved in multiple pathways, we will only consider the pathways that drug A has listed in KEGG.)
  drug_pathways = ONeil_drug_target_pathway_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(PathwayID) %>% unlist() %>% unique
  
  for(drug_target in drug_targets) {
    # Get the effect of the drug on this target.
    target_edited = drug_target %>% regexPipes::gsub("hsa\\:", "")
    fx_drug_on_target = ONeil_drug_target_data_KEGG %>% dplyr::filter(Drug==drug & Target==target_edited) %>% dplyr::select(Effect) %>% unlist()
    
    # For each drug target, get the TFs that are downstream of that target. 
    tfs = ONeil_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & Pathway %in% drug_pathways) %>% dplyr::select(TFentrez) %>% unlist() %>% as.character() %>% unique() # Pathway %in% drug_pathways ensures that only the downstream TFs in the pathways associated with that drug are chosen.
    
    # For each TF, get the downstream transcriptional targets from ONeil_drug_target_txnal_target_data_KEGG_TRRUST.
    for(tf in tfs) {
      txn_targets = ONeil_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & Pathway %in% drug_pathways & TFentrez==tf) %>% dplyr::select(TranscriptionalTarget) %>% unlist() %>% as.character() %>% unique() # Pathway %in% drug_pathways ensures that only the downstream txnal targets in the pathways associated with that drug are chosen.
    
      # For each downstream transcriptional target, calculate the final effect. 
      # Use ONeil_drug_target_downstream_node_data_KEGG.
      for(txn_target in txn_targets) {
        print(paste0("Calculating effect of drug ", drug, " on target ", txn_target, "."))
        # Final effect = effect of drug on target (fx_drug_on_target, already calculated in outer loop) * effect of drug target on TF (from ONeil_drug_target_downstream_node_data_KEGG) (fx_drug_target_on_tf) * effect of TF on transcriptional target (from ONeil_drug_target_txnal_target_data_KEGG_TRRUST) (fx_tf_on_txn_target).
        fx_drug_target_on_tf = ONeil_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Target == drug_target & DownstreamNodes == tf & Pathway %in% drug_pathways) %>% dplyr::select(Effects) %>% unlist()
        fx_tf_on_txn_target = ONeil_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & TFentrez==tf & TranscriptionalTarget == txn_target & Pathway %in% drug_pathways) %>% dplyr::select(Effect) %>% unlist()
        final_effect = prod(fx_drug_on_target, fx_drug_target_on_tf, fx_tf_on_txn_target)
        
        ONeil_drug_target_data_TRRUST = rbind(ONeil_drug_target_data_TRRUST, data.frame(
          Drug = drug,
          Target = txn_target,
          Effect = final_effect,
          stringsAsFactors = F
          ))
        }
    }
  }
}

# Direct targets. 
colnames(ONeil_drug_target_data_TRRUST)[3] = "Effect"
hs = org.Hs.eg.db
keys = unique(ONeil_drug_target_data_KEGG$Target) %>% as.character()
x = AnnotationDbi::select(hs, 
           keys = keys,
           columns = c("SYMBOL", "ENTREZID"),
           keytype = "ENTREZID") %>% .[complete.cases(.),] %>% distinct()
for(drug in unique(ONeil_drug_target_data_KEGG$Drug)) {
  # For each drug, get its corresponding targets and effects from ONeil_drug_target_data_KEGG. 
  drug_targets = ONeil_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist()
  final_effects = ONeil_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Effect) %>% unlist()
  
  # Convert to gene symbol.
  #keggGet(kegg_drug_id) %>% .[[1]] %>% .$NAME %>% str_split(",") %>% .[[1]] %>% .[1]
  a = x$ENTREZID
  b = x$SYMBOL
  target_ids = b[match(drug_targets, a)]
  # Alternative: 
  #target_ids = c()
  #for(target in unique(ONeil_drug_target_data_KEGG$Target)) {
  #  print(paste0("Getting gene ID for target ", target, "."))
  #  target_ids = c(target_ids, keggGet(paste0("hsa:",target)) %>% .[[1]] %>% .$NAME %>% str_split(",") %>% .[[1]] %>% .[1])
  #}
  
  # Add to ONeil_drug_target_data_TRRUST. 
  ONeil_drug_target_data_TRRUST = rbind(ONeil_drug_target_data_TRRUST, data.frame(
          Drug = rep(drug, length(final_effects)),
          Target = target_ids,
          Effect = final_effects,
          stringsAsFactors = F
          ))
}

# Keep only unique rows.
ONeil_drug_target_data_TRRUST = ONeil_drug_target_data_TRRUST %>% distinct()

# Split the dataframe into a list, to match the CTD drug-target-data format and the format that most of the calcNetworkScores() functions use. 
ONeil_drug_target_data_TRRUST = split(ONeil_drug_target_data_TRRUST , f = ONeil_drug_target_data_TRRUST$Drug)

# Remove all entries in the list whose tables have 0 rows. (28 June 2021.)
for(entry in names(ONeil_drug_target_data_TRRUST)) {
  if(nrow(ONeil_drug_target_data_TRRUST[[entry]]) < 1) {
    ONeil_drug_target_data_TRRUST[[entry]] = NULL
  } 
}

# Save.
ONeil_drug_target_data_TRRUST_filename = filename_generator(data_dir, data_source = "ONeil", data_type = "Drugs", data_set = "TRRUST", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(ONeil_drug_target_data_TRRUST, ONeil_drug_target_data_TRRUST_filename)
#write.table(ONeil_drug_target_data_TRRUST, paste0(data_dir, "Processed_data/ONeil/ONeil_kegg_drug_final_effects.csv"), sep = ",", row.names = F)
```

## Expression data
### Normalization
```{r}
# Load GDSC cell-line metadata file.
CCLE_cell_lines_metadata_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "CCLE",
  data_type = "Metadata",
  processing_stage = "Raw"
), "E-MTAB-3610.sdrf.csv")
CCLE_cell_lines = read.csv(CCLE_cell_lines_metadata_filename)
# Read in the GSE metadata file. 
GSE_metadata_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "GEO",
  data_type = "Metadata",
  processing_stage = "Processed"
), "GEO_GSE_metadata.csv")
GSE_metadata = read.csv(GSE_metadata_filename)
# Standardize GDSC cell-line names (all caps, no punctuation.)
CCLE_cell_lines$Characteristics.cell.line. = toupper(base::gsub("[[:punct:]]|[[:space:]]", "", CCLE_cell_lines$Characteristics.cell.line.))

# Set the annotation variables.
GSE = "GDSC"
GPL = as.character(GSE_metadata[GSE_metadata$GSE==GSE,"AnnotationDB"])
annotation = as.character(GSE_metadata[GSE_metadata$GSE==GSE,"Annotation"])

ONeil_cell_line_names_dictionary_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "ONeil",
  data_type = "Metadata",
  processing_stage = "Processed"
), "ONeil_cell_line_names_dictionary.csv")
ONeil_cell_line_names_dictionary = read.csv(ONeil_cell_line_names_dictionary_filename, stringsAsFactors = F)
ONeil_cell_lines = ONeil_cell_line_names_dictionary %>% 
  dplyr::filter(Keep == "Y") %>%
  dplyr::select(Corrected) %>%
  unlist

# For each cell line in cell_viability, find corresponding .cel file using CCLE_cell_lines. 
# Then find the folder that .cel file is in. 
tmp_dir_name = "outputDirectory"
tmp_dir_path = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "CCLE",
  data_type = "Expression",
  processing_stage = "Raw"
), tmp_dir_name)
unlink(tmp_dir_path) # Remove all the files in the temporary directory.   
if(!file.exists(tmp_dir_path)){
    dir.create(tmp_dir_path)
} 
  
raw_files = list.files(path = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "CCLE",
  data_type = "Expression",
  processing_stage = "Raw"
)), all.files = FALSE,
           full.names = T, recursive = T,
           ignore.case = T, include.dirs = T)
cel_files = c()
for(cell_line in ONeil_cell_lines) {
  # Get the .cel file. 
  cel_file_name = as.character(CCLE_cell_lines[(CCLE_cell_lines$Factor.Value.cell_line.==cell_line | CCLE_cell_lines$Characteristics.cell.line.==cell_line),"Array.Data.File"])
  cel_files = c(cel_files, cel_file_name) # We will use this for replacing the cel file names with the cell-line names later. 
  
  # Get the full path to the .cel file. 
  cel_file_path = raw_files[base::grep(cel_file_name, raw_files)] # There should only be one match. ...
  
  # Copy that file to the temporary directory. 
  file.copy(cel_file_path, tmp_dir_path)
}

# Process the raw files using YuGene.
exprs_bgcorrected = processAffy(tmp_dir_path, is_GSE = F) # Perform background correction using Affy. 
exprs_log2 = log2transform(exprs_bgcorrected) # Perform log2 transformation. 
exprs_YuGene = YuGene(exprs_log2) # Perform YuGene normalization.
exprs_YuGene = exprs_YuGene[1:nrow(exprs_YuGene),1:ncol(exprs_YuGene),drop=F] # This step is needed because apparently YuGene() returns a 'YuGene' object, not a matrix, and using colnames() does something funky

# Rename the columns (cel files -> cell lines).
# Replace a with b. 
a = cel_files
b = ONeil_cell_lines
names(b) = a
colnames(exprs_YuGene) =  b[match(colnames(exprs_YuGene), a)]
sum(is.na(unique(colnames(exprs_YuGene))))

# Remove the temporary directory. 
system(paste0("rm -r ", tmp_dir_path))

# Save to an RDS file. (It won't be an eset yet.)
GSE_temp = "CCLE_ONeil_cell_lines"
exprs_YuGene_filename = filename_generator(data_dir = data_dir, data_source = "CCLE", data_type = "Expression", extension = ".rds", sample = "ONeil", processing_stage = "intermed_1", processing = preprocessing_type, gene_identifier = id_type, full_path = T)
saveRDS(exprs_YuGene, exprs_YuGene_filename)

# We don't need to remove the suffixes since we will be converting the probeset/probes to ENTREZ IDs ourselves, and the databases (hgu133plus2.db etc.) have the full probeset/probe names including the suffixes.
# We do have to remove the AFFX probesets, though.
exprs_YuGene = exprs_YuGene[!base::grepl("AFFX", rownames(exprs_YuGene)),,drop=F]

# Annotate the probes.
if(GSE %in% c("GSE39345")) {
      exprs_annotated = annotateLumi(GSE, exprs_YuGene)
} else {
      exprs_annotated = annotateAffy(GSE, exprs_YuGene, GPL, annotation)
}

# Set the expression matrix of the eset_ONeil to be exprs. 
# For this one, since we're not just subsetting, we're creating an entirely new matrix, we will have to ... rebuild the eset_ONeil. 囧rz
pData = data.frame(CellLine=colnames(exprs_annotated))
rownames(pData) = colnames(exprs_annotated)
experimentData = new("MIAME",
                     name="",
                     lab="",
                     contact="",
                     title="",
                     abstract="",
                     url="")
eset_ONeil = ExpressionSet(assayData=exprs_annotated, phenoData=as(pData, "AnnotatedDataFrame"), experimentData=experimentData, annotation=annotation)

# Save eset_ONeil.
eset_ONeil_filename = filename_generator(data_dir = data_dir, data_source = "CCLE", data_type = "Esets", extension = ".rds", sample = "ONeil", processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T)
saveRDS(eset_ONeil, eset_ONeil_filename)

exprs_ONeil_filename = filename_generator(data_dir = data_dir, data_source = "ONeil", data_type = "Expression", extension = ".rds", processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T)
exprs_ONeil = exprs(eset_ONeil)
saveRDS(exprs_ONeil, exprs_ONeil_filename)
```

### Differential expression
```{r}
# Load the mapping file.
ONeil_cancer_types = read.csv(paste0(folder_generator(data_dir, data_source = "ONeil", data_type = "Metadata", processing_stage = "Processed"), "ONeil_cancer_types.csv"))

exprs_ONeil_filename = filename_generator(data_dir = data_dir, data_source = "ONeil", data_type = "Expression", extension = ".rds", processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, full_path = T)
exprs_ONeil = readRDS(exprs_ONeil_filename)
  
# Load deg_list if it exists. Otherwise, initiate it. 
deg_list_filename = filename_generator(data_dir = data_dir, data_source = "ONeil", data_type = "Expression", data_subtype = "DEG_list", extension = ".rds", processing_stage = "Processed", processing = "YuGene", gene_identifier = "HUGO", DE_criterion = "all_genes", full_path = T)
if(file.exists(deg_list_filename)) {
  deg_list = readRDS(deg_list_filename)
} else {
  deg_list = list()
}

# Loop over every sample and identify the differentially expressed genes. 
deg_list_names = c()
#system.time({
for(GSM in unique(colnames(exprs_ONeil))) {
  print(paste0("Calculating the differentially expressed genes for sample ", GSM, "."))
  GSM_tissue_type = as.character(ONeil_cancer_types[ONeil_cancer_types$CellLine==GSM,"TissueType"][1])
  
  # Load the appropriate processed normal tissue. 
  # Check if the file exists. If it does, load it. If it doesn't, create it.
  normal_samples_filename = paste0(folder_generator(data_dir = data_dir, data_source = "GTEx", data_type = "Expression", processing_stage = "Processed"), "GTEx_normal_samples_processed_", GSM_tissue_type, ".rds") #filename_generator(data_dir = data_dir, data_source = "GTEx", data_type = "Expression", sample = GSM_tissue_type, extension = ".rds", processing_stage = "Processed", processing = "YuGene", gene_identifier = "HUGO", additional_info = "normal", full_path = T)
  if(file.exists(normal_samples_filename)) {
    normal_samples = readRDS(normal_samples_filename)
    deg_list_names = c(deg_list_names, GSM)
  } else {
    print(paste0("Error: the cancer ", GSM_tissue_type, " does not have associated normal tissue. Skipping this cancer."))
    next
  } 
  
  # Check if this sample is already in deg_list. 
  if(GSM %in% names(deg_list)) {
    print(paste0("Sample ", GSM, " is already in deg_list. Skipping this one."))
    next
  }
  
  # Load the expression matrix of the cell-line sample.
  patient_sample = exprs_ONeil[,colnames(exprs_ONeil)==GSM,drop=F]
  # Load the appropriate processed normal tissue. 
  normal_samples2 = t(normal_samples) # Transposing because GTEx_normal_samples_processed.rds contains the expression matrices with rows as samples and columns as genes. 
    
  ######################################
  ## 1. DATA PREPARATION AND CLEANING ##
  ######################################
  # Make sure the genes are the same across both the patient samples and normal tissue. 
  common_genes = intersect(rownames(normal_samples2), rownames(patient_sample))
  normal_samples2 = normal_samples2[rownames(normal_samples2) %in% common_genes,]
  patient_sample = patient_sample[rownames(patient_sample) %in% common_genes,,drop=F]
  normal_samples2 = normal_samples2[order(rownames(normal_samples2)),]
  patient_sample = patient_sample[order(rownames(patient_sample)),,drop=F]
  identical(rownames(normal_samples2), rownames(patient_sample))
  
  # I'm pretty sure we don't need to log2 transform, since log2 transformation is monotonic, and we're using rank-based methods. ... But let's leave this in here anyway in case we need to do so later.  
  #normal_samples_log2 = log2transform(normal_samples2) # Normal tissue.
  #patient_log2 = log2transform(patient_sample) # Patient samples. 
  
  # Harmonize patient samples and normal tissue. 
  # https://link.springer.com/protocol/10.1007%2F978-1-0716-0138-9_15
  # Visualize results. 
  
  # Normalize both patient samples and normal tissue.
  # https://link.springer.com/protocol/10.1007%2F978-1-0716-0138-9_15
  # They recommend quantile normalization for microarray data, but maybe log2-transform for both the patient sample and the normal tissue is OK? Check that Bolstad paper they cite.
  # ... Scratch that. Let's just not normalize outside the harmonization for now. 

  ##############################################
  ## 2. DIFFERENTIAL GENE EXPRESSION ANALYSIS ##
  ##############################################
  # For each gene, get the changes in rank between normal and tumor. 
  tumor_rank = patient_sample[order(patient_sample[,1], decreasing = T),1,drop=F]
  tumor_rank = cbind(tumor_rank, 1:length(tumor_rank))
  tumor_rank = tumor_rank[order(rownames(tumor_rank)),]
  
  normal_avg = as.matrix(future_apply(normal_samples2, 1, mean)) # Because we have more than one normal sample, get the rank of the average expression of the gene across all the samples.
  normal_rank = normal_samples2[order(normal_avg[,1], decreasing = T),1,drop=F]
  normal_rank = cbind(normal_rank, 1:length(normal_rank))
  normal_rank = normal_rank[order(rownames(normal_rank)),]
  
  identical(rownames(normal_rank), rownames(tumor_rank))
  rank_dif = as.matrix(tumor_rank[,2] - normal_rank[,2])
  rownames(rank_dif) = rownames(normal_rank) # rank_dif is now a data frame with the ranks of each gene. 
  
  # Select DEGs as the genes with rank differences >= 2SDs +/- the mean. 
  if(deg_type=="All") {
    deg_names = rownames(rank_dif)
  } else {
    lower_bound = mean(rank_dif) - deg_cutoff*sd(rank_dif)
    upper_bound = mean(rank_dif) + deg_cutoff*sd(rank_dif)
    upreg_degs = rownames(rank_dif[rank_dif[,1] > upper_bound,,drop=F])
    downreg_degs = rownames(rank_dif[rank_dif[,1] < lower_bound,,drop=F])
    deg_names = c(upreg_degs, downreg_degs)
  }
  
  # Create the table of differentially expressed genes. 
  degs = rank_dif[rownames(rank_dif) %in% deg_names,,drop=F]
  
  # Create the table of intensities.
  intensities = patient_sample[rownames(patient_sample) %in% deg_names,,drop=F]
  identical(rownames(intensities), rownames(degs)) # These are the two tables we'll be adding to deg_list[[sample]], so make sure they match. 
    
  # Add the table of differentially expressed genes to the list. 
  deg_list[[GSM]][["DEGs"]] = degs
  deg_list[[GSM]][["Intensity"]] = intensities
  
  # Remove all the samples expression matrices and clean up the memory. 
  rm(patient_sample, normal_samples2)
  gc()
  
}
#})
names(deg_list) = deg_list_names

# Save the list of DEGs.
saveRDS(deg_list, deg_list_filename)
```

### Network construction
#### All genes
```{r}
deg_type = "All"
if(deg_type == "All")  {
  all_genes = "all_genes"
} else if(deg_type == "SD") {
  all_genes = paste0(deg_cutoff, "SD")
} else {
  all_genes = paste0(deg_type)
}

# Load the list of DEG genes for each patient sample if it is not loaded already. 
deg_list_filename = filename_generator(data_dir = data_dir, data_source = "ONeil", data_type = "Expression", data_subtype = "DEG_list", extension = ".rds", processing_stage = "Processed", processing = preprocessing_method, gene_identifier = id_type, DE_criterion = all_genes, full_path = T)
deg_list = readRDS(deg_list_filename)

# https://www.biostars.org/p/190137/#222651
# Instantiate STRINGdb reference class. We will set a very stringent threshold (default 400) and of course choose humans as our species. Do it outside the for() loop so we don't have to instantiate it every time. 
string_db = STRINGdb$new(version="10", species=9606, score_threshold=400, input_directory=folder_generator(
  data_dir = data_dir,
  data_source = "STRING-DB",
  data_type = "Network",
  processing_stage = "Raw"
))
#system.time({
for(GSM in names(deg_list)) {
  network_filename = filename_generator(data_dir = data_dir, data_source = "ONeil", data_type = "Expression", data_subtype = "disease_network", extension = ".rds", data_set = GSE, sample = GSM, processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, DE_criterion = "all_genes", full_path = T)
  if(file.exists(network_filename)) next
  
  # Set up a list to hold the network, the mapping, and the hits. 
  network_list = list()
  
  # Differential gene expression data.
  de_genes = as.data.frame(deg_list[[GSM]][["DEGs"]])
  de_genes$GeneSymbol = rownames(de_genes)
  colnames(de_genes)[1] = "RankChange"
  
  # Map gene names from the table of differentially expressed genes to STRING identifiers. 
  #system.time({
  mapped = string_db$map(de_genes, "GeneSymbol", removeUnmappedRows=TRUE)
  #}) # Time: user system elapsed 7.412   0.248   7.978 
  hits = mapped$STRING_id # These are the hits. To select the top n hits, simply subset using [1:n]. Because we start with ~150 genes, which should be enough to make a decent PPI network, we will just use all of these genes without subsetting. 
    # Plot the network, showing the number of proteins (genes), the number of interactions, and the p-value (probability that we would get, by chance, as many interactions as we did in   this network.)
    # string_db$plot_network(hits)

  # As of 05/17/2021, we no longer have to create a subnetwork. ... I think.
  # Create an iGraph network object. This is the disease network, which we can now run iGraph functions on.
  #system.time({
  #network = string_db$get_subnetwork(hits) # user system elapsed 0.017   0.066   0.192
  #})
  # Save network to list.
  #network_list[["Network"]] = network 
  network_list[["Map"]] = mapped
  network_list[["Hits"]] = hits
  
  # New addition 01/29/2021; need the intensity for the WINTHER score.
  # Add intensity.
  intensity = as.data.frame(deg_list[[GSM]][["Intensity"]])
  intensity = intensity[rownames(intensity) %in% mapped$GeneSymbol,,drop=F]
  colnames(intensity) = "Intensity"
  network_list[["Intensity"]] = intensity
  
  # Save the list to RDS.
  saveRDS(network_list, network_filename)
  
  # Clean up.
  rm(network_list)
  gc()
}
#})
```

#### Rank-difference cutoff
```{r}
deg_type = "SD"
if(deg_type == "All")  {
  all_genes = "all_genes"
} else if(deg_type == "SD") {
  all_genes = paste0(deg_cutoff, "SD")
} else {
  all_genes = paste0(deg_type)
}

# Load the list of DEG genes for each patient sample if it is not loaded already. 
deg_list_filename = filename_generator(data_dir = data_dir, data_source = "ONeil", data_type = "Expression", data_subtype = "DEG_list", extension = ".rds", processing_stage = "Processed", processing = preprocessing_method, gene_identifier = id_type, DE_criterion = "all_genes", full_path = T)
deg_list = readRDS(deg_list_filename)

# https://www.biostars.org/p/190137/#222651
# Instantiate STRINGdb reference class. We will set a very stringent threshold (default 400) and of course choose humans as our species. Do it outside the for() loop so we don't have to instantiate it every time. 
string_db = STRINGdb$new(version="10", species=9606, score_threshold=400, input_directory=folder_generator(
  data_dir = data_dir,
  data_source = "STRING-DB",
  data_type = "Network",
  processing_stage = "Raw"
))
#system.time({
for(GSM in names(deg_list)) {
  network_filename = filename_generator(data_dir = data_dir, data_source = "ONeil", data_type = "Expression", data_subtype = "disease-network", extension = ".rds", data_set = GSE, sample = GSM, processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, DE_criterion = all_genes, full_path = F)
  if(file.exists(network_filename)) next
  
  # Set up a list to hold the network, the mapping, and the hits. 
  network_list = list()
  
  # Differential gene expression data.
  de_genes = as.data.frame(deg_list[[GSM]][["DEGs"]])
  de_genes$GeneSymbol = rownames(de_genes)
  colnames(de_genes)[1] = "RankChange"
  
  # Map gene names from the table of differentially expressed genes to STRING identifiers. 
  #system.time({
  mapped = string_db$map(de_genes, "GeneSymbol", removeUnmappedRows=TRUE)
  #}) # Time: user system elapsed 7.412   0.248   7.978 
  hits = mapped$STRING_id # These are the hits. To select the top n hits, simply subset using [1:n]. Because we start with ~150 genes, which should be enough to make a decent PPI network, we will just use all of these genes without subsetting. 
    # Plot the network, showing the number of proteins (genes), the number of interactions, and the p-value (probability that we would get, by chance, as many interactions as we did in   this network.)
    # string_db$plot_network(hits)

  # As of 05/17/2021, we no longer have to create a subnetwork. ... I think.
  # Create an iGraph network object. This is the disease network, which we can now run iGraph functions on.
  #system.time({
  #network = string_db$get_subnetwork(hits) # user system elapsed 0.017   0.066   0.192
  #})
  # Save network to list.
  #network_list[["Network"]] = network 
  network_list[["Map"]] = mapped
  network_list[["Hits"]] = hits
  
  # New addition 01/29/2021; need the intensity for the WINTHER score.
  # Add intensity.
  intensity = as.data.frame(deg_list[[GSM]][["Intensity"]])
  intensity = intensity[rownames(intensity) %in% mapped$GeneSymbol,,drop=F]
  colnames(intensity) = "Intensity"
  network_list[["Intensity"]] = intensity
  
  # Save the list to RDS.
  saveRDS(network_list, network_filename)
  
  # Clean up.
  rm(network_list)
  gc()
}
#})
```

# TCGA
## pData
### Biotab file cleanup
```{r}
# Move all the TCGA Biotab files to the Legacy_data folder.
GDC_download_dir = folder_generator(data_dir, data_source = "TCGA", data_type = "pData", processing_stage = "Raw", additional_paths = "Legacy_data/gdc_download_20200926_085115.921269/")
legacy_data_dir = folder_generator(data_dir, data_source = "TCGA", data_type = "pData", processing_stage = "Raw", additional_paths = "Legacy_data/")
gdc_folders = list.dirs(path = GDC_download_dir, full.names = TRUE, recursive = TRUE) 
gdc_folders = gdc_folders[2:length(gdc_folders)]

for(folder in gdc_folders) {
  # Move/copy the text file NOT named "annotations.txt" up to /Legacy_data/.
  file = list.files(folder) %>% regexPipes::grep("annotations\\.txt", value = T, invert = T)
  file.copy(paste0(folder, "/", file), legacy_data_dir)
}

# Count the number of text files. There should be 437.
list.files(legacy_data_dir) %>% regexPipes::grepl("\\.txt") %>% sum()

# Rename the files.
filenames = list.files(legacy_data_dir) %>% regexPipes::grep("\\.txt", value = T)
for(filename in filenames) {
  new_name = base::gsub("^.+\\.[[:alpha:]]+_", "", filename)
  file.rename(paste0(legacy_data_dir, filename), paste0(legacy_data_dir, new_name))
}

# Count the number of cancers with clinical drug data.
list.files(legacy_data_dir) %>% regexPipes::grepl("clinical_drug_") %>% sum()

# Get all the cancers with clinical drug data.
cancers = list.files(legacy_data_dir) %>% regexPipes::grep("clinical_drug_", value = T) %>% regexPipes::gsub("clinical_drug_", "") %>% regexPipes::gsub("\\.[[:alpha:]]+", "") %>% unique()

```

### Creation of pData table and removal of non-adjuvant treatments
Remove the palliative/progression/recurrence treatments. If the therapy_regimen/regimen_indication is unknown, check if there are multiple pharmaceutical_tx_started_days_to/days_to_drug_therapy_start, and take all the drugs with the lowest number of days (we are assuming that this is the earliest and therefore adjuvant treatment, and anything later would be for progressive or recurrent disease. Indeed, the LUAD clinical_drug file bears this out.)
```{r}
# T_T
clinical_drug_files_with_technical_issues = c("ov")

# Get all the cancers with clinical drug data.
legacy_data_dir = folder_generator(data_dir, data_source = "TCGA", data_type = "pData", processing_stage = "Raw", additional_paths = "Legacy_data/")
cancers = list.files(legacy_data_dir) %>% regexPipes::grep("clinical_drug_", value = T) %>% regexPipes::gsub("clinical_drug_", "") %>% regexPipes::gsub("\\.[[:alpha:]]+", "") %>% unique()

# Check which cancers do not have the "days_to_drug_therapy_start" or "pharmaceutical_tx_started_days_to" column, and which cancers do not have a regimen indicator.
cancers_no_tx_start_indicator = c()
cancers_no_regimen_indicator = c()
cancers_no_response_indicator = c()
for(cancer in cancers) {
  if(cancer %in% clinical_drug_files_with_technical_issues) {
    drug_filename = paste0("clinical_drug_", cancer, ".csv")
    clinical_drug = read.csv(paste0(legacy_data_dir, drug_filename), header = T, stringsAsFactors = F)
  } else {
    drug_filename = paste0("clinical_drug_", cancer, ".txt")
    clinical_drug = read.table(paste0(legacy_data_dir, drug_filename), sep = "\t", header = T, stringsAsFactors = F)
  }
  
  # Check if the "days_to_drug_therapy_start" or "pharmaceutical_tx_started_days_to" column is present. 
  if("days_to_drug_therapy_start" %in% colnames(clinical_drug) | "pharmaceutical_tx_started_days_to" %in% colnames(clinical_drug)) {
    # Do nothing.
  } else {
    print(paste0("Cancer ", cancer, " has no tx start indicator."))
    cancers_no_tx_start_indicator = c(cancers_no_tx_start_indicator, cancer)
  }
  
  # Check if the "therapy_regimen" or "regimen_indication" column is present.
  if("therapy_regimen" %in% colnames(clinical_drug) | "regimen_indication" %in% colnames(clinical_drug)) {
    # Do nothing.
  } else {
    print(paste0("Cancer ", cancer, " has no regimen indicator."))
    cancers_no_regimen_indicator = c(cancers_no_regimen_indicator, cancer)
  }
  
  # Check if the response column is present.
  if("treatment_best_response" %in% colnames(clinical_drug) | "measure_of_response" %in% colnames(clinical_drug)) {
    # Do nothing.
  } else {
    print(paste0("Cancer ", cancer, " has no response indicator."))
    cancers_no_response_indicator = c(cancers_no_response_indicator, cancer)
  }
}

# Perform filtering. 
pData = data.frame(GSE = character(),
                              GSM = character(),
                              Drugs = character(),
                              Response = character())
for(cancer in cancers) {
  if(cancer %in% clinical_drug_files_with_technical_issues) {
    drug_filename = paste0("clinical_drug_", cancer, ".csv")
    clinical_drug = read.csv(paste0(legacy_data_dir, drug_filename), header = T, stringsAsFactors = F)
  } else {
    drug_filename = paste0("clinical_drug_", cancer, ".txt")
    clinical_drug = read.table(paste0(legacy_data_dir, drug_filename), sep = "\t", header = T, stringsAsFactors = F)
  }
  
  # Check if the "days_to_drug_therapy_start" or "pharmaceutical_tx_started_days_to" column is present. If neither is, then skip this cancer.
  if("days_to_drug_therapy_start" %in% colnames(clinical_drug)) {
    # Do nothing. 
  } else if("pharmaceutical_tx_started_days_to" %in% colnames(clinical_drug)) {
    # Rename the column.
    clinical_drug = dplyr::rename(clinical_drug, days_to_drug_therapy_start = pharmaceutical_tx_started_days_to)
  } else {
    print(paste0("There is no indicator of when a given therapy was started. Skipping cancer ", cancer, "."))
    next
  }
  
  # Remove any rows in which there is no BCR patient barcode. 
  clinical_drug = clinical_drug %>% dplyr::filter(base::grepl("TCGA-", clinical_drug$bcr_patient_barcode))
  
  # Check if the "therapy_regimen" or "regimen_indication" column is present. If it is, then exclude only the entries corresponding to palliative, recurrent, or progressive treatment. 
  if("therapy_regimen" %in% colnames(clinical_drug)) {
    clinical_drug = clinical_drug %>% dplyr::filter((base::grepl("adjuvant", clinical_drug$therapy_regimen, ignore.case = T) | base::grepl("\\[", clinical_drug$therapy_regimen, ignore.case = T)))
  } else if("regimen_indication" %in% colnames(clinical_drug)) {
    clinical_drug = clinical_drug %>% dplyr::filter((base::grepl("adjuvant", clinical_drug$regimen_indication, ignore.case = T) | base::grepl("\\[", clinical_drug$regimen_indication, ignore.case = T)))
  }
  
  # For each patient, get the first set of drugs they were treated with. This will be the drugs corresponding to the lowest "days_to_drug_therapy_start" or "pharmaceutical_tx_started_days_to". 
  for(patient in unique(clinical_drug$bcr_patient_barcode)) {
    # Get the days corresponding to the first treatment. 
    # The last part of the code numericizes everything, then removes any NAs (entries that have alphabeti al parts.) If there is nothing left in days_first_tx after removal of NAs, then there are no numeric entries. In that case, we will just use all the drugs.
    # Also note that if there are entries with two drugs listed, one with a numerical entry for days_first_tx and one without, then it will discard the one without, even though they might both be part of the same regimen. Hopefully this situation doesn't come up. ... 
    days_first_tx = clinical_drug %>% dplyr::filter(bcr_patient_barcode==patient) %>% dplyr::select(matches("days_to_drug_therapy_start")) %>% unlist() %>% as.numeric() %>% .[is.finite(.)] %>% min()
    
    # Get the drugs corresponding to days_first_tx. 
    if(is.finite(days_first_tx)) {
     first_tx = clinical_drug %>% dplyr::filter(bcr_patient_barcode==patient & days_to_drug_therapy_start==days_first_tx) %>% dplyr::select(contains("drug_name")) %>% unlist()
      #first_tx = paste(first_tx, collapse=",")  
    } else {
      first_tx = clinical_drug %>% dplyr::filter(bcr_patient_barcode==patient) %>% dplyr::select(contains("drug_name")) %>% unlist()
      #first_tx = paste(first_tx, collapse=",")  
    }
    
    # Get the response. 
    if(cancer %in% cancers_no_response_indicator) {
      first_tx_response = NA
    } else {
      if(is.finite(days_first_tx)) {
        first_tx_response = clinical_drug %>% dplyr::filter(bcr_patient_barcode==patient & days_to_drug_therapy_start==days_first_tx) %>% dplyr::select(contains("_response")) %>% unlist() %>% .[1] # Why the period? https://stackoverflow.com/questions/44373284/subsetting-on-a-tibble-using-gives-object-not-found-error
      } else {
        first_tx_response = clinical_drug %>% dplyr::filter(bcr_patient_barcode==patient) %>% dplyr::select(contains("_response")) %>% unlist() %>% .[1]
      }
      
    }
    
    # Add to table.
    pData = rbind(pData, 
                           data.frame(GSE = cancer,
                                      GSM = patient,
                                      Drugs = first_tx,
                                      Response = first_tx_response))
  }
  
}

# Save intermediate pData.
saveRDS(pData, pData_intermed_TCGA_1_filename)
rm(pData)
gc()
```

### Removal of patients treated with radiation or with unknown treatment type
Remove all patients treated with radiation. Since we're only interested in adjuvant treatment (and not in recurrence, progression, or palliative treatment), we will exclude any patients treated with adjuvant radiation or for whom it is unknown whether their treatment was adjuvant, recurrence, or progression.
```{r}
# Load the pData from the last step.
pData = readRDS(pData_intermed_TCGA_1_filename)

# Get all the cancers with clinical drug data.
cancers = list.files(legacy_data_dir) %>% regexPipes::grep("clinical_drug_", value = T) %>% regexPipes::gsub("clinical_drug_", "") %>% regexPipes::gsub("\\.[[:alpha:]]+", "") %>% unique()

rad_ids = list()
for(cancer in cancers) {
    rad_filename = paste0("clinical_radiation_", cancer, ".txt")
    clinical_radiation = read.table(paste0(legacy_data_dir, rad_filename), sep = "\t", header = T, stringsAsFactors = F)
  
  # Remove any rows in which there is no BCR patient barcode. 
  clinical_radiation = clinical_radiation %>% dplyr::filter(base::grepl("TCGA-", clinical_radiation$bcr_patient_barcode))
  
  # Check if the "therapy_regimen" or "regimen_indication" column is present. If it is, then exclude only the patients treated with adjuvant radiation or for whom the therapy regimen is unknown. Otherwise, exclude all patients treated with radiation. 
  if("therapy_regimen" %in% colnames(clinical_radiation)) {
    clinical_radiation = clinical_radiation %>% dplyr::filter((base::grepl("adjuvant", clinical_radiation$therapy_regimen, ignore.case = T) | base::grepl("\\[", clinical_radiation$therapy_regimen, ignore.case = T)))
  } else if("regimen_indication" %in% colnames(clinical_radiation)) {
    clinical_radiation = clinical_radiation %>% dplyr::filter((base::grepl("adjuvant", clinical_radiation$regimen_indication, ignore.case = T) | base::grepl("\\[", clinical_radiation$regimen_indication, ignore.case = T)))
  }
  
  rad_ids[[cancer]] = unique(clinical_radiation$bcr_patient_barcode)
  
}

rad_ids # The IDs of patients to exclude. 

pData = pData %>% dplyr::filter(!(GSM %in% unlist(rad_ids)))

# Save intermediate pData.
saveRDS(pData, pData_intermed_TCGA_2_filename)
rm(pData)
gc()
```

### Addition of survival data
```{r}
# Load the pData from the last step.
pData = readRDS(pData_intermed_TCGA_2_filename)

survival_data = read.csv(paste0(TCGA_raw_data_dir, "TCGA_survival_data_Liu_et_al.csv"))[,-1]

# https://stackoverflow.com/a/11977256
survival_data_sub = survival_data %>% dplyr::filter(bcr_patient_barcode %in% pData$GSM) %>% #.[match(pData$GSM, survival_data$bcr_patient_barcode),] %>%
  dplyr::select(c(bcr_patient_barcode, PFI.1, PFI.time.1))
survival_data_sub = dplyr::rename(survival_data_sub, GSM = bcr_patient_barcode)

pData = merge(pData, survival_data_sub, by = "GSM", sort = F)
setdiff(survival_data_sub$GSM, unique(pData$GSM)) # There are no GSMs in survival_data_sub that are not present in pData, so we do not need to specify left outer join, right outer join, etc. https://www.dummies.com/programming/r/how-to-use-the-merge-function-with-data-sets-in-r/

# Save intermediate pData.
saveRDS(pData, pData_intermed_TCGA_3_filename)
rm(pData)
gc()
```

### Addition of stage data
Add stage data. 
```{r}
# Load the pData from the last step.
pData = readRDS(pData_intermed_TCGA_3_filename)

stage_table = data.frame(
  GSM = character(),
  Stage = character(),
  StageType = character(),
  stringsAsFactors = F
)
for(cancer in cancers) {
  patient_filename = paste0("clinical_patient_", cancer, ".txt")
  clinical_patient = read.csv(paste0(legacy_data_dir, patient_filename), sep = "\t", header = T, stringsAsFactors = F)
  
  # Remove any rows in which there is no BCR patient barcode. 
  clinical_patient = clinical_patient %>% dplyr::filter(base::grepl("TCGA-", clinical_patient$bcr_patient_barcode))
  
  # Check what kind of staging the cancer has, if any. 
  has_pathologic_stage_column = F
  has_clinical_stage_column = F
  if("ajcc_pathologic_tumor_stage" %in% colnames(clinical_patient) | "pathologic_stage" %in% colnames(clinical_patient)) {
    has_pathologic_stage_column = T
    pathologic_stage = clinical_patient %>% dplyr::select(matches("ajcc_pathologic_tumor_stage") | matches("pathologic_stage")) %>% unlist() %>% as.character()
  } 
  if("ajcc_clinical_tumor_stage" %in% colnames(clinical_patient) | "clinical_stage" %in% colnames(clinical_patient))  {
    has_clinical_stage_column = T
    clinical_stage = clinical_patient %>% dplyr::select(matches("ajcc_clinical_tumor_stage") | matches("clinical_stage")) %>% unlist() %>% as.character()
  }
  
  if(has_pathologic_stage_column & has_clinical_stage_column) {
    # Check to see which one is populated (i.e. is not >50% "[Not Applicable]" or "[Not Available].")
    length_pathologic_stage_missing = pathologic_stage %>% .[.=="[Not Applicable]" | .=="[Not Available]"] %>% length()
    length_clinical_stage_missing = clinical_stage %>% .[.=="[Not Applicable]" | .=="[Not Available]"] %>% length()
    # Go with whichever one has fewer missing values.
    if(length_pathologic_stage_missing <= length_clinical_stage_missing) {
      stage_table_i = clinical_patient %>% dplyr::select(bcr_patient_barcode, matches("ajcc_pathologic_tumor_stage") | matches("pathologic_stage")) %>% dplyr::rename(GSM = bcr_patient_barcode, Stage = (matches("ajcc_pathologic_tumor_stage") | matches("pathologic_stage"))) %>% mutate(StageType = "Pathologic")
      stage_table = rbind(stage_table, stage_table_i)
    } else {
      stage_table_i = clinical_patient %>% dplyr::select(bcr_patient_barcode, matches("ajcc_clinical_tumor_stage") | matches("clinical_stage")) %>% dplyr::rename(GSM = bcr_patient_barcode, Stage = (matches("ajcc_clinical_tumor_stage") | matches("clinical_stage"))) %>% mutate(StageType = "Clinical")
      stage_table = rbind(stage_table, stage_table_i)
    }
    
  } else if(has_pathologic_stage_column & !has_clinical_stage_column) {
    stage_table_i = clinical_patient %>% dplyr::select(bcr_patient_barcode, matches("ajcc_pathologic_tumor_stage") | matches("pathologic_stage")) %>% dplyr::rename(GSM = bcr_patient_barcode, Stage = (matches("ajcc_pathologic_tumor_stage") | matches("pathologic_stage"))) %>% mutate(StageType = "Pathologic")
    stage_table = rbind(stage_table, stage_table_i)
  } else if(!has_pathologic_stage_column & has_clinical_stage_column) {
    stage_table_i = clinical_patient %>% dplyr::select(bcr_patient_barcode, matches("ajcc_clinical_tumor_stage") | matches("clinical_stage")) %>% dplyr::rename(GSM = bcr_patient_barcode, Stage = (matches("ajcc_clinical_tumor_stage") | matches("clinical_stage"))) %>% mutate(StageType = "Clinical")
    stage_table = rbind(stage_table, stage_table_i)
  } else {
    stage_table_i = clinical_patient %>% dplyr::select(bcr_patient_barcode) %>% dplyr::rename(GSM = bcr_patient_barcode) %>% mutate(Stage = NA, StageType = NA)
    stage_table = rbind(stage_table, stage_table_i)
  }
  
}

# Keep only the ones in pData. 
stage_table = stage_table %>% dplyr::filter(GSM %in% pData$GSM)
pData = merge(pData, stage_table, by = "GSM", sort = F)
setdiff(stage_table$GSM, unique(pData$GSM))

# Save intermediate pData.
saveRDS(pData, pData_intermed_TCGA_4_filename)
rm(pData)
gc()
```

### Cleanup of clinical covariates
Clean up the stage, response, PFI, and GSE variables.
```{r}
# Load the pData from the last step.
pData = readRDS(pData_intermed_TCGA_4_filename)

# Clean up Response variable by changing missing values to NAs.
pData$Response = pData$Response %>% regexPipes::gsub("\\[.+\\]", NA)

# Clean up Stage variable by changing missing values to NAs, removing A/B, 1/2 from the stage, changing "I/II NOS" to "II", and changing the variable to a factor.
pData$Stage = pData$Stage %>% regexPipes::gsub("\\[.+\\]", NA) %>% regexPipes::gsub("Stage X", NA) %>% regexPipes::gsub("[ABC][[:digit:]]*", "") %>% regexPipes::gsub("I/II NOS", "II") %>% as.factor()

# Clean up the PFI variables by changing to numeric.
# Don't worry about the non-numeric values; they will be coerced to NAs automatically. 
pData$PFI.1 = pData$PFI.1 %>% as.character() %>% as.numeric()
pData$PFI.time.1 = pData$PFI.time.1 %>% as.character() %>% as.numeric()

# Capitalize the cancer types.
pData$GSE = str_to_upper(pData$GSE)

# Remove cancer types for which we have no normal tissue. 
pData = pData %>% dplyr::filter(!(GSE %in% cancer_no_normal))

# Save intermediate pData.
saveRDS(pData, pData_intermed_TCGA_5_filename)
rm(pData)
gc()
```

### Addition of tissue type
```{r}
# Load the pData from the last step.
pData = readRDS(pData_intermed_TCGA_5_filename)

cancer_types = read.csv(paste0(TCGA_raw_data_dir, "TCGA_cancer_types.csv"), stringsAsFactors = F)

tissue_types = c()
for(i in 1:nrow(pData)) {
  tcga_cancer = pData[i,"GSE"]
  tissue_type = cancer_types %>% dplyr::filter(TCGACancer==tcga_cancer) %>% dplyr::select(TissueType) %>% unlist()
  tissue_types = c(tissue_types, tissue_type)
}

pData$TissueType = tissue_types

# Save intermediate pData.
saveRDS(pData, pData_intermed_TCGA_6_filename)
rm(pData)
gc()
```

### Standardization of drug names
Filter the drugs AFTER cleaning.
```{r}
# Load the pData from the last step.
pData = readRDS(pData_intermed_TCGA_6_filename)

drug_name_corrections = read.csv(paste0(TCGA_raw_data_dir, "TCGA_drug_name_corrections.csv"), stringsAsFactors = F)

# Correct names.
# https://stackoverflow.com/a/3905442
a = drug_name_corrections$OldName
b = drug_name_corrections$Correction
pData$Drugs = b[match(pData$Drugs, a)]

# Split along "+".
pData = pData %>% separate_rows(Drugs, sep = "[\\+]", convert = FALSE)

# Remove trailing/leading whitespace.
pData$Drugs = pData$Drugs %>% trimws()

all_drugs = pData$Drugs %>% unique() %>% sort()

pData_final_TCGA_filename = filename_generator(data_dir = data_dir, data_source = "TCGA", data_type = "pData", extension = ".rds", processing_stage = "processed", full_path = T)
saveRDS(pData, pData_final_TCGA_filename)

# Update 08/21/2021: rename columns to match those expected by calcNetworkScores.R
TCGA_pData = readRDS(pData_final_TCGA_filename)
TCGA_pData = TCGA_pData %>% dplyr::rename(Sample = GSM)
TCGA_pData$Dataset = "TCGA"
saveRDS(TCGA_pData, pData_final_TCGA_filename)

# Update 08/21/2021: summarize so that each row corresponds to only one sample, with all the drugs for that sample in one string.
# https://stackoverflow.com/a/43958163
# https://stackoverflow.com/a/44971876
TCGA_pData = readRDS(pData_final_TCGA_filename)
TCGA_pData = TCGA_pData %>% group_by(Sample) %>% dplyr::mutate(Drugs=paste(Drugs, collapse="_")) %>% dplyr::distinct() # The distinct() part is necessary because mutate() will have duplicate rows. 
saveRDS(TCGA_pData, pData_final_TCGA_filename)

# Update 08/21/2021: convert all drug names to lower-case.
TCGA_pData = readRDS(pData_final_TCGA_filename)
TCGA_pData$Drugs = TCGA_pData$Drugs %>% str_to_lower()
saveRDS(TCGA_pData, pData_final_TCGA_filename)
rm(pData)
gc()
```

## Drug data
### Creation of drug list
The drug list was manually created and consists of all the drugs that have either a DrugBank or KEGG ID or both.
```{r}
TCGA_drug_list = read.csv(filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids"), stringsAsFactors = F)
TCGA_drugs = TCGA_drug_list$drug_name %>% unique
# length(TCGA_drugs) == length(unique(TCGA_drugs))

# Save to file. 
write.table(TCGA_drugs, filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", extension = ".tsv", processing_stage = "Raw", additional_info = "names"), row.names = F, col.names = F, quote = F)
```

### CTD
#### Filtering
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Load the CTD data.
TCGA_drug_cgixns_CTD_raw = read.csv(paste0(folder_generator(data_dir, data_source = "TCGA", data_type = "Drugs", processing_stage = "Processed"), "TCGA_CTD_chem_cgixns_1634090448182.csv"))

# Filter drugs to include the following: 1) has data, 2) is human, 3) has no cotreatment stuff, 4) includes information on increasing/decreasing activity/expression (not just "affects.")
TCGA_drug_cgixns_CTD_filtered = TCGA_drug_cgixns_CTD_raw %>% dplyr::filter(!base::grepl("found", Input) & 
                                          OrganismID == "9606" &
                                          !base::grepl("reaction", InteractionActions) & 
                                          !base::grepl("response", InteractionActions) & 
                                          !base::grepl("cotreatment", InteractionActions) &
                                          (
                                            base::grepl("increases\\^activity", InteractionActions) |
                                              base::grepl("increases\\^expression", InteractionActions) |
                                              base::grepl("decreases\\^activity", InteractionActions) |
                                              base::grepl("decreases\\^expression", InteractionActions)
                                            )
                                        )

# Save the filtered data.
TCGA_drug_cgixns_CTD_filtered_filename = paste0(folder_generator(data_dir, data_source = "TCGA", data_type = "Drugs", processing_stage = "Processed"), "TCGA_CTD_chem_cgixns_1634090448182_filtered.rds")
saveRDS(TCGA_drug_cgixns_CTD_filtered, TCGA_drug_cgixns_CTD_filtered_filename)
```

#### Target extraction
```{r echo = FALSE, eval=TRUE, include=FALSE}
TCGA_drug_cgixns_CTD_filtered_filename = paste0(folder_generator(data_dir, data_source = "TCGA", data_type = "Drugs", processing_stage = "Processed"), "TCGA_CTD_chem_cgixns_1632082857803_filtered.rds")

# Naming the modified function "getTargets2," how creative. 
getTargets2 = function(drug) {
  # For drug "drug," get the targets. 
  print(paste0("Getting targets for drug ", drug, "."))
  
  # Create an empty table to be returned for drugs without entries.
  empty_table = data.frame(
    Drug = character(),
    Target = character(),
    Effect = character(),
    stringsAsFactors = F
  )
  
  # Load the chemical-gene interactions from CTD (saved as a CSV file in /Data/CTD/TCGA.)
  possibleError = tryCatch(
    {
      # TCGA_drug_cgixns_CTD_filtered should already be loaded in the global environment. 
      # Keep only the interactions for the drug "drug" and found in humans.
      regex = paste0("^", drug, "$")
      CTD_subset = TCGA_drug_cgixns_CTD_filtered[TCGA_drug_cgixns_CTD_filtered$OrganismID=="9606" & (TCGA_drug_cgixns_CTD_filtered$ChemicalName==drug | TCGA_drug_cgixns_CTD_filtered$Input==drug | base::grepl(regex, TCGA_drug_cgixns_CTD_filtered$Input, ignore.case = T) | base::grepl(regex, TCGA_drug_cgixns_CTD_filtered$ChemicalName, ignore.case = T)),,drop=F]
    }, error=function(cond) {
      message(paste0("For getTargets(), there was a problem retrieving the chemical-gene interactions for the drug ", drug, ":"))
      message(cond)
    }
  )
  
  if(inherits(possibleError, "error") | !exists("CTD_subset")) {
    print(paste0("For getTargets(), there was a problem retrieving the chemical-gene interactions for the drug ", drug, "."))
    return(empty_table)
  }
  
  else {
    if(nrow(CTD_subset) < 1) return(empty_table)
    
    # We want only the interactions that include "[chemical name] (and not an analog) ... results in decreased/increased action/expression of [X protein/mRNA]."
    # regex = paste0(drug, " (?!\\banalog\\b)(binds to and results in |results in(\\s| (de|in)creased [^\\s]+ of and results in ))(de|in)creased (activity|expression) of") # Yes, there should be no space between "(?!\\banalog\\b)" and "results."
    # Standardize the drug name. 
    drug = CTD_subset$ChemicalName
    drug = drug[complete.cases(drug)][1]
  
    regex1 = paste0(" (?!\\banalog\\b)") # This will be set to negative, because we do NOT want the analogs. Just the drug itself. 
    regex2 = "(the reaction \\[|susceptibility to|co-treated|modified form)" # This will be set to negative, because we do NOT want the other drug-chemical interactions that the drug in question affects OR direct gene effects affected by other drugs. Just the direct gene effects. We also don't want co-treatments (for right now.) Finally, we don't want the modified forms of proteins. 
    regex3 = "results in (de|in)creased (activity|expression) of" # This will be set to positive, because we want to make sure that this phrase is present. 
    regex4 = "\\[" # We do NOT want something like "Carboplatin results in increased activity of [NFKB1 protein binds to RELA protein]"
    # We will use the regexPipes library to do this. 
    interactions = CTD_subset$Interaction %>% regexPipes::grep(drug, fixed = T, value = T) %>% regexPipes::grep(regex1, perl = T, value = T) %>% regexPipes::grep(regex2, value = T, invert = T) %>% regexPipes::grep(regex3, value = T) %>% regexPipes::grep(regex4, value = T, invert = T)
    # CTD_subset = CTD_subset[grep(regex, CTD_subset$Interaction, perl = T),,drop=F]
    
    # Build a data frame to hold the targets and the direction the drug affects the target in.
    # We won't distinguish between mRNA and protein here. 
    # Populate the data frame with the targets.
    targets = future_lapply(interactions, FUN = extractTarget, drug = drug)
    targets = as.data.frame(do.call(rbind, targets), stringsAsFactors = F)
    if(nrow(targets) > 0) {
      colnames(targets) = c("Drug", "Target", "Effect")
      targets$Effect = as.integer(as.character(targets$Effect))
      
      # Remove duplicates
      targets = unique(targets)
    }
    
  rm(CTD_subset)
  
  return(targets)
  }
}

# Check the format of the data frames that calcNetworkScore() uses. 

# Get the vector of drugs.
# Update 08/16/2021: now including even the drugs without KEGG pathways.
drugs = read.csv(TCGA_drugs_filename, stringsAsFactors = F) %>% dplyr::filter(exclude != "Y") %>% dplyr::select(drug_name) %>% unlist() %>% unique() %>% str_to_lower()
# Replace "venotoclax" with "venetoclax."
drugs[drugs=="venotoclax"] = "venetoclax"

# Load the file. 
if(!exists("TCGA_drug_cgixns_CTD_filtered")) TCGA_drug_cgixns_CTD_filtered = readRDS(TCGA_drug_cgixns_CTD_filtered_filename)

# Get the targets.
TCGA_drug_target_data_CTD = future_lapply(drugs, FUN = getTargets2) # Returns a list. 
names(TCGA_drug_target_data_CTD) = drugs

# Rename the drugs in the tables and get the drugs that have entries.
drugs_with_CTD_entries = c()
for(drug in names(TCGA_drug_target_data_CTD)) {
  if(nrow(TCGA_drug_target_data_CTD[[drug]]) > 0) {
    TCGA_drug_target_data_CTD[[drug]]$Drug = drug
    drugs_with_CTD_entries = c(drugs_with_CTD_entries, drug)
  }
}
# Keep only the drugs with entries.
TCGA_drug_target_data_CTD = TCGA_drug_target_data_CTD[drugs_with_CTD_entries]

# Save the list. 
# New list with 71 entries (previously 53) saved 08/16/2021.
TCGA_drug_target_data_CTD_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "CTD", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(TCGA_drug_target_data_CTD, TCGA_drug_target_data_CTD_filename)
```

### DrugBank
DrugBank data was downloaded as an XML file from [...] on [...]. The data was migrated to a MySQL database for easier retrieval. See the Supplemental Data section for detailed methods. 
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Update 08/16/2021: now including even the drugs without KEGG pathways.
TCGA_drugs_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
TCGA_drugs = read.csv(TCGA_drugs_filename)
drugs = TCGA_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(drug_name) %>% unlist %>% unique %>% str_to_lower
DB_ids = TCGA_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(DB_id) %>% unlist %>% unique

TCGA_drug_target_data_DrugBank_tmp = data.frame(
  Drug = character(),
  Target = character(),
  Effect = numeric(),
  stringsAsFactors = F
)

# Get the targets of the drugs from the MySQL database. 

# Get all the possible pharmacological actions. 
#query = "SELECT PharmacologicalAction FROM DrugTargets.DrugBank;"
#res = dbSendQuery(DrugTargetsDB, query)
#pharm_actions = dbFetch(res) %>% unlist() %>% unique()
#View(pharm_actions)
#dbClearResult(res)
inhibitory_actions = c("inhibitor", "antagonist", "antibody", "inverse agonist", "inhibitory allosteric modulator", "negative modulator", "blocker", "weak inhibitor", "downregulator", "partial antagonist", "suppressor", "inactivator", "degradation", "incorporation into and destabilization", "inhibition of synthesis")
activating_actions = c("activator", "agonist", "stimulator", "potentiator", "inducer", "positive allosteric modulator", "partial agonist", "positive modulator")
        
# https://programminghistorian.org/en/lessons/getting-started-with-mysql-using-r#create-an-r-script-that-connects-to-the-database
# Make the connection to the MySQL database. 
# The connection method below uses a password stored in a settings file.
user_password = "Kibougaaru2020"
DrugTargetsDB = dbConnect(RMariaDB::MariaDB(), 
                          user='root', 
                          password=user_password, 
                          dbname='DrugTargets', 
                          host='localhost')
dbListTables(DrugTargetsDB)

# Make the queries. 
for(db_id in DB_ids) {
  query = paste0("SELECT DrugName, TargetName, Organism, PharmacologicalAction FROM DrugTargets.DrugBank WHERE DrugBankID = '", db_id, "';")
  res = dbSendQuery(DrugTargetsDB, query)
  drug_data = dbFetch(res)
  dbClearResult(res)
  
  if(nrow(drug_data) < 1) next
  
  # Get the drug name.
  drug_name = TCGA_drugs %>% dplyr::filter(DB_id==db_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  
  # Select the entries with "Human" in the Organism column.
  drug_data = drug_data %>% dplyr::filter(base::grepl("Human", Organism))
  
  # For each target, get the effect.
  for(target in unique(drug_data$TargetName)) {
    # Get the number of effects.
    drug_actions = drug_data %>% dplyr::filter(TargetName == target) %>% dplyr::select(PharmacologicalAction) %>% unique()
    
    if(length(drug_actions) > 0) {
      # Convert the pharmacological actions to -1, 0, or 1. 
      inhibitory = ifelse(sum(drug_actions %in% inhibitory_actions) > 0, T, F)
      activating = ifelse(sum(drug_actions %in% activating_actions) > 0, T, F)
      if(inhibitory & !activating) {
        drug_action_numeric = -1
      } else if(activating & !inhibitory) {
        drug_action_numeric = 1
      } else {
        drug_action_numeric = 0
      }
        
      # Add to the table.
      TCGA_drug_target_data_DrugBank_tmp = rbind(TCGA_drug_target_data_DrugBank_tmp, data.frame(
        Drug = drug_name,
        Target = target,
        Effect = drug_action_numeric,
        stringsAsFactors = F
      ))
    }
  }
}
# Disconnect
dbDisconnect(DrugTargetsDB)

# Save the temporary table.
TCGA_drug_target_data_DrugBank_tmp_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "DrugBank", extension = ".rds", processing_stage = "Processed", additional_info = "target_data_tmp")
saveRDS(TCGA_drug_target_data_DrugBank_tmp, TCGA_drug_target_data_DrugBank_tmp_filename)

# Make sure all the drug names in TCGA_drug_target_data_DrugBank_tmp match the names in drugs. (We will need to do some manual correction, more than likely.)
setdiff(unique(TCGA_drug_target_data_DrugBank_tmp$Drug), drugs)
setdiff(drugs, unique(TCGA_drug_target_data_DrugBank_tmp$Drug))

# Convert the targets in TCGA_drug_target_data_DrugBank_tmp to ENTREZ IDs.
hs = org.Hs.eg.db
keys = TCGA_drug_target_data_DrugBank_tmp$Target %>% as.character()
x = AnnotationDbi::select(hs, 
               keys = keys,
               columns = c("SYMBOL", "ENTREZID"),
               keytype = "SYMBOL") %>% .[complete.cases(.),] %>% distinct()

# Remove any ENTREZIDs that don't have corresponding KEGG entries.
entrez_no_kegg = c()
for(entrez_id in unique(x$ENTREZID)) {
  print(paste0("Checking if gene ", entrez_id, " has a KEGG entry."))
  
  possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
        entrez_test = keggGet(paste0("hsa:", entrez_id))
    }, error=function(cond) {
        message(cond)
    }
    )
  if(inherits(possibleError, "error") | !exists("entrez_test")) {
      entrez_no_kegg = c(entrez_no_kegg, entrez_id)
  }
  
  rm(entrez_test)
}
x = x %>% dplyr::filter(!(ENTREZID %in% entrez_no_kegg))
# Convert to ENTREZ.
# https://stackoverflow.com/a/3905442
a = x$SYMBOL
b = x$ENTREZID
TCGA_drug_target_data_DrugBank_tmp$Target = b[match(TCGA_drug_target_data_DrugBank_tmp$Target, a)]
TCGA_drug_target_data_DrugBank = TCGA_drug_target_data_DrugBank_tmp %>% .[complete.cases(.),]

# We won't need to convert to list to match CTD format until we merge the DrugBank and KEGG data.

# Merge.
#TCGA_drug_target_data_DrugBank = rbind(TCGA_drug_target_data_DrugBank, TCGA_drug_target_data_DrugBank_tmp)

# Change everything to sentence caps. 
#TCGA_drug_target_data_DrugBank$Drug = str_to_sentence(TCGA_drug_target_data_DrugBank$Drug)

# Filter out targets that already exist (i.e. keep only unique rows.)
#TCGA_drug_target_data_DrugBank = TCGA_drug_target_data_DrugBank %>% distinct()

# 11 Aug 2021: replace venotoclax -> venetoclax.
TCGA_drug_target_data_DrugBank$Drug = TCGA_drug_target_data_DrugBank$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")

# Save.
# Update 08/16/2021: now including even the drugs without KEGG pathways.
TCGA_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
write.table(TCGA_drug_target_data_DrugBank, TCGA_drug_target_data_DrugBank_filename, sep=",", row.names=F)
```

### KEGG
KEGG data was downloaded using the KEGGREST package in R (3.6.3.) Since KEGG does not provide the pharmacological effects of drugs on the target (e.g. whether the drug acts as an antagonist or agonist), 
```{r echo = FALSE, eval=TRUE, include=FALSE}
TCGA_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
TCGA_drug_target_data_DrugBank = read.csv(TCGA_drug_target_data_DrugBank_filename)

TCGA_drugs_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
TCGA_drugs = read.csv(TCGA_drugs_filename, stringsAsFactors = F)
kegg_ids = TCGA_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(KEGG_id) %>% unlist %>% unique %>% .[!is.na(.)]

TCGA_drug_target_data_KEGG = data.frame(
  Drug = character(),
  Target = character(),
  Effect = character()
)
# Table to hold the mutant/fusion protein targets. 
TCGA_drug_target_data_KEGG_v = data.frame( # v = variation. 
  Drug = character(),
  Target = character()
)
for(kegg_drug_id in kegg_ids) {
  drug = TCGA_drugs %>% dplyr::filter(KEGG_id==kegg_drug_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  print(paste0("Getting the KEGG targets for drug ", drug, "."))

    # Get the pathways affected.
  if(!is.null(kegg_drug_id) & !is.na(kegg_drug_id)) {
    
    possibleError = tryCatch(
    {
      kegg_pathways = keggGet(kegg_drug_id)[[1]]$TARGET
    }, error=function(cond) {
      message(paste0("There was a problem retrieving the drug-target data from KEGG for the drug ", drug, ":"))
      message(cond)
    }
  )
  
    if(inherits(possibleError, "error")) {
      print(paste0("There was a problem retrieving the drug-target data from KEGG for the drug ", drug, ":"))
      next
    }
  
    else {
      if(class(kegg_pathways)=="list") {
        # Get the mutant/fusion protein targets and add them to a separate table. 
        kegg_targets = kegg_pathways$TARGET
        v_targets = kegg_targets %>% regexPipes::grep("\\*", value = T) %>% str_split(" ") %>% unlist %>% regexPipes::grep("\\[HSA\\:", value = T) %>% regexPipes::gsub("\\[HSA\\:", "") %>% regexPipes::gsub("\\]", "") # This assumes that drugs can't target both a mutant and non-mutant form. ... 
        TCGA_drug_target_data_KEGG_v = rbind(TCGA_drug_target_data_KEGG_v, data.frame(
          Drug = rep(drug, length(v_targets)),
          Target = v_targets
        ))
        
        # Now get the rest of the targets from the pathways. 
        kegg_pathways = kegg_pathways$PATHWAY
      
        # Keep only the signal-transduction and disease-associated pathways (hsa03xxx, hsa04xxx and hsa05xxx.) 
        kegg_pathway_names = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("[[:space:]]+.+$", "")
      
        # Get the targets of the drug and filter the targets to include only the ones that are not already present in the DB table.
        drug_targets_DrugBank = TCGA_drug_target_data_DrugBank %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist
        targets = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("hsa0[345][[:digit:]]{3}", "") %>% regexPipes::gsub("[[:space:]]+.+$", "") %>% regexPipes::gsub("[()]", "") %>% str_split("\\+") %>% unlist() %>% unique() #%>% .[!(. %in% drug_targets_DrugBank)] As of 2022-06-05, we are no longer removing the drug targets present in the DrugBank table at this step. We will wait until the "Merging DrugBank and KEGG" step to do that, because we need all the KEGG targets present when we do the TRRUST stuff. 
      
        # Add to the table.
        TCGA_drug_target_data_KEGG = rbind(TCGA_drug_target_data_KEGG, data.frame(
          Drug = rep(drug, length(targets)),
          Target = targets,
          Effect = rep(-1, length(targets)) # I'm assuming most of the drugs are inhibitors. ... 
        ))
      }
    }
  } 
  
}

# Keep only unique rows.
TCGA_drug_target_data_KEGG = TCGA_drug_target_data_KEGG %>% distinct()

# For the most part, the drugs are inhibitors, but for two drug-target pairs, fulvestrant and 2100, and phenformin and 5563, we will have to manually update them. 
TCGA_drug_target_data_KEGG = TCGA_drug_target_data_KEGG
TCGA_drug_target_data_KEGG[TCGA_drug_target_data_KEGG$Drug=="fulvestrant" & TCGA_drug_target_data_KEGG$Target=="2100","Effect"] = 0
TCGA_drug_target_data_KEGG[TCGA_drug_target_data_KEGG$Drug=="phenformin" & TCGA_drug_target_data_KEGG$Target=="5563","Effect"] = 1

# 11 Aug 2021: replace venotoclax -> venetoclax.
TCGA_drug_target_data_KEGG$Drug = TCGA_drug_target_data_KEGG$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")
TCGA_drug_target_data_KEGG_v$Drug = TCGA_drug_target_data_KEGG_v$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")

# Remove the following drugs from the _v table, since they do not target mutant but overexpressed/fusion proteins: trastuzumab, lapatinib, crizotinib. Well, maybe keep crizo in the _v table for consistency? It looks like we did that for the network scores? 
TCGA_drug_target_data_KEGG_v$Effect = -1
for(drug in c("lapatinib")) {
  # Add the appropriate row to non-_v table.
  TCGA_drug_target_data_KEGG = rbind(TCGA_drug_target_data_KEGG, TCGA_drug_target_data_KEGG_v %>% dplyr::filter(Drug==drug))
}
TCGA_drug_target_data_KEGG_v = TCGA_drug_target_data_KEGG_v %>% dplyr::filter(!(Drug %in% c("lapatinib")))

# Save. 
TCGA_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
TCGA_drug_target_data_KEGG_v_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_data", processing_stage = "Processed")
write.table(TCGA_drug_target_data_KEGG, TCGA_drug_target_data_KEGG_filename, sep=",", row.names=F)
write.table(TCGA_drug_target_data_KEGG_v, TCGA_drug_target_data_KEGG_v_filename, sep=",", row.names=F)
```

### Merging DrugBank and KEGG
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Load the Drugbank and KEGG target information.
TCGA_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
TCGA_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
TCGA_drug_target_data_KEGG_v_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_data", processing_stage = "Processed")
TCGA_drug_target_data_KEGG = read.csv(TCGA_drug_target_data_KEGG_filename)
TCGA_drug_target_data_KEGG_v = read.csv(TCGA_drug_target_data_KEGG_v_filename)
TCGA_drug_target_data_DrugBank = read.csv(TCGA_drug_target_data_DrugBank_filename)

# Merge the Drugbank and KEGG target tables. 
TCGA_drug_target_data_DrugBank_KEGG = rbind(TCGA_drug_target_data_DrugBank, TCGA_drug_target_data_KEGG) %>% distinct()
# Consolidate duplicate rows (i.e., rows with the same target but different effects).
# https://stackoverflow.com/a/10180178
TCGA_drug_target_data_DrugBank_KEGG = TCGA_drug_target_data_DrugBank_KEGG %>% dplyr::select(Drug, Target, Effect) %>% ddply(.(Drug, Target), numcolwise(sum))
#rownames(TCGA_drug_target_data_DrugBank_KEGG) = TCGA_drug_target_data_DrugBank_KEGG$Target
# Because of the consolidation in the previous step, we might have effect values > 1 or < -1. Set the ceiling and floor to be 1 and -1, respectively. 
TCGA_drug_target_data_DrugBank_KEGG$Effect = ifelse(TCGA_drug_target_data_DrugBank_KEGG$Effect > 1, 1, TCGA_drug_target_data_DrugBank_KEGG$Effect)
TCGA_drug_target_data_DrugBank_KEGG$Effect = ifelse(TCGA_drug_target_data_DrugBank_KEGG$Effect < -1, -1, TCGA_drug_target_data_DrugBank_KEGG$Effect)

# Remove all the entries from the Drugbank targets that are also present in the variant KEGG table (i.e. the ones that have mutations/fusions.)
TCGA_drug_target_data_DrugBank_KEGG = TCGA_drug_target_data_DrugBank_KEGG %>% .[!(paste(.$Drug, .$Target, sep="_") %in% paste(TCGA_drug_target_data_KEGG_v$Drug, TCGA_drug_target_data_KEGG_v$Target, sep="_")),]

# Convert from Entrez ID to HUGO gene symbol. 
hs = org.Hs.eg.db
keys = TCGA_drug_target_data_DrugBank_KEGG$Target %>% as.character
x = AnnotationDbi::select(hs, 
                          keys = keys,
                          columns = c("SYMBOL", "ENTREZID"),
                          keytype = "ENTREZID") %>% .[complete.cases(.),]
TCGA_drug_target_data_DrugBank_KEGG$Target = x %>% .[match(TCGA_drug_target_data_DrugBank_KEGG$Target, .$ENTREZID),] %>% .$SYMBOL

# Split the dataframe into a list, to match the CTD drug-target-data format and the format that most of the calcNetworkScores() functions use. 
TCGA_drug_target_data_DrugBank_KEGG = split(TCGA_drug_target_data_DrugBank_KEGG , f = TCGA_drug_target_data_DrugBank_KEGG$Drug)

# Remove all entries in the list whose tables have 0 rows. (28 June 2021.)
for(entry in names(TCGA_drug_target_data_DrugBank_KEGG)) {
  if(nrow(TCGA_drug_target_data_DrugBank_KEGG[[entry]]) < 1) {
    TCGA_drug_target_data_DrugBank_KEGG[[entry]] = NULL
  } 
}

# Save.
TCGA_drug_target_data_DrugBank_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "DrugBank_KEGG", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(TCGA_drug_target_data_DrugBank_KEGG, TCGA_drug_target_data_DrugBank_KEGG_filename)
```

### TRRUST
#### Target pathways from KEGG
```{r}
# From KEGG, get the pathways targeted by each drug. 
TCGA_drugs_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
TCGA_drugs = read.csv(TCGA_drugs_filename, stringsAsFactors = F)
drugs = TCGA_drugs %>% dplyr::select(drug_name) %>% unlist %>% unique %>% str_to_lower
TCGA_drug_target_pathway_data_KEGG = data.frame(
  Drug = character(),
  PathwayName = character(),
  PathwayID = character(),
  Target = character(),
  stringsAsFactors = F
)
TCGA_drug_target_pathway_data_KEGG_v = data.frame(
  Drug = character(),
  PathwayName = character(),
  PathwayID = character(),
  Target = character(),
  stringsAsFactors = F
)
kegg_ids = TCGA_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(KEGG_id) %>% unlist %>% unique %>% .[!is.na(.)]
for(kegg_drug_id in kegg_ids) {
  drug = TCGA_drugs %>% dplyr::filter(KEGG_id==kegg_drug_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  print(paste0("Getting KEGG pathways for drug ", drug, "."))
  
  if(!is.null(kegg_drug_id)) {
    kegg_drug_id = kegg_drug_id %>% str_trim
    kegg_pathways = keggGet(kegg_drug_id)[[1]]$TARGET
    
    if(class(kegg_pathways)=="list") {
      # Get the targets of the drug.
      kegg_targets = kegg_pathways$TARGET
      
      # Get the mutant/fusion protein targets and add them to a separate table. 
      v_targets = kegg_targets %>% regexPipes::grep("\\*", value = T) %>% str_split(" ") %>% unlist %>% regexPipes::grep("\\[HSA\\:", value = T) %>% regexPipes::gsub("\\[HSA\\:", "") %>% regexPipes::gsub("\\]", "") # This assumes that drugs can't target both a mutant and non-mutant form. ... 
      TCGA_drug_target_pathway_data_KEGG_v = rbind(TCGA_drug_target_pathway_data_KEGG_v, data.frame(
        Drug = rep(drug, length(v_targets)),
        PathwayName = rep(NA, length(v_targets)),
        PathwayID = rep(NA, length(v_targets)),
        Target = v_targets
      ))
      
      # Now get the rest of the targets from the pathways. 
      kegg_pathways = kegg_pathways$PATHWAY
      
      # Get the names of the pathways.
      kegg_pathway_names = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>%  regexPipes::gsub("^[[:alnum:]]+\\(.*\\)[[:space:]]*", "") %>% str_to_upper() %>% regexPipes::gsub("[[:space:]]", "_") %>% paste0("KEGG_", .)
      # Get the KEGG IDs of the pathways.
      KEGG_pathway_ids = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("\\(.+$", "")
      # Get the targets in those pathways. 
      kegg_pathway_targets = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("hsa0[345][[:digit:]]{3}\\(", "") %>% regexPipes::gsub("\\).+$", "") %>% str_split("\\+")
      if(length(kegg_pathway_targets) < 1) {
        print(paste0("There are no applicable KEGG pathways for drug ", drug, ". Skipping to the next one."))
        next
      }
      names(kegg_pathway_targets) = KEGG_pathway_ids
      
      # Create the vectors for the drugs, pathway names, pathway IDs, and targets.
      target_vector = kegg_pathway_targets %>% unlist
      pathway_id_vector = c()
      for(name in names(kegg_pathway_targets)) {
        pathway_id_vector = c(pathway_id_vector, rep(name, length(kegg_pathway_targets[[name]])))
      }
      pathway_name_vector = c()
      for(i in 1:length(kegg_pathway_targets)) {
        pathway_name_vector = c(pathway_name_vector, rep(kegg_pathway_names[i], length(kegg_pathway_targets[[i]])))
      }
  
      if(length(kegg_pathway_names)==length(KEGG_pathway_ids)) {
        TCGA_drug_target_pathway_data_KEGG = rbind(TCGA_drug_target_pathway_data_KEGG, data.frame(
          Drug = rep(drug, length(pathway_name_vector)),
          PathwayName = pathway_name_vector,
          PathwayID = pathway_id_vector,
          Target = target_vector,
          stringsAsFactors = F
        ))
      } # End if(length(kegg_pathway_names)==length(KEGG_pathway_ids)). 
    } # End if(class(kegg_pathways)=="list"). 
  } # End if(!is.null(kegg_drug_id)). 

}

# Currently, the normal target table has ALL the records. We will remove from it all the mutant protein targets. (This is different from what we did in the KEGG protein target section.)
# Add RecordID field to both _v and normal target tables.
TCGA_drug_target_pathway_data_KEGG$RecordID = paste(TCGA_drug_target_pathway_data_KEGG$Drug, TCGA_drug_target_pathway_data_KEGG$Target, sep = "_")
TCGA_drug_target_pathway_data_KEGG_v$RecordID = paste(TCGA_drug_target_pathway_data_KEGG_v$Drug, TCGA_drug_target_pathway_data_KEGG_v$Target, sep = "_")

# Remove the following drugs from the _v table, since they do not target mutant but overexpressed/fusion proteins: trastuzumab, lapatinib, crizotinib.
TCGA_drug_target_pathway_data_KEGG_v = TCGA_drug_target_pathway_data_KEGG_v %>% dplyr::filter(!(Drug %in% c("trastuzumab", "lapatinib", "crizotinib")))
# Now filter the normal table by the _v table.
# But first save the _v stuff!
tmp = TCGA_drug_target_pathway_data_KEGG %>% dplyr::filter(RecordID %in% TCGA_drug_target_pathway_data_KEGG_v$RecordID)
TCGA_drug_target_pathway_data_KEGG = TCGA_drug_target_pathway_data_KEGG %>% dplyr::filter(!(RecordID %in% TCGA_drug_target_pathway_data_KEGG_v$RecordID))
TCGA_drug_target_pathway_data_KEGG_v = tmp

rm(tmp)

# Save to file.
TCGA_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
TCGA_drug_target_pathway_data_KEGG_v_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_pathway_data", processing_stage = "Processed")
write.table(TCGA_drug_target_pathway_data_KEGG, TCGA_drug_target_pathway_data_KEGG_filename, sep=",", row.names=F)
write.table(TCGA_drug_target_pathway_data_KEGG_v, TCGA_drug_target_pathway_data_KEGG_v_filename, sep=",", row.names=F)
```

#### Genes downstream of each drug target
```{r}
# Get all the targeted pathways. 
TCGA_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
TCGA_drug_target_pathway_data_KEGG = read.csv(TCGA_drug_target_pathway_data_KEGG_filename)
# We no longer have to remove drug-target-pathway combinations involving mutant/fusion proteins in this step, since we did it in the last one. 08/21/2021.
KEGG_pathway_ids = TCGA_drug_target_pathway_data_KEGG$PathwayID %>% unique() 
# Get all the direct targets of the drugs.
TCGA_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
TCGA_drug_target_data_KEGG = read.csv(TCGA_drug_target_data_KEGG_filename)
TCGA_drug_targets_KEGG = TCGA_drug_target_data_KEGG$Target %>% unique() %>% paste0("hsa:", .)

# For each pathway, get the nodes downstream of each target. 
TCGA_drug_target_downstream_node_data_KEGG = data.frame(
  Pathway = character(),
  Target = character(),
  DownstreamNodes = character(),
  Effects = numeric(),
  stringsAsFactors = F
)
for(pathway in KEGG_pathway_ids) {
  print(paste0("Working on pathway ", pathway, "."))
  
  # Load the KGML file. 
  #kgml = keggGet("hsa04010", option = "kgml")
  #parsed_kgml = parseKGML(kgml)
  #pathway_graph = KEGGpathway2Graph(parsed_kgml)
  kgml = keggGet(pathway, option = "kgml")

  # Convert the KGML file into an iGraph object.
  # First convert to a graphNEL object.
  graphNEL = parseKGML2Graph(kgml, expandGenes = T, genesOnly = F) # PI3K signaling occurs through PIP3, which is a lipid. ... 
  #graphNEL_layout = layoutGraph(graphNEL)
  #renderGraph(graphNEL_layout)
  
  # For MAPK pathway only--create a directed edge between the RTK node and the GRB2 node, and between the GRB2 node and the SOS node. 
  rtk_nodes = c("hsa:1436","hsa:1956","hsa:1969","hsa:2064","hsa:2065","hsa:2066","hsa:2260","hsa:2261","hsa:2263","hsa:2264","hsa:2321","hsa:2322","hsa:2324","hsa:3480","hsa:3643","hsa:3791","hsa:3815","hsa:4233","hsa:4804","hsa:4914","hsa:4915","hsa:5156","hsa:5159","hsa:7010")
  grb2_node = "hsa:2885"
  sos_nodes = c("hsa:6654","hsa:6655")
  if(pathway=="hsa04010") {
    graphNEL = addEdge(rtk_nodes, grb2_node, graphNEL, 1)
    graphNEL = addEdge(grb2_node, sos_nodes, graphNEL, 1)
  }
  
  # Next, weight the edges by whether they are inhibitory or activating. 
  # @_@
  # For each edge in the graph (pathway_graph or graphNEL), use the KEGG edge data to determine whether it is an activating or inhibitory edge. If it is activating, leave it alone. Otherwise, set it to -1. 
  kegg_edge_data = getKEGGedgeData(graphNEL)
  kegg_edges = edges(graphNEL)
  kegg_edge_weights = edgeWeights(graphNEL)
  # Generate a list of all the edges. 
  all_edges = c()
  for(first_node in names(kegg_edges)) {
    if(length(kegg_edges[[first_node]]) > 0) all_edges = c(all_edges, paste0(first_node, "~", kegg_edges[[first_node]]))
  }
        
  for(edge in all_edges) {
    first_node = str_split(edge, "~") %>% unlist %>% .[1]
    second_node = str_split(edge, "~") %>% unlist %>% .[2]
    edge_data = getKEGGedgeData(graphNEL)[[edge]] # This will be NULL for the edges we added on, since we only added the edges, not any metadata. 
    if(!is.null(edge_data)) {
      if(length(getSubtype(edge_data)) > 0) {
        edge_subtype = getName(getSubtype(getKEGGedgeData(graphNEL)[[edge]])$subtype) # "activation" or "inhibition".
        } else {
          edge_subtype = "activation"
        }
    } else {
        edge_subtype = "activation"
      }
    
    if(edge_subtype=="inhibition") kegg_edge_weights[[first_node]][second_node] = -1
  }
  #edgeWeights(graphNEL) = kegg_edge_weights
  # Above line of code doesn't work--see comment below. 
  
  # Then convert to iGraph.
  igraph = graph_from_graphnel(graphNEL, name = TRUE, weight = TRUE,
  unlist.attrs = TRUE)
  # Set the weights of the iGraph to be kegg_edge_weights.
  # (We can't change the weights of a graphNEL object, apparently, so we have to do it this way. ... Of course, this assumes that the edges are in the same order in igraph as they are once you unlist kegg_edge_weights. ... If we ever update any of the packages used here, we will have to 2x check this.)
  edge_attr(igraph)$weight = unlist(kegg_edge_weights)
  
  # Get the downstream nodes of the target of the drug. 
  # https://rdrr.io/github/robertness/lucy/man/get_downstream_nodes.html 
  TCGA_drug_targets_KEGG_i = TCGA_drug_targets_KEGG %>% .[. %in% names(V(igraph))]
  for(drug_target in TCGA_drug_targets_KEGG_i) {
    print(paste0("Working on target ", drug_target, " in pathway ", pathway, "."))
    
    w = V(igraph)[drug_target]
     possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      downstream_nodes = V(igraph)[get_downstream_nodes(igraph, w)]
    }, error=function(cond) {
      message(paste0("There was a problem getting the nodes downstream from target ", drug_target, ":"))
      message(cond)
    }
  )
    if(inherits(possibleError, "error") | !exists("downstream_nodes")) {
      print(paste0("Skipping drug target ", drug_target, "."))
      next
    }
    
    # Check if there are any downstream nodes. If not, move on to the next target.
    if(length(downstream_nodes) < 1) {
      print(paste0("Target ", drug_target, " has no downstream nodes. Moving on!"))
      next
    }
    downstream_node_names = downstream_nodes %>% names() # %>% paste(collapse=",")
    
    # Determine the effect of the target on each node? (I.e. upregulated or downregulated. ... This is important, but can we do it without having to do it manually??)
    # Get all the edges between the target and the downstream nodes. 
    #all_paths = all_simple_paths(igraph, from = V(igraph)[drug_target], to = downstream_nodes, mode = "out")
    possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      all_paths = shortest_paths(igraph, from = V(igraph)[drug_target], to = downstream_nodes, weights = rep(1, length(unlist(kegg_edge_weights)))) %>% .$vpath # Have to set the weights to all be positive; otherwise, the algorithm doesn't work. Using all_simple_paths returns all possible paths. 
    }, error=function(cond) {
      message(paste0("There was a problem getting the shortest paths from target ", drug_target, ":"))
      message(cond)
    }
  )
    if(inherits(possibleError, "error") | !exists("all_paths")) {
      print(paste0("Skipping drug target ", drug_target, "."))
      next
    }

    effects = c()
    for(i in 1:length(all_paths)) {
      # Get path i. 
      path = all_paths[[i]] %>% names()
      # Because of the way get.edge.ids works, we need to duplicate all inner vertices (vertices that are not the first or last) in path in order to get all the edges that make up the path.
      if(length(path) > 2) {
        vertices = c(path[1], rep(path[2:(length(path)-1)], each = 2), path[length(path)])
      } else {
        vertices = path
      }
      # Get the IDs of the edges connecting vertices in the path. 
      edge_ids = get.edge.ids(igraph, vertices, directed = TRUE, error = FALSE,
  multi = FALSE)
      # Get the weights of those edges.
      weights = edge_attr(igraph, "weight", index = E(igraph)[edge_ids])
      # Multiply them together. 
      # https://stackoverflow.com/a/62561005
      effect = ifelse(prod(weights) < 0, -1, 1)
      # If < 0, then -1; if > 0, then 1.
      effects = c(effects, effect)
    }
    
    # Add to the table. 
    TCGA_drug_target_downstream_node_data_KEGG = rbind(TCGA_drug_target_downstream_node_data_KEGG, data.frame(
    Pathway = rep(pathway, length(downstream_nodes)),
    Target = rep(drug_target, length(downstream_nodes)),
    DownstreamNodes = names(downstream_nodes),
    Effects = effects,
    stringsAsFactors = F
    ))
    
    # Remove old "downstream_nodes" and "all_paths" so that the error checks can be triggered properly.
    rm(downstream_nodes, all_paths)
  }
    
}

# Save.
TCGA_drug_target_downstream_node_data_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_downstream_node_data", processing_stage = "Processed")
write.table(TCGA_drug_target_downstream_node_data_KEGG, TCGA_drug_target_downstream_node_data_KEGG_filename, sep=",", row.names=F)
```

#### Transcription factors and their targets for each pathway
```{r}
TCGA_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
TCGA_drug_target_pathway_data_KEGG = read.csv(TCGA_drug_target_pathway_data_KEGG_filename)

KEGG_pathways_complete_filename = paste0(folder_generator(data_dir, data_source = "GSEA-MSigDB", data_type = "Misc", processing_stage = "Raw"), "c2.cp.kegg.v7.1.symbols.gmt")
KEGG_pathways_complete = GSA.read.gmt(KEGG_pathways_complete_filename)
TCGA_drug_target_downstream_node_data_KEGG = read.csv(TCGA_drug_target_downstream_node_data_KEGG_filename)

# Load the TRRUST data. 
TRRUST_data_filename = paste0(folder_generator(data_dir, data_source = "TRRUST", data_type = "Misc", processing_stage = "Raw"), "trrust_rawdata.human.tsv")
TRRUST_data = read.table(TRRUST_data_filename, header = F)
colnames(TRRUST_data) = c("TF", "Target",	"ModeOfRegulation",	"PMID")
# Exclude all unknown interactions from the TRRUST data. 
TRRUST_data = TRRUST_data %>% dplyr::filter(ModeOfRegulation != "Unknown")

# For each unique pathway in TCGA_drug_target_pathway_data_KEGG, get the transcription factors from that pathway. 
TCGA_drug_target_txnal_target_data_KEGG_TRRUST = data.frame(
  Pathway = character(),
  DrugTarget = character(),
  TFentrez = character(),
  TFsymbol = character(),
  TranscriptionalTarget = character(),
  ModeOfRegulation = character(),
  stringsAsFactors = F
)

for(pathway in unique(TCGA_drug_target_pathway_data_KEGG$PathwayID)) {
  # Get the drug targets in that pathway. 
  pathway_drug_targets = TCGA_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Pathway==pathway) %>% dplyr::select(Target) %>% unlist() %>% unique()
  
  for(drug_target in pathway_drug_targets) {
    # Get the nodes downstream of that target. Remove any nodes that are not genes. 
    downstream_nodes = TCGA_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Pathway==pathway & Target == drug_target & regexPipes::grepl(.$DownstreamNodes, "hsa\\:")) %>% dplyr::select(DownstreamNodes, Effects) %>% distinct()
  
    if(nrow(downstream_nodes) < 1) {
      print(paste0("Target ", drug_target, " has no downstream gene nodes. Skipping this one!"))
      next
    }
    
    # Convert the downstream nodes from their KEGG ID to their gene name. 
    hs = org.Hs.eg.db
    keys = downstream_nodes$DownstreamNodes %>% unlist() %>% regexPipes::gsub("hsa\\:", "")
    x = AnnotationDbi::select(hs, 
               keys = keys,
               columns = c("SYMBOL", "ENTREZID"),
               keytype = "ENTREZID") %>% .[complete.cases(.),]
    # We will be back-converting from symbols to ENTREZ IDs, so make sure that each symbol maps to only ONE ENTREZ ID. 
    # ... Which, come to think of it, shouldn't be a problem, since we started out with ENTREZ IDs, and I don't think KEGG had duplicates. ... 
  
    # Get the transcription factors.
    # https://stackoverflow.com/questions/10586652/r-preserve-order-when-using-matching-operators-in
    tfs = intersect(unique(TRRUST_data$TF), x$SYMBOL)
    if(length(tfs) < 1) {
      print(paste0("Target ", drug_target, " has no downstream transcription factors. Skipping this one!"))
      next
    }
    
    tfs_entrez = x %>% .[match(tfs, .$SYMBOL),] %>% .$ENTREZID %>% paste0("hsa:", .)
    names(tfs_entrez) = tfs
  
    # Get the targets of those transcription factors.
    for(tf in tfs) {
      txn_target = TRRUST_data %>% dplyr::filter(TF==tf) %>% dplyr::select(TF, Target, ModeOfRegulation)
    
      # Add to the table if there are any transcriptional targets. 
      TCGA_drug_target_txnal_target_data_KEGG_TRRUST = rbind(TCGA_drug_target_txnal_target_data_KEGG_TRRUST, data.frame(
        Pathway = rep(pathway, nrow(txn_target)),
        DrugTarget = rep(drug_target, nrow(txn_target)),
        TFentrez = rep(tfs_entrez[tf], nrow(txn_target)),
        TFsymbol = txn_target$TF,
        TranscriptionalTarget = txn_target$Target,
        ModeOfRegulation = txn_target$ModeOfRegulation,
        stringsAsFactors = F
        ))
    }
    
  }
  
}

# Add an effect column.
TCGA_drug_target_txnal_target_data_KEGG_TRRUST$Effect = ifelse(TCGA_drug_target_txnal_target_data_KEGG_TRRUST$ModeOfRegulation=="Repression", -1, 1)

# Save.
TCGA_drug_target_txnal_target_data_KEGG_TRRUST_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG_TRRUST", extension = ".csv", additional_info = "target_txnal_target_data", processing_stage = "Processed")
write.table(TCGA_drug_target_txnal_target_data_KEGG_TRRUST, TCGA_drug_target_txnal_target_data_KEGG_TRRUST_filename, sep=",", row.names=F)
```

#### Final effects of drugs on downstream targets
Combine the data from TCGA_drug_target_data_KEGG, drug_genes_table and TCGA_drug_target_txnal_target_data_KEGG_TRRUST (i.e. multiply the effects) to get the final effect of the drug on each of its transcriptional targets. 
```{r}
TCGA_drug_target_txnal_target_data_KEGG_TRRUST_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG_TRRUST", extension = ".csv", additional_info = "target_txnal_target_data", processing_stage = "Processed")
TCGA_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
TCGA_drug_target_downstream_node_data_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_downstream_node_data", processing_stage = "Processed")
TCGA_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")

TCGA_drug_target_txnal_target_data_KEGG_TRRUST = read.csv(TCGA_drug_target_txnal_target_data_KEGG_TRRUST_filename)
TCGA_drug_target_pathway_data_KEGG = read.csv(TCGA_drug_target_pathway_data_KEGG_filename)
TCGA_drug_target_downstream_node_data_KEGG = read.csv(TCGA_drug_target_downstream_node_data_KEGG_filename)
TCGA_drug_target_data_KEGG = read.csv(TCGA_drug_target_data_KEGG_filename)

TCGA_drug_target_data_TRRUST = data.frame(
  Drug = character(),
  Target = character(),
  Effect = numeric(),
  stringsAsFactors = F
)

# Indirect targets. 
for(drug in unique(TCGA_drug_target_data_KEGG$Drug)) {
  # For each drug, get its corresponding targets from TCGA_drug_target_data_KEGG. 
  drug_targets = TCGA_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist() %>% paste0("hsa:", .)
  
  # Get the pathways this drug is involved in. We are going to restrict transcriptional effects to the pathways the drug is known to be involved in. (E.g., if drug A targets EGFR, even if EGFR is involved in multiple pathways, we will only consider the pathways that drug A has listed in KEGG.)
  drug_pathways = TCGA_drug_target_pathway_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(PathwayID) %>% unlist() %>% unique
  
  for(drug_target in drug_targets) {
    # Get the effect of the drug on this target.
    target_edited = drug_target %>% regexPipes::gsub("hsa\\:", "")
    fx_drug_on_target = TCGA_drug_target_data_KEGG %>% dplyr::filter(Drug==drug & Target==target_edited) %>% dplyr::select(Effect) %>% unlist()
    
    # For each drug target, get the TFs that are downstream of that target. 
    tfs = TCGA_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & Pathway %in% drug_pathways) %>% dplyr::select(TFentrez) %>% unlist() %>% as.character() %>% unique() # Pathway %in% drug_pathways ensures that only the downstream TFs in the pathways associated with that drug are chosen.
    
    # For each TF, get the downstream transcriptional targets from TCGA_drug_target_txnal_target_data_KEGG_TRRUST.
    for(tf in tfs) {
      txn_targets = TCGA_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & Pathway %in% drug_pathways & TFentrez==tf) %>% dplyr::select(TranscriptionalTarget) %>% unlist() %>% as.character() %>% unique() # Pathway %in% drug_pathways ensures that only the downstream txnal targets in the pathways associated with that drug are chosen.
    
      # For each downstream transcriptional target, calculate the final effect. 
      # Use TCGA_drug_target_downstream_node_data_KEGG.
      for(txn_target in txn_targets) {
        print(paste0("Calculating effect of drug ", drug, " on target ", txn_target, "."))
        # Final effect = effect of drug on target (fx_drug_on_target, already calculated in outer loop) * effect of drug target on TF (from TCGA_drug_target_downstream_node_data_KEGG) (fx_drug_target_on_tf) * effect of TF on transcriptional target (from TCGA_drug_target_txnal_target_data_KEGG_TRRUST) (fx_tf_on_txn_target).
        fx_drug_target_on_tf = TCGA_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Target == drug_target & DownstreamNodes == tf & Pathway %in% drug_pathways) %>% dplyr::select(Effects) %>% unlist()
        fx_tf_on_txn_target = TCGA_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & TFentrez==tf & TranscriptionalTarget == txn_target & Pathway %in% drug_pathways) %>% dplyr::select(Effect) %>% unlist()
        final_effect = prod(fx_drug_on_target, fx_drug_target_on_tf, fx_tf_on_txn_target)
        
        TCGA_drug_target_data_TRRUST = rbind(TCGA_drug_target_data_TRRUST, data.frame(
          Drug = drug,
          Target = txn_target,
          Effect = final_effect,
          stringsAsFactors = F
          ))
        }
    }
  }
}

# Direct targets. 
colnames(TCGA_drug_target_data_TRRUST)[3] = "Effect"
hs = org.Hs.eg.db
keys = unique(TCGA_drug_target_data_KEGG$Target) %>% as.character()
x = AnnotationDbi::select(hs, 
           keys = keys,
           columns = c("SYMBOL", "ENTREZID"),
           keytype = "ENTREZID") %>% .[complete.cases(.),] %>% distinct()
for(drug in unique(TCGA_drug_target_data_KEGG$Drug)) {
  # For each drug, get its corresponding targets and effects from TCGA_drug_target_data_KEGG. 
  drug_targets = TCGA_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist()
  final_effects = TCGA_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Effect) %>% unlist()
  
  # Convert to gene symbol.
  #keggGet(kegg_drug_id) %>% .[[1]] %>% .$NAME %>% str_split(",") %>% .[[1]] %>% .[1]
  a = x$ENTREZID
  b = x$SYMBOL
  target_ids = b[match(drug_targets, a)]
  # Alternative: 
  #target_ids = c()
  #for(target in unique(TCGA_drug_target_data_KEGG$Target)) {
  #  print(paste0("Getting gene ID for target ", target, "."))
  #  target_ids = c(target_ids, keggGet(paste0("hsa:",target)) %>% .[[1]] %>% .$NAME %>% str_split(",") %>% .[[1]] %>% .[1])
  #}
  
  # Add to TCGA_drug_target_data_TRRUST. 
  TCGA_drug_target_data_TRRUST = rbind(TCGA_drug_target_data_TRRUST, data.frame(
          Drug = rep(drug, length(final_effects)),
          Target = target_ids,
          Effect = final_effects,
          stringsAsFactors = F
          ))
}

# Keep only unique rows.
TCGA_drug_target_data_TRRUST = TCGA_drug_target_data_TRRUST %>% distinct()

# Split the dataframe into a list, to match the CTD drug-target-data format and the format that most of the calcNetworkScores() functions use. 
TCGA_drug_target_data_TRRUST = split(TCGA_drug_target_data_TRRUST , f = TCGA_drug_target_data_TRRUST$Drug)

# Remove all entries in the list whose tables have 0 rows. (28 June 2021.)
for(entry in names(TCGA_drug_target_data_TRRUST)) {
  if(nrow(TCGA_drug_target_data_TRRUST[[entry]]) < 1) {
    TCGA_drug_target_data_TRRUST[[entry]] = NULL
  } 
}

# Save.
TCGA_drug_target_data_TRRUST_filename = filename_generator(data_dir, data_source = "TCGA", data_type = "Drugs", data_set = "TRRUST", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(TCGA_drug_target_data_TRRUST, TCGA_drug_target_data_TRRUST_filename)
#write.table(TCGA_drug_target_data_TRRUST, paste0(data_dir, "Processed_data/TCGA/TCGA_kegg_drug_final_effects.csv"), sep = ",", row.names = F)
```

## Expression: differential expression
```{r}
pData_filename = filename_generator(data_dir = data_dir, data_source = "TCGA", data_type = "pData", extension = ".rds", processing_stage = "Processed", full_path = T)
pData = readRDS(pData_filename)
cancers = unique(pData$GSE)

# Determine whether to use GTEx or TCGA for normals. 
num_normal_samples_per_cancer_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source= "TCGA",
  data_type = "Metadata",
  processing_stage = "Processed"
), "TCGA_number_of_normal_samples_per_cancer.csv")
cancer_types_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "TCGA",
  data_type = "Metadata",
  processing_stage = "Processed"
), "TCGA_cancer_types.csv")
num_normal_samples_per_cancer = read.csv(num_normal_samples_per_cancer_filename, stringsAsFactors = F)
cancer_types = read.csv(cancer_types_filename, stringsAsFactors = F)

normal_source_table = data.frame(
  Cancer = character(),
  NormalSource = character(),
  stringsAsFactors = F
)

for(cancer in cancers) {
  gtex_normal = cancer_types %>% filter(TCGACancer==cancer) %>% dplyr::select(GTExNormalTissue) %>% unlist()
  num_tcga_normals = num_normal_samples_per_cancer %>% filter(Cancer==cancer) %>% dplyr::select(NumNormalSamples) %>% unlist()
  
  if(num_tcga_normals >= 10) {
    normal_source = "TCGA"
  } else {
    if(!is.na(gtex_normal)) {
      normal_source = "GTEx"
    } else {
      if(num_tcga_normals >= 1) {
        normal_source = "GTEx"
      } else {
        normal_source = "Exclude"
      }
    }
  }
  
  normal_source_table = rbind(normal_source_table, data.frame(
  Cancer = cancer,
  NormalSource = normal_source,
  stringsAsFactors = F
  ))

}

# Load deg_list if it exists. Otherwise, initiate it. 
deg_list_filename = filename_generator(data_dir = data_dir, data_source = "TCGA", data_type = "Expression", data_subtype = "DEG_list", extension = ".rds", processing_stage = "Processed", processing = "YuGene", gene_identifier = "HUGO", DE_criterion = "all_genes", full_path = T)
if(file.exists(deg_list_filename)) {
  deg_list = readRDS(deg_list_filename)
} else {
  deg_list = list()
}

cancers = normal_source_table %>% filter(NormalSource != "Exclude") %>% dplyr::select(Cancer) %>% unlist() %>% unique() # Remove all the cancers that have no corresponding normal tissues.

# Calculate differential expression.
for(cancer in cancers) {
  print(paste0("Performing differential expression calculation for samples in cancer ", cancer, "."))
  
  # Read in the processed RNA-seq data.
  rnaseq = readRDS(paste0(tcga_data_dir, "TCGA_processed_samples/", cancer, "_tumor_samples_processed_", preprocessing_method, ".rds")) %>% as.data.frame()
  
  # Change the column names. (Keep only the first 12 characters.)
  colnames(rnaseq) = colnames(rnaseq) %>% substring(1, 12)
  
  # Keep only the samples in pData. 
  #samples = pData %>% filter(GSE==cancer) %>% dplyr::select(GSM) %>% unlist() %>% as.character()
  #rnaseq = rnaseq %>% dplyr::select(matches(samples))
  
  # Load the normal samples.
  normal_source = normal_source_table %>% filter(Cancer==cancer) %>% dplyr::select(NormalSource) %>% unlist()
  if(normal_source == "TCGA") {
    # Check if the file exists. If it does, load it. If it doesn't, create it. 
    if(file.exists(paste0(tcga_data_dir, "TCGA_processed_samples/", cancer, "_normal_samples_processed_", preprocessing_method, ".rds"))) {
      normal_samples = readRDS(paste0(tcga_data_dir, "TCGA_processed_samples/", cancer, "_normal_samples_processed_", preprocessing_method, ".rds"))
    } else {
      print(paste0("Error: the cancer ", cancer, " does not have associated normal tissue. Skipping this cancer."))
      next
    }
    
  } else if(normal_source == "GTEx") {
    normal_tissue_type = cancer_types %>% filter(TCGACancer==cancer) %>% dplyr::select(GTExNormalTissue) %>% unlist()
    # Check if the file exists. If it does, load it. If it doesn't, create it. 
    if(file.exists(paste0(data_dir, "GTEx/Processed_samples/GTEx_normal_samples_processed_", normal_tissue_type, ".rds"))) {
    normal_samples = readRDS(paste0(data_dir, "GTEx/Processed_samples/GTEx_normal_samples_processed_", normal_tissue_type, ".rds"))
    } else {
      print(paste0("Error: the cancer ", cancer, " does not have associated normal tissue. Skipping this cancer."))
      next
    }
  
  } else {
    # This shouldn't be. ... 
    print(paste0("The cancer ", cancer, " does not have matching normal tissue. Skipping this cancer."))
    next
  }
  
  for(sample in colnames(rnaseq)) {
    print(paste0("Processing sample ", sample, "."))
    
    # Check if this sample is already in deg_list. 
    if(sample %in% names(deg_list)) {
      print(paste0("Sample ", sample, " is already in deg_list. Skipping this one."))
      next
    }
    
    # Load the expression matrix of the patient sample.
    patient_sample = rnaseq[,colnames(rnaseq)==sample,drop=F]
    # Load the appropriate processed normal tissue. 
    if(normal_source=="GTEx") {
      normal_samples2 = t(normal_samples) # Transposing because GTEx_normal_samples_processed.rds contains the expression matrices with rows as samples and columns as genes. 
    } else {
      normal_samples2 = normal_samples
    }
  
    ######################################
    ## 1. DATA PREPARATION AND CLEANING ##
    ######################################
    # Make sure the genes are the same across both the patient samples and normal tissue. 
    common_genes = intersect(rownames(normal_samples2), rownames(patient_sample))
    normal_samples2 = normal_samples2[rownames(normal_samples2) %in% common_genes,]
    patient_sample = patient_sample[rownames(patient_sample) %in% common_genes,,drop=F]
    normal_samples2 = normal_samples2[order(rownames(normal_samples2)),]
    patient_sample = patient_sample[order(rownames(patient_sample)),,drop=F]
    identical(rownames(normal_samples2), rownames(patient_sample))

    ##############################################
    ## 2. DIFFERENTIAL GENE EXPRESSION ANALYSIS ##
    ##############################################
    # For each gene, get the changes in rank between normal and tumor. 
    tumor_rank = patient_sample[order(patient_sample[,1], decreasing = T),1,drop=F]
    tumor_rank = cbind(tumor_rank, 1:nrow(tumor_rank))
    tumor_rank = tumor_rank[order(rownames(tumor_rank)),]
  
    normal_avg = rowMeans(normal_samples2) %>% as.data.frame() #as.matrix(future_apply(normal_samples2, 1, mean)) # Because we have more than one normal sample, get the rank of the average expression of the gene across all the samples.
    normal_rank = normal_samples2[order(normal_avg[,1], decreasing = T),1,drop=F]
    normal_rank = cbind(normal_rank, 1:length(normal_rank))
    normal_rank = normal_rank[order(rownames(normal_rank)),]
  
    identical(rownames(normal_rank), rownames(tumor_rank))
    rank_dif = as.matrix(tumor_rank[,2] - normal_rank[,2])
    rownames(rank_dif) = rownames(normal_rank) # rank_dif is now a data frame with the ranks of each gene. 
  
    # Select DEGs as the genes with rank differences >= 2SDs +/- the mean. 
    if(deg_type=="All") {
      deg_names = rownames(rank_dif)
    } else {
      lower_bound = mean(rank_dif) - deg_cutoff*sd(rank_dif)
      upper_bound = mean(rank_dif) + deg_cutoff*sd(rank_dif)
      upreg_degs = rownames(rank_dif[rank_dif[,1] > upper_bound,,drop=F])
      downreg_degs = rownames(rank_dif[rank_dif[,1] < lower_bound,,drop=F])
      deg_names = c(upreg_degs, downreg_degs)
    }
  
    # Create the table of differentially expressed genes. 
    degs = rank_dif[rownames(rank_dif) %in% deg_names,,drop=F]
  
    # Create the table of intensities.
    intensities = patient_sample[rownames(patient_sample) %in% deg_names,,drop=F]
    identical(rownames(intensities), rownames(degs)) # These are the two tables we'll be adding to deg_list[[sample]], so make sure they match. 

    # Add the table of differentially expressed genes to the list. 
    deg_list[[sample]][["DEGs"]] = degs
    deg_list[[sample]][["Intensity"]] = intensities
  
    # Remove all the samples expression matrices and clean up the memory. 
    rm(patient_sample, normal_samples2)
    gc()
  }
  
}

# Save the list.
saveRDS(deg_list, deg_list_filename)
```

## Expression: network construction
### All genes
```{r}
deg_type = "All"
if(deg_type == "All")  {
  all_genes = "_all-genes"
} else if(deg_type == "SD") {
  all_genes = paste0(deg_cutoff, "SD")
} else {
  all_genes = paste0(deg_type)
}

# Load the list of DEG genes for each patient sample if it is not loaded already. 
deg_list_filename = filename_generator(data_dir = data_dir, data_source = "TCGA", data_type = "Expression", data_subtype = "DEG_list", extension = ".rds", processing_stage = "Processed", processing = preprocessing_method, gene_identifier = id_type, DE_criterion = all_genes, full_path = T)
deg_list = readRDS(deg_list_filename)

# https://www.biostars.org/p/190137/#222651
# Instantiate STRINGdb reference class. We will set a very stringent threshold (default 400) and of course choose humans as our species. Do it outside the for() loop so we don't have to instantiate it every time. 
string_db = STRINGdb$new(version="10", species=9606, score_threshold=400, input_directory=folder_generator(
  data_dir = data_dir,
  data_source = "STRING-DB",
  data_type = "Network",
  processing_stage = "Raw"
))
#system.time({
for(GSM in names(deg_list)) {
  network_filename = filename_generator(data_dir = data_dir, data_source = "NCI-60", data_type = "Expression", data_subtype = "disease_network", extension = ".rds", data_set = GSE, sample = GSM, processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, DE_criterion = "all_genes", full_path = T)
  if(file.exists(network_filename)) next
  
  # Set up a list to hold the network, the mapping, and the hits. 
  network_list = list()
  
  # Differential gene expression data.
  de_genes = as.data.frame(deg_list[[GSM]][["DEGs"]])
  de_genes$GeneSymbol = rownames(de_genes)
  colnames(de_genes)[1] = "RankChange"
  
  # Map gene names from the table of differentially expressed genes to STRING identifiers. 
  #system.time({
  mapped = string_db$map(de_genes, "GeneSymbol", removeUnmappedRows=TRUE)
  #}) # Time: user system elapsed 7.412   0.248   7.978 
  hits = mapped$STRING_id # These are the hits. To select the top n hits, simply subset using [1:n]. Because we start with ~150 genes, which should be enough to make a decent PPI network, we will just use all of these genes without subsetting. 
    # Plot the network, showing the number of proteins (genes), the number of interactions, and the p-value (probability that we would get, by chance, as many interactions as we did in   this network.)
    # string_db$plot_network(hits)

  # As of 05/17/2021, we no longer have to create a subnetwork. ... I think.
  # Create an iGraph network object. This is the disease network, which we can now run iGraph functions on.
  #system.time({
  #network = string_db$get_subnetwork(hits) # user system elapsed 0.017   0.066   0.192
  #})
  # Save network to list.
  #network_list[["Network"]] = network 
  network_list[["Map"]] = mapped
  network_list[["Hits"]] = hits
  
  # New addition 01/29/2021; need the intensity for the WINTHER score.
  # Add intensity.
  intensity = as.data.frame(deg_list[[GSM]][["Intensity"]])
  intensity = intensity[rownames(intensity) %in% mapped$GeneSymbol,,drop=F]
  colnames(intensity) = "Intensity"
  network_list[["Intensity"]] = intensity
  
  # Save the list to RDS.
  saveRDS(network_list, network_filename)
  
  # Clean up.
  rm(network_list)
  gc()
}
#})
```

### Rank-difference cutoff
```{r}
deg_type = "SD"
if(deg_type == "All")  {
  all_genes = "_all-genes"
} else if(deg_type == "SD") {
  all_genes = paste0(deg_cutoff, "SD")
} else {
  all_genes = paste0(deg_type)
}

# Load the list of DEG genes for each patient sample if it is not loaded already. 
deg_list_filename = filename_generator(data_dir = data_dir, data_source = "TCGA", data_type = "Expression", data_subtype = "DEG_list", extension = ".rds", processing_stage = "Processed", processing = preprocessing_method, gene_identifier = id_type, DE_criterion = all_genes, full_path = T)
deg_list = readRDS(deg_list_filename)

# https://www.biostars.org/p/190137/#222651
# Instantiate STRINGdb reference class. We will set a very stringent threshold (default 400) and of course choose humans as our species. Do it outside the for() loop so we don't have to instantiate it every time. 
string_db = STRINGdb$new(version="10", species=9606, score_threshold=400, input_directory=folder_generator(
  data_dir = data_dir,
  data_source = "STRING-DB",
  data_type = "Network",
  processing_stage = "Raw"
))
#system.time({
for(GSM in names(deg_list)) {
  network_filename = filename_generator(data_dir = data_dir, data_source = "NCI-60", data_type = "Expression", data_subtype = "disease_network", extension = ".rds", data_set = GSE, sample = GSM, processing_stage = "Processed", processing = preprocessing_type, gene_identifier = id_type, DE_criterion = "all_genes", full_path = T)
  if(file.exists(network_filename)) next
  
  # Set up a list to hold the network, the mapping, and the hits. 
  network_list = list()
  
  # Differential gene expression data.
  de_genes = as.data.frame(deg_list[[GSM]][["DEGs"]])
  de_genes$GeneSymbol = rownames(de_genes)
  colnames(de_genes)[1] = "RankChange"
  
  # Map gene names from the table of differentially expressed genes to STRING identifiers. 
  #system.time({
  mapped = string_db$map(de_genes, "GeneSymbol", removeUnmappedRows=TRUE)
  #}) # Time: user system elapsed 7.412   0.248   7.978 
  hits = mapped$STRING_id # These are the hits. To select the top n hits, simply subset using [1:n]. Because we start with ~150 genes, which should be enough to make a decent PPI network, we will just use all of these genes without subsetting. 
    # Plot the network, showing the number of proteins (genes), the number of interactions, and the p-value (probability that we would get, by chance, as many interactions as we did in   this network.)
    # string_db$plot_network(hits)

  # As of 05/17/2021, we no longer have to create a subnetwork. ... I think.
  # Create an iGraph network object. This is the disease network, which we can now run iGraph functions on.
  #system.time({
  #network = STRING_DB$get_subnetwork(hits) # user system elapsed 0.017   0.066   0.192
  #})
  # Save network to list.
  #disease_network_list[["Network"]] = network 
  network_list[["Map"]] = mapped
  network_list[["Hits"]] = hits
  
  # New addition 01/29/2021; need the intensity for the WINTHER score.
  # Add intensity.
  intensity = as.data.frame(deg_list[[GSM]][["Intensity"]])
  intensity = intensity[rownames(intensity) %in% mapped$GeneSymbol,,drop=F]
  colnames(intensity) = "Intensity"
  network_list[["Intensity"]] = intensity
  
  # Save the list to RDS.
  saveRDS(network_list, network_filename)
  
  # Clean up.
  rm(network_list)
  gc()
}
#})
```

# DrugComb
## pData
```{r}
DrugComb_pData_filename = paste0(data_dir, "DrugComb/pData/Processed/DrugComb_pData.rds")
if(file.exists(DrugComb_pData_filename)) {
  pData = readRDS(DrugComb_pData_filename)
} else {
  # Read in the raw CSV file.
  pData = read.csv(paste0(data_dir, "DrugComb/pData/Raw/summary_v_1_5.csv"))
  # Save to RDS for future use.
  saveRDS(pData, DrugComb_pData_filename)
}

# Get the studies we want.
studies = c("ALMANAC", "ONEIL") # "ONEIL", "ALMANAC", "CCLE", "CTRPV2", "GDSC1", "GRAY", "ASTRAZENECA", "FRIEDMAN"
pData_sub = pData %>% dplyr::filter(study_name %in% studies)
pData_sub[pData_sub=="NULL"] = NA

# Get the unique drug names, along with the data sets they're used in.
drug_table = pData_sub %>% dplyr::distinct(drug_row, study_name) %>% arrange(study_name)
# Group by study and arrange drugs in alphabetical order. 
#drugs = pData_sub %>% dplyr::select(drug_row, drug_col) %>% unlist %>% as.character %>% unique
write.table(drug_table, paste0(data_dir, "DrugComb/DrugComb_drug_ids.csv"), row.names = F, sep = ",")
# Get the standardized drug names (the drug names used in the final ML data set) for each study. 
# ALMANAC.
ALMANAC_ML_data = read.csv(filename_generator(data_dir = data_dir, data_source = "ALMANAC", data_set = "PROGENy", data_type = "ML", processing_stage = "Processed", input_or_output = "Input", data_subset_type = "Full", additional_info = "combined", extension = ".csv"))
ALMANAC_ML_data %>% .$Drugs %>% str_split("_") %>% unlist %>% as.character %>% unique %>% as.data.frame %>% write.table(paste0(data_dir, "ALMANAC/Drugs/Processed/ALMANAC_drug_names_standardized.csv"), sep = ",", row.names = F, col.names = F)
# ONeil.
ONeil_ML_data = read.csv(filename_generator(data_dir = data_dir, data_source = "ONeil", data_set = "PROGENy", data_type = "ML", processing_stage = "Processed", input_or_output = "Input", data_subset_type = "Full", additional_info = "Combos", extension = ".csv"))
ONeil_ML_data %>% .$combination_name %>% str_split("_") %>% unlist %>% as.character %>% unique %>% as.data.frame %>% write.table(paste0(data_dir, "ONeil/Drugs/Processed/ONeil_drug_names_standardized.csv"), sep = ",", row.names = F, col.names = F)
# Make sure we got all the drugs.
drug_ids = read.csv(paste0(data_dir, "DrugComb/DrugComb_drug_ids_processed.csv")) %>% .[complete.cases(.),]
nrow(drug_ids[drug_ids$study_name=="ALMANAC",]) == ALMANAC_ML_data %>% .$Drugs %>% str_split("_") %>% unlist %>% as.character %>% unique %>% length
setdiff(ALMANAC_ML_data %>% .$Drugs %>% str_split("_") %>% unlist %>% as.character %>% unique, drug_ids[drug_ids$study_name=="ALMANAC",'standardized_name'])
# Ok, looks like DrugComb is missing epirubicin (103 vs 104 drugs.)
nrow(drug_ids[drug_ids$study_name=="ONEIL",]) == ONeil_ML_data %>% .$combination_name %>% str_split("_") %>% unlist %>% as.character %>% unique %>% length
setdiff(ONeil_ML_data %>% .$combination_name %>% str_split("_") %>% unlist %>% as.character %>% unique, drug_ids[drug_ids$study_name=="ONEIL",'standardized_name'])

# Cell line names for dictionary. 
pData %>% dplyr::filter(study_name=="ALMANAC") %>% .$cell_line_name %>% as.character %>% unique %>% as.data.frame() %>% write.table(paste0(data_dir, "NCI-60/Metadata/Raw/NCI-60_cell_line_names_DrugComb.csv"), sep = ",", row.names = F, col.names = F)
pData %>% dplyr::filter(study_name=="ONEIL") %>% .$cell_line_name %>% as.character %>% unique %>% as.data.frame() %>% write.table(paste0(data_dir, "ONeil/Metadata/Raw/ONeil_cell_line_names_DrugComb.csv"), sep = ",", row.names = F, col.names = F)

# Subset pData_sub to include only the entries with our drugs and cell lines. 
NCI60_cell_line_name_dict_filename = paste0(folder_generator(data_dir, data_source = "NCI-60", data_type = "Metadata", processing_stage = "Processed"), "NCI-60_cell_line_names_ALMANAC_GEO_GDSC_CCLE_DrugComb.csv")
ONeil_cell_line_name_dict_filename = paste0(folder_generator(
  data_dir = data_dir,
  data_source = "ONeil",
  data_type = "Metadata",
  processing_stage = "Processed"
), "ONeil_cell_line_names_dictionary.csv")
NCI60_cell_line_name_dict = read.csv(NCI60_cell_line_name_dict_filename)
ONeil_cell_line_name_dict = read.csv(ONeil_cell_line_name_dict_filename)
drugs = drug_ids$drug_row %>% unique
ALMANAC_cell_lines = NCI60_cell_line_name_dict %>% .$DrugComb_name
ONeil_cell_lines = ONeil_cell_line_name_dict %>% dplyr::filter(Keep=="Y") %>% .$DrugComb
cell_lines = union(ALMANAC_cell_lines, ONeil_cell_lines) # DrugComb names. 
pData_sub = pData_sub %>% dplyr::filter(drug_row %in% drugs & drug_col %in% drugs & cell_line_name %in% cell_lines)

# Merge drugs.
pData_sub$drugs = paste(pData_sub$drug_row, pData_sub$drug_col, sep ="_")
pData_sub = pData_sub %>% dplyr::relocate(drugs, .before = cell_line_name)
# Replace
# Save.
DrugComb_pData_sub_filename = paste0(data_dir, "DrugComb/pData/Processed/DrugComb_pData_sub.rds")
saveRDS(pData_sub, DrugComb_pData_sub_filename)

```

# Gao
##### Clinical data
```{r}
# Read in the raw phenotype data.
pData = read.csv(pData_raw_Gao_filename)
# Rename the columns.
colnames(pData) = c("GSM",	"Drugs",	"TreatmentTarget",	"TreatmentType",	"BestResponse",	"Day_BestResponse",	"BestAvgResponse",	"Day_BestAvgResponse",	"TimeToDouble",	"Day_Last", "ResponseCategory")

# Load the PCT raw data. We will need it for the cancer types.
pct_raw_data = read.csv(PCT_data_raw_Gao_filename, stringsAsFactors = F)
pct_raw_data[pct_raw_data$Model=="X-3782","Tumor.Type"] = "PDAC"
pct_raw_data[pct_raw_data$Model=="X-1468","Tumor.Type"] = "BRCA"
#View(unique(pct_raw_data$Tumor.Type))
# Create a table mapping model numbers to cancer type. 
model_to_cancer_type_table = pct_raw_data %>% dplyr::select(Model, Tumor.Type) %>% distinct()
# Open the table mapping cancer types to (normal) tissue type.
cancer_type_to_tissue_type_table = read.csv(Gao_cancer_types_filename, stringsAsFactors = F)
# Create the final mapping table (mapping models to normal tissue type.)
model_tissue_type = c()
for(i in 1:nrow(model_to_cancer_type_table)) {
  model_cancer_type = model_to_cancer_type_table[i,"Tumor.Type"]
  model_tissue_type = c(model_tissue_type, cancer_type_to_tissue_type_table[cancer_type_to_tissue_type_table$Cancer==model_cancer_type,"GTExNormalTissue"])
}
#View(model_tissue_type)
cancer_types = model_to_cancer_type_table %>% dplyr::select(Model, Tumor.Type)
cancer_types$GTExNormalTissue = model_tissue_type

# Add a GSE (i.e. cancer type) column to pData.
GSE = c()
for(i in 1:nrow(pData)) {
  cancer_type = model_to_cancer_type_table %>% dplyr::filter(Model==pData[i,"GSM"]) %>% dplyr::select(Tumor.Type) %>% unlist() %>% .[1]
  GSE = c(GSE, cancer_type)
}
pData$GSE = GSE
# Some of the models in pData are not in pct_raw_data. These will show up in pData as having GSE = NA. Remove these. 
pData = pData %>% dplyr::filter(!is.na(GSE))

# Get a list of drugs.
all_drugs = pData$Drugs %>% str_split("\\+") %>% unlist() %>% trimws() %>% unique() %>% regexPipes::gsub("-.+$", "") %>% regexPipes::gsub('\\"', '')
# Format the PCT raw data to match.
pData$Drugs = pData$Drugs %>% regexPipes::gsub("-.+$", "") %>% regexPipes::gsub('\\"', '')

# Correct the drug names.
drug_name_corrections = read.csv(Gao_drug_names_filename, stringsAsFactors = F)
# Add a unique ID row--we will need this to merge rows again.
pData$UniqueID = 1:nrow(pData)
# Split along "+".
pData = pData %>% separate_rows(Drugs, sep = "[\\+]", convert = FALSE)
# Remove trailing/leading whitespace.
pData$Drugs = pData$Drugs %>% trimws()
# Correct names.
# https://stackoverflow.com/a/3905442
a = drug_name_corrections$OldName
b = drug_name_corrections$Correction
pData$Drugs = b[match(pData$Drugs, a)]

all_drugs = pData$Drugs %>% unique() %>% sort()

# Untreated patients/drugs with no target information.
#gao_drugs_no_targets = c(
#  "CKX620",
#  "LKA136",
#  "Untreated"
#)

# Remove patients treated with drugs we have no target information for. 
#patient_ids_drugs_no_targets = pData %>% filter(Drugs %in% gao_drugs_no_targets) %>% dplyr::select(UniqueID) %>% unlist() %>% unique()
#pData = pData %>% filter(!(UniqueID %in% patient_ids_drugs_no_targets))

# Merge.
pData =  pData %>% group_by(UniqueID) %>% 
       mutate(Drugs = paste(Drugs, collapse="_")) %>%
       distinct(UniqueID, .keep_all = T)

# Save.
saveRDS(pData, pData_final_Gao_filename)
saveRDS(cancer_types, Gao_cancer_types_filename)

# Update 08/21/2021: rename columns to match those expected by calcNetworkScores.R
Gao_pData = readRDS(pData_final_Gao_filename)
Gao_pData$Dataset = "Gao"
Gao_pData = Gao_pData %>% dplyr::rename(Sample = GSM)
saveRDS(Gao_pData, pData_final_Gao_filename)

# Update 08/21/2021: convert all drug names to lower-case.
Gao_pData = readRDS(pData_final_Gao_filename)
Gao_pData$Drugs = Gao_pData$Drugs %>% str_to_lower()
saveRDS(Gao_pData, pData_final_Gao_filename)
```

##### Molecular data
```{r}
# Read in the RNA-seq data.
rna_seq_raw = read.csv(paste0(Gao_raw_data_dir, "Gao_PDX_RNAseq_FPKM.csv"))
rownames(rna_seq_raw) = rna_seq_raw[,1]
rna_seq_raw = rna_seq_raw[,-1]
colnames(rna_seq_raw) = colnames(rna_seq_raw) %>% regexPipes::gsub("\\.", "-")

# Subset both pData and rna_seq_raw to include only the samples present in both. 
#samples_keep = intersect(unique(pData$Model), colnames(rna_seq_raw))
#rna_seq_raw = rna_seq_raw[,colnames(rna_seq_raw) %in% samples_keep]
#pData = pData %>% filter(Model %in% samples_keep)

# Run YuGene normalization. 
# Perform log2 transformation. 
rna_seq_log2 = log2transform(rna_seq_raw)
# Perform YuGene normalization.
rna_seq_YuGene = YuGene(rna_seq_log2)
rna_seq_YuGene = rna_seq_YuGene[1:nrow(rna_seq_YuGene),1:ncol(rna_seq_YuGene)] # This step is needed because apparently YuGene() returns a 'YuGene' object, not a matrix, and using colnames() does something funky.
rna_seq = rna_seq_YuGene 

# Save.
saveRDS(rna_seq, paste0(Gao_processed_data_dir, "Gao_tumor_samples_processed.rds"))
```

##### Differential expression analysis
```{r}
# Load the PCT curve data.
pData = readRDS(pData_final_Gao_filename)
# Load the cancer types table.
cancer_types = readRDS(Gao_cancer_types_filename)

# Load deg_list if it exists. Otherwise, initiate it. 
if(file.exists(paste0(Gao_processed_data_dir, "Gao_deg_list", all_genes, ".rds"))) {
  deg_list = readRDS(paste0(Gao_processed_data_dir, "Gao_deg_list", all_genes, ".rds"))
} else {
  deg_list = list()
}

# Read in the processed RNA-seq data.
rnaseq = readRDS(paste0(Gao_processed_data_dir, "Gao_tumor_samples_processed.rds")) %>% as.data.frame()

# Calculate differential expression.
for(cancer in unique(cancer_types$Tumor.Type)) {
  print(paste0("Performing differential expression calculation for samples in cancer ", cancer, "."))
  
  # Keep only the samples of that cancer type. 
  samples = cancer_types %>% dplyr::filter(Tumor.Type==cancer & Model %in% pData$GSM) %>% dplyr::select(Model) %>% unlist() %>% as.character()
  rnaseq_sub = rnaseq[,colnames(rnaseq) %in% samples] # rnaseq %>% dplyr::select(matches(samples))
  if(nrow(rnaseq_sub) < 1) next
  
  # Load the normal samples.
  normal_tissue_type = cancer_types %>% dplyr::filter(Tumor.Type==cancer) %>% dplyr::select(GTExNormalTissue) %>% unlist() %>% .[1]
  # Check if the file exists. If it does, load it. If it doesn't, create it.
  if(file.exists(paste0(GTEx_processed_data_dir, "GTEx_normal_samples_processed_", normal_tissue_type, ".rds"))) {
    normal_samples = readRDS(paste0(GTEx_processed_data_dir, "GTEx_normal_samples_processed_", normal_tissue_type, ".rds"))
  } else {
    print(paste0("Error: the cancer ", cancer, " does not have associated normal tissue. Skipping this cancer."))
    next
  }
  
  for(sample in colnames(rnaseq_sub)) {
    print(paste0("Processing sample ", sample, "."))
    
    # Check if this sample is already in deg_list. 
    if(sample %in% names(deg_list)) {
      print(paste0("Sample ", sample, " is already in deg_list. Skipping this one."))
      next
    }
    
    # Load the expression matrix of the patient sample.
    patient_sample = rnaseq_sub[,colnames(rnaseq_sub)==sample,drop=F]
    # Load the appropriate processed normal tissue. 
    normal_samples2 = t(normal_samples) # Transposing because GTEx_normal_samples_processed.rds contains the expression matrices with rows as samples and columns as genes. 
  
    ######################################
    ## 1. DATA PREPARATION AND CLEANING ##
    ######################################
    # Make sure the genes are the same across both the patient samples and normal tissue. 
    common_genes = intersect(rownames(normal_samples2), rownames(patient_sample))
    normal_samples2 = normal_samples2[rownames(normal_samples2) %in% common_genes,]
    patient_sample = patient_sample[rownames(patient_sample) %in% common_genes,,drop=F]
    normal_samples2 = normal_samples2[order(rownames(normal_samples2)),]
    patient_sample = patient_sample[order(rownames(patient_sample)),,drop=F]
    identical(rownames(normal_samples2), rownames(patient_sample))

    ##############################################
    ## 2. DIFFERENTIAL GENE EXPRESSION ANALYSIS ##
    ##############################################
    # For each gene, get the changes in rank between normal and tumor. 
    tumor_rank = patient_sample[order(patient_sample[,1], decreasing = T),1,drop=F]
    tumor_rank = cbind(tumor_rank, 1:nrow(tumor_rank))
    tumor_rank = tumor_rank[order(rownames(tumor_rank)),]
  
    normal_avg = rowMeans(normal_samples2) %>% as.data.frame() #as.matrix(future_apply(normal_samples2, 1, mean)) # Because we have more than one normal sample, get the rank of the average expression of the gene across all the samples.
    normal_rank = normal_samples2[order(normal_avg[,1], decreasing = T),1,drop=F]
    normal_rank = cbind(normal_rank, 1:length(normal_rank))
    normal_rank = normal_rank[order(rownames(normal_rank)),]
  
    identical(rownames(normal_rank), rownames(tumor_rank))
    rank_dif = as.matrix(tumor_rank[,2] - normal_rank[,2])
    rownames(rank_dif) = rownames(normal_rank) # rank_dif is now a data frame with the ranks of each gene. 
  
    # Select DEGs as the genes with rank differences >= 2SDs +/- the mean. 
    if(deg_type=="All") {
      deg_names = rownames(rank_dif)
    } else {
      lower_bound = mean(rank_dif) - deg_cutoff*sd(rank_dif)
      upper_bound = mean(rank_dif) + deg_cutoff*sd(rank_dif)
      upreg_degs = rownames(rank_dif[rank_dif[,1] > upper_bound,,drop=F])
      downreg_degs = rownames(rank_dif[rank_dif[,1] < lower_bound,,drop=F])
      deg_names = c(upreg_degs, downreg_degs)
    }
  
    # Create the table of differentially expressed genes. 
    degs = rank_dif[rownames(rank_dif) %in% deg_names,,drop=F]
    
    # Create the table of intensities.
    intensities = patient_sample[rownames(patient_sample) %in% deg_names,,drop=F]
    identical(rownames(intensities), rownames(degs)) # These are the two tables we'll be adding to deg_list[[sample]], so make sure they match. 
  
    # Add the table of differentially expressed genes to the list. 
    deg_list[[sample]][["DEGs"]] = degs
    deg_list[[sample]][["Intensity"]] = intensities
  
    # Remove all the samples expression matrices and clean up the memory. 
    rm(patient_sample, normal_samples2)
    gc()
  }
  
}

# Save the list.
saveRDS(deg_list, paste0(Gao_processed_data_dir, "Gao_deg_list", all_genes, ".rds"))
```

##### Network construction 
```{r}
# 08/03/2021:
# OK, I know this is weird, but the DEG list RDS file will always be named with "all_genes," so we need to set that before loading the file. 
# But once we load the file, we will need to change the deg_type back to whatever it is it will actually be. This is due to a change in how we processed the differentially expressed genes. Back then, we actually removed the non-DE genes before creating the network. Now we just keep all the genes and mark which ones are the DE genes. 
deg_type = "All"
all_genes = ifelse(deg_type == "All", "_all_genes", "") 

# Load the list of DEG genes for each patient sample if it is not loaded already. 
deg_list = readRDS(paste0(Gao_processed_data_dir, "Gao_deg_list", all_genes, ".rds"))

deg_type = "SD"
if(deg_type == "All")  {
  all_genes = "_all_genes"
} else if(deg_type == "SD") {
  all_genes = paste0("_", deg_cutoff, "SD")
} else {
  all_genes = paste("_", deg_type, "_")
}
disease_network_folder = "Rank-difference_cutoff/"

# https://www.biostars.org/p/190137/#222651
# Instantiate STRINGdb reference class. We will set a very stringent threshold (default 400) and of course choose humans as our species. Do it outside the for() loop so we don't have to instantiate it every time. 
string_db = STRINGdb$new(version="10", species=9606, score_threshold=400, input_directory=paste0(raw_data_dir, "STRING-DB"))
#system.time({
for(sample in names(deg_list)) {
  if(file.exists(paste0(Gao_processed_data_dir, "Disease_networks/", sample, "_disease_network", all_genes, ".rds"))) next
  
  print(paste0("Processing sample ", sample, "."))
  
  # Set up a list to hold the network, the mapping, and the hits. 
  disease_network_list = list()
  
  # Differential gene expression data.
  de_genes = as.data.frame(cbind(deg_list[[sample]][["DEGs"]], deg_list[[sample]][["Intensity"]]))
  # Add gene names and rename columns.
  de_genes$GeneSymbol = rownames(de_genes)
  colnames(de_genes)[1] = "RankChange"
  colnames(de_genes)[2] = "Intensity"
  # Choose genes for disease module by cutoff.
  rank_dif = de_genes$RankChange
  lower_bound = mean(rank_dif) - deg_cutoff*sd(rank_dif)
  upper_bound = mean(rank_dif) + deg_cutoff*sd(rank_dif)
  upreg_degs = rownames(de_genes[de_genes[,1] > upper_bound,,drop=F])
  downreg_degs = rownames(de_genes[de_genes[,1] < lower_bound,,drop=F])
  deg_names = c(upreg_degs, downreg_degs)
  de_genes$DiseaseModuleGene = ifelse(de_genes$GeneSymbol %in% deg_names, "Y", "N")
  
  # Map gene names from the table of differentially expressed genes to STRING identifiers. 
  #system.time({
  mapped = string_db$map(de_genes, "GeneSymbol", removeUnmappedRows=TRUE)
  #}) # Time: user system elapsed 7.412   0.248   7.978 
  hits = mapped$STRING_id # These are the hits. To select the top n hits, simply subset using [1:n]. Because we start with ~150 genes, which should be enough to make a decent PPI network, we will just use all of these genes without subsetting. 
    # Plot the network, showing the number of proteins (genes), the number of interactions, and the p-value (probability that we would get, by chance, as many interactions as we did in this network.)
    # string_db$plot_network(hits)

  # As of 05/17/2021, we no longer have to create a subnetwork. ... I think.
  # Create an iGraph network object. This is the disease network, which we can now run iGraph functions on.
  #system.time({
  #network = string_db$get_subnetwork(hits) # user system elapsed 0.017   0.066   0.192
  #})
  # Save network to list.
  #disease_network_list[["Network"]] = network 
  disease_network_list[["Map"]] = mapped
  disease_network_list[["Hits"]] = hits
  
  # New addition 11/01/2020; need the intensity for the WINTHER score.
  # Add intensity.
  intensity = as.data.frame(deg_list[[sample]][["Intensity"]])
  intensity = intensity[rownames(intensity) %in% mapped$GeneSymbol,,drop=F]
  colnames(intensity) = "Intensity"
  disease_network_list[["Intensity"]] = intensity
  
  # New addition 03/09/2021; need to know whether the gene is part of the disease module.
  # Make sure the gene names from de_genes matches the gene names in disease_disease_network_list. Or just save the gene names from de_genes.
  disease_network_list[["DiseaseModuleGene"]] = de_genes[,3:4]
  
  # Save the list to RDS.
  saveRDS(disease_network_list, paste0(Gao_processed_data_dir, "Disease_networks/", sample, "_disease_network", all_genes, ".rds"))
  
  # Clean up.
  rm(disease_network_list)
  gc()
}
#})
```

# GEO
## Clinical data
### Individual Esets
```{r}
# Load all the esets into a list. 
esets = list()
for(GSE in GSEs) {
  esets[[GSE]] = readRDS(paste0(GEO_processed_data_dir, GSE, "_eset_", preprocessing_method, "_", id_type, ".rds"))
}

# GSE30161.
keep = c(53, 54, 55, 64, 65, 67)
pData = pData(esets[["GSE30161"]])[,keep]
colnames(pData) = c("OSCensoring", "Drugs", "Response", "OSTime", "PFSTime", "PFSCensoring")
# Split the second column and replace "Taxol" with "Paclitaxel" and "Cytoxan" with "Cyclophosphamide". Also, replace blank entries with NAs. 
pData$Drug1 = str_split_fixed(pData$Drugs, "/", 2)[,1]
pData$Drug2 = str_split_fixed(pData$Drugs, "/", 2)[,2]
pData$Drugs = base::gsub("/", "_", pData$Drugs)
#pData = subset(pData, select=-c(Drug))
a = c("Taxol", "Cytoxan")
b = c("Paclitaxel", "Cyclophosphamide")
names(b) = a
pData$Drug2 = b[match(pData$Drug2, a)] # str_replace_all(pData$Drug2, b)
pData$Drugs = paste(pData$Drug1, pData$Drug2, sep = "_") %>% regexPipes::gsub("_NA", "") # str_replace_all(pData$Drugs, b)
pData$Drug2[pData$Drug2==""] = NA
# Clean up the response variable. 
pData$Response = base::gsub("[[:space:]]\\(.+\\)", "", pData$Response)
# Add the GSE.
pData$GSE = "GSE30161"
# Re-order the columns.
pData = pData[,c("GSE", "Drugs", "Drug1", "Drug2", "Response", "OSTime", "OSCensoring", "PFSTime", "PFSCensoring")]
# Save the pData. 
saveRDS(pData, paste0(GEO_processed_data_dir, "GSE30161_pData_pseaned.rds"))

# GSE18728
keep = c(44, 45, 47)
pData = pData(esets[["GSE18728"]])[,keep]
colnames(pData) = c("Response", "Timepoint", "PIN")
# Add the drugs column.
pData$Drugs = "Docetaxel_Capecitabine"
# Add the individual drug columns.
pData$Drug1 = "Docetaxel"
pData$Drug2 = "Capecitabine"
# Clean up the response variable. 
GSE18728_RECIST = read.csv(paste0(GEO_processed_data_dir, "GSE18728_RECIST.csv"))
patients_bl = pData[pData$Timepoint=="bl","PIN"]
sum(patients_bl %in%  GSE18728_RECIST$PIN)
response = c()
for(i in 1:nrow(pData)) {
  PIN = pData[i,"PIN"]
  RECIST = ifelse(nrow(GSE18728_RECIST[GSE18728_RECIST$PIN==PIN,]) < 1, NA, as.character(GSE18728_RECIST[GSE18728_RECIST$PIN==PIN,"RECIST"]))
  response = c(response, RECIST)
}
pData$Response = response
# Add the GSE.
pData$GSE = "GSE18728"
# Re-order the columns.
pData = pData[,c("GSE", "Drugs", "Drug1", "Drug2", "Response", "Timepoint", "PIN")]
# Save the pData. 
saveRDS(pData, paste0(GEO_processed_data_dir, "GSE18728_pData_pseaned.rds"))

# GSE28702
keep = c(1)
pData = pData(esets[["GSE28702"]])[,keep,drop=F]
colnames(pData) = c("Title")
# Add the drugs column.
pData$Drugs = "Leucovorin_Fluorouracil_Oxaliplatin"
# Add the individual drug columns.
pData$Drug1 = "Fluorouracil"
pData$Drug2 = "Oxaliplatin"
# Clean up the response variable. 
GSE28702_RECIST = read.csv(paste0(GEO_processed_data_dir, "GSE28702_RECIST.csv"))
response = c()
pData$PIN = base::gsub("^.+, #", "", pData$Title)
for(i in 1:nrow(pData)) {
  PIN = pData[i,"PIN"]
  RECIST = ifelse(nrow(GSE28702_RECIST[GSE28702_RECIST$PIN==PIN,]) < 1, NA, as.character(GSE28702_RECIST[GSE28702_RECIST$PIN==PIN,"RECIST"]))
  response = c(response, RECIST)
}
pData$Response = response
pData = subset(pData, select=-c(Title))
# Add the GSE.
pData$GSE = "GSE28702"
# Re-order the columns.
pData = pData[,c("GSE", "Drugs", "Drug1", "Drug2", "Response")]
# Save the pData. 
saveRDS(pData, paste0(GEO_processed_data_dir, "GSE28702_pData_pseaned.rds"))

# GSE72970
keep = c(48:51, 54:55)
pData = pData(esets[["GSE72970"]])[,keep,drop=F]
colnames(pData) = c("OSCensoring", "OSTime", "PFSCensoring", "PFSTime", "Drugs", "Response")
# Add the GSE.
pData$GSE = "GSE72970"
# Add the individual drug columns.
drugs = data.frame(Drug1=character(), Drug2=character(), stringsAsFactors = F)
for(i in 1:nrow(pData)) {
  regimen = pData[i,"Drugs"]
  if(regimen=="FOLFOX") {
    drugs = rbind(drugs, data.frame(Drug1="Fluorouracil", Drug2="Oxaliplatin"))
  } else if(regimen=="FOLFIRI") {
    drugs = rbind(drugs, data.frame(Drug1="Fluorouracil", Drug2="Irinotecan"))
  } else {
    drugs = rbind(drugs, data.frame(Drug1=NA, Drug2=NA))
  }
}
pData$Drug1 = drugs$Drug1
pData$Drug2 = drugs$Drug2
# Add the drugs column.
drugs = c()
for(i in 1:nrow(pData)) {
  regimen = pData[i,"Drugs"]
  chemo = str_split(regimen, "\\+")[[1]][1]
  mAB = str_split(regimen, "\\+")[[1]][2]
  if(is.na(mAB)) {
    mAB = ""
  } else if(mAB == "ERBITUX") {
    mAB = "_Cetuximab"
  } else {
    mAB = "_Bevacizumab"
  }
  
  if(chemo=="FOLFOX") {
    chemo = "Leucovorin_Fluorouracil_Oxaliplatin"
  } else if(chemo=="FOLFIRI") {
    chemo = "Leucovorin_Fluorouracil_Irinotecan"
  } else if(chemo=="FOLFIRINOX") {      
    chemo = "Leucovorin_Fluorouracil_Irinotecan_Oxaliplatin"
  } else if(chemo=="XELIRI") {
    chemo = "Capecitabine_Irinotecan" 
  }
  
  drugs = c(drugs, paste0(chemo, mAB))
}
pData$Drugs = drugs
# Re-order the columns.
#pData = subset(pData, select=-c(Drugs))
pData = pData[,c("GSE", "Drugs", "Drug1", "Drug2", "Response", "OSTime", "OSCensoring", "PFSTime", "PFSCensoring")]
saveRDS(pData, paste0(GEO_processed_data_dir, "GSE72970_pData_pseaned.rds"))

# GSE39345
keep = c(36, 39)
pData = pData(esets[["GSE39345"]])[,keep,drop=F]
colnames(pData) = c("Type", "Response")
# Reformat the Response column. (Replace a with b.)
a = unique(pData$Response)
a = a[complete.cases(a)]
b = c("PR", "SD", "PD")
names(b) = a
pData$Response = b[match(pData$Response, a)] #str_replace_all(pData$Response, b)
# Add the drugs columns.
pData$Drugs = "Cisplatin_Gemcitabine"
# Add the individual drug columns.
pData$Drug1 = "Cisplatin"
pData$Drug2 = "Gemcitabine"
# Add the GSE. 
pData$GSE = "GSE39345"
# Re-order the columns.
pData = pData[,c("GSE", "Drugs", "Drug1", "Drug2", "Response", "Type")]
saveRDS(pData, paste0(GEO_processed_data_dir, "GSE39345_pData_pseaned.rds"))

# GSE69657
keep = c(37)
pData = pData(esets[["GSE69657"]])[,keep,drop=F]
colnames(pData) = c("Response")
# Reformat the Response column. (Replace a with b.)
a = unique(pData$Response)
a = a[complete.cases(a)]
b = c("PD", "PR") # Here we will just replace all "noresponders" (that's not a typo) with "PD", even though some of the non-responders were SDs. 
names(b) = a
pData$Response = b[match(pData$Response, a)] # str_replace_all(pData$Response, b)
# Add the drugs columns.
pData$Drugs = "Leucovorin_Fluorouracil_Oxaliplatin"
# Add the individual drug columns.
pData$Drug1 = "Fluorouracil"
pData$Drug2 = "Oxaliplatin"
# Add the GSE. 
pData$GSE = "GSE69657"
## Re-order the columns.
pData = pData[,c("GSE", "Drugs", "Drug1", "Drug2", "Response")]
saveRDS(pData, paste0(GEO_processed_data_dir, "GSE69657_pData_pseaned.rds"))

```

### Merged Esets
```{r}
GSE_metadata = read.csv(GSE_metadata_filename)

# Create the merged pData. 
pData = data.frame(
  GSE = character(),
  GSM = character(),
  TissueType = character(),
  Drugs = character(),
  ActualCombo = character(),
  Response = character(),
  Timepoint = character(),
  Type = character(),
  OSTime = numeric(), 
  OSCensoring = integer(), 
  PFSTime = numeric(),
  PFSCensoring = integer(),
  stringsAsFactors = F
)

for(GSE in GSEs) {
  pData_i = readRDS(paste0(GEO_processed_data_dir, GSE, "_pData_pseaned.rds"))

  TissueType = GSE_metadata[GSE_metadata$GSE==GSE,"TissueType"]
  
  if(GSE %in% c("GSE18728", "GSE28702", "GSE39345", "GSE69657")) {
    OSTime = NA
    OSCensoring = NA
    PFSTime = NA
    PFSCensoring = NA
  } else {
    OSTime = 1
    OSCensoring = 1
    PFSTime = 1
    PFSCensoring = 1
  }
  
  Timepoint = ifelse(!("Timepoint" %in% colnames(pData_i)), NA, 1)
  Type = ifelse(!("Type" %in% colnames(pData_i)), NA, 1)
  
  #GSMs = unique(combos_with_controls[combos_with_controls$GSE==GSE,"GSM"])
  GSMs = pData_i %>% rownames
  for(GSM in GSMs) {
    # https://stackoverflow.com/questions/8753531/repeat-rows-of-a-data-frame-n-times/8753732
    Response = pData_i[rownames(pData_i)==GSM,"Response"]
    Timepoint = ifelse(is.na(Timepoint), NA, pData_i[rownames(pData_i)==GSM,"Timepoint"])
    Type = ifelse(is.na(Type), NA, pData_i[rownames(pData_i)==GSM,"Type"])
    OSTime = ifelse(is.na(OSTime), NA, pData_i[rownames(pData_i)==GSM,"OSTime"])
    OSCensoring = ifelse(is.na(OSCensoring), NA, pData_i[rownames(pData_i)==GSM,"OSCensoring"])
    PFSTime = ifelse(is.na(PFSTime), NA, pData_i[rownames(pData_i)==GSM,"PFSTime"])
    PFSCensoring = ifelse(is.na(PFSCensoring), NA, pData_i[rownames(pData_i)==GSM,"PFSCensoring"])
    Drugs = pData_i[rownames(pData_i)==GSM,"Drugs"]
    
    d = data.frame(
      GSE = GSE,
      GSM = GSM,
      TissueType = TissueType,
      Drugs = Drugs,
      Response = Response,
      Timepoint = Timepoint,
      Type = Type,
      OSTime = OSTime, 
      OSCensoring = OSCensoring, 
      PFSTime = PFSTime,
      PFSCensoring = PFSCensoring,
      stringsAsFactors = F
    )
    
    pData = rbind(pData, d)
    #pData = rbind(pData, do.call("rbind", replicate((n_rand + 1), d, simplify = FALSE)))
  }
}

# Save the data.
saveRDS(pData, pData_final_GEO_filename)

# Update 08/21/2021: rename columns to match those expected by calcNetworkScores.R
GEO_pData = readRDS(pData_final_GEO_filename)
GEO_pData = GEO_pData %>% dplyr::rename(Sample = GSM)
GEO_pData$Dataset = "GEO"
saveRDS(GEO_pData, pData_final_GEO_filename)

# Update 08/21/2021: convert all drug names to lower-case.
GEO_pData = readRDS(pData_final_GEO_filename)
GEO_pData$Drugs = GEO_pData$Drugs %>% str_to_lower()
saveRDS(GEO_pData, pData_final_GEO_filename)
```

## Molecular data
### Eset creation
```{r}
GSE_metadata = read.csv(GSE_metadata_filename)

# Make a cluster using n - 1 cores, where n = the number of cores on the computer. 
#ncores = detectCores() - 1
#cl = makeCluster(ncores)
# Register the parallel backend with the foreach package. 
#registerDoParallel(cl) 

for(GSE in GSEs) {
  # See if the eset already exists. If so, then skip it. 
  if(file.exists(paste0(GEO_processed_data_dir, GSE, "_eset_", preprocessing_method, "_", id_type, ".rds"))) next 
  
  print(paste0("Creating GEO set ", GSE, "."))
  
  # Create a file to hold the error messages for this GEO data set. 
  GSE_error_file = paste0(error_log_dir, "NCBI-GEO/", GSE, "_", preprocessing_method, "_", id_type, "_error_log.txt")
  file.create(GSE_error_file)
  
  GPL = as.character(GSE_metadata[GSE_metadata$GSE==GSE,"AnnotationDB"])
  annotation = as.character(GSE_metadata[GSE_metadata$GSE==GSE,"Annotation"])
  
  possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      # Read in the raw data and BG correct.
      if(GSE %in% c("GSE39345")) {
        exprs_bgcorrected = processLumi(GSE, is_GSE = T)
      } else {
        exprs_bgcorrected = processAffy(GSE, is_GSE = T)
      }
      # Perform log2 transformation. 
      exprs_log2 = log2transform(exprs_bgcorrected)
      # Perform YuGene normalization.
      exprs_YuGene = YuGene(exprs_log2)
      exprs_YuGene = exprs_YuGene[1:nrow(exprs_YuGene),1:ncol(exprs_YuGene)] # This step is needed because apparently YuGene() returns a 'YuGene' object, not a matrix, and using colnames() does something funky
      
    }, error=function(cond) {
      message(paste0("There was a problem processing GEO set ", GSE, ". Skipping this set."))
      message(cond)
    }
  )
  if(inherits(possibleError, "error")) {
    print(paste0("There was a problem processing GEO set ", GSE, ". Skipping this set."))
    
    # Write the error to the appropriate file. 
    fileConn = file(GSE_error_file)
    writeLines(paste0("There was a problem processing GEO set ", GSE, ". Skipping this set."), fileConn)
    close(fileConn)
    
  } 

  # if(!exists("eset")) next
  # Don't think we need this line for right now. ... 

  # Annotate the probes.
  if(GSE %in% c("GSE39345")) {
        exprs_annotated = annotateLumi(GSE, exprs_YuGene)
  } else {
        exprs_annotated = annotateAffy(GSE, exprs_YuGene, GPL, annotation)
  }

  eset = getGEO(GSE)[[1]] # We will need the pData from getGEO.
  # Remove suffixes etc. from the sample names. 
  sampleNames(eset) = base::gsub("\\..*$", "", sampleNames(eset))
  sampleNames(eset) = base::gsub("_.*$", "", sampleNames(eset))
  
  # GSE39345 only: change the column names of exprs_annotated to the GSMs from GEO. 
  if(GSE=="GSE39345") colnames(exprs_annotated) = colnames(exprs(eset))
    
  # Set the expression matrix of the eset to be exprs. 
  # For this one, since we're not just subsetting, we're creating an entirely new matrix, we will have to ... rebuild the eset. 囧rz
  pData = pData(eset)
  complete_samples = intersect(rownames(pData), colnames(exprs_annotated))
  pData = pData[rownames(pData) %in% complete_samples,,drop=F]
  exprs_annotated = exprs_annotated[,colnames(exprs_annotated) %in% complete_samples,drop=F]
  pData = pData[order(rownames(pData)),,drop=F] # Default for order() is ascending, which is what we want. 
  exprs_annotated = exprs_annotated[,order(colnames(exprs_annotated)),drop=F]
  experimentData = experimentData(eset)
  annotation = ifelse(annotation != "", annotation, GPL)
    
  # Make sure exprs has the correct row and column names. 
  if(identical(colnames(exprs_annotated), rownames(pData))) {
    rm(eset)
    eset = ExpressionSet(assayData=exprs_annotated, phenoData=as(pData, "AnnotatedDataFrame"), experimentData=experimentData, annotation=annotation)

    # Save the eset.
    saveRDS(eset, paste0(GEO_processed_data_dir, GSE, "_eset_", preprocessing_method, "_", id_type, ".rds"))

    # Write to the appropriate log file. 
    fileConn = file(GSE_error_file)
    writeLines(paste0("No errors for GEO set ", GSE, "."), fileConn)
    close(fileConn)
    
  } else {
    # Write the error to the appropriate log file. 
    fileConn = file(GSE_error_file)
    writeLines(paste0("Columns of the expression matrix and the column names of the expression matrix in the eset for ", GSE, " do not match. Skipping this data set."), fileConn)
    close(fileConn)
  }

  print(paste0("GEO set ", GSE, " created."))
  
  # Free up memory. 
  rm(eset)
  gc()
  
}
  
# Stop the cluster.
#stopCluster(cl)

```

### Big expression list
Originally we thought we could combine all the expression matrices from the esets we're using into one big one, for when we do differential expression analysis, but with different microarray platforms, we will not necessarily have the same genes in each individual matrix. So we will just stick with a list. 
```{r}
exprs_final_list = list()
for(GSE in GSEs) {
  eset = readRDS(paste0(GEO_processed_data_dir, GSE, "_eset_", preprocessing_method, "_", id_type, ".rds"))
  exprs_final_list[[GSE]] = exprs(eset) 
}
# Not used.
#exprs_final = do.call(cbind, exprs_final_list)

# Save.
saveRDS(exprs_final_list, paste0(GEO_processed_data_dir, "GEO_exprs_final_list.rds"))
rm(exprs_final_list)
```

## Differential expression analysis
```{r}
pData = readRDS(pData_final_GEO_filename)
GSEs = unique(pData$GSE)
exprs_list = readRDS(paste0(GEO_processed_data_dir, "GEO_exprs_final_list.rds"))
GSE_metadata = read.csv(GSE_metadata_filename)
colnames(GSE_metadata)[1] = "Set"

# Load deg_list if it exists. Otherwise, initiate it. 
if(file.exists(paste0(GEO_processed_data_dir, "GEO_deg_list", all_genes, ".rds"))) {
  deg_list = readRDS(paste0(GEO_processed_data_dir, "GEO_deg_list", all_genes, ".rds"))
} else {
  deg_list = list()
}

# Calculate differential expression.
for(GSE in GSEs) {
  print(paste0("Performing differential expression calculation for samples in data set ", GSE, "."))
  
  # Get the tissue type for the GSE.
  GSE_tissue_type = GSE_metadata %>% dplyr::filter(Set==GSE) %>% dplyr::select(TissueType) %>% unlist %>% as.character
  
  # Read in the processed RNA-seq data.
  exprs = exprs_list[[GSE]] %>% as.data.frame
  
  # Keep only the samples in pData. 
  samples = pData %>% dplyr::filter(GSE==GSE) %>% dplyr::select(GSM) %>% unlist() %>% as.character()
  exprs = exprs %>% dplyr::select(matches(samples))
  
  # Load the appropriate processed normal tissue. 
  # Check if the file exists. If it does, load it. If it doesn't, create it.
  if(file.exists(paste0(GTEx_processed_data_dir, "GTEx_normal_samples_processed_", GSE_tissue_type, ".rds"))) {
    normal_samples = readRDS(paste0(GTEx_processed_data_dir, "GTEx_normal_samples_processed_", GSE_tissue_type, ".rds"))
  } else {
    print(paste0("Error: the cancer ", cancer, " does not have associated normal tissue. Skipping this cancer."))
    next
  } 
  
  for(sample in colnames(exprs)) {
    print(paste0("Processing sample ", sample, "."))
    
    # Check if this sample is already in deg_list. 
    if(sample %in% names(deg_list)) {
      print(paste0("Sample ", sample, " is already in deg_list. Skipping this one."))
      next
    }
    
    # Load the expression matrix of the patient sample.
    patient_sample = exprs[,colnames(exprs)==sample,drop=F]
    # Transpose normal_samples matrix because GTEx_normal_samples_processed.rds contains the expression matrices with rows as samples and columns as genes. 
    normal_samples2 = t(normal_samples) 
  
    ######################################
    ## 1. DATA PREPARATION AND CLEANING ##
    ######################################
    # Make sure the genes are the same across both the patient samples and normal tissue. 
    common_genes = intersect(rownames(normal_samples2), rownames(patient_sample))
    normal_samples2 = normal_samples2[rownames(normal_samples2) %in% common_genes,]
    patient_sample = patient_sample[rownames(patient_sample) %in% common_genes,,drop=F]
    normal_samples2 = normal_samples2[order(rownames(normal_samples2)),]
    patient_sample = patient_sample[order(rownames(patient_sample)),,drop=F]
    identical(rownames(normal_samples2), rownames(patient_sample))

    ##############################################
    ## 2. DIFFERENTIAL GENE EXPRESSION ANALYSIS ##
    ##############################################
    # For each gene, get the changes in rank between normal and tumor. 
    tumor_rank = patient_sample[order(patient_sample[,1], decreasing = T),1,drop=F]
    tumor_rank = cbind(tumor_rank, 1:nrow(tumor_rank))
    tumor_rank = tumor_rank[order(rownames(tumor_rank)),]
  
    normal_avg = rowMeans(normal_samples2) %>% as.data.frame() #as.matrix(future_apply(normal_samples2, 1, mean)) # Because we have more than one normal sample, get the rank of the average expression of the gene across all the samples.
    normal_rank = normal_samples2[order(normal_avg[,1], decreasing = T),1,drop=F]
    normal_rank = cbind(normal_rank, 1:length(normal_rank))
    normal_rank = normal_rank[order(rownames(normal_rank)),]
  
    identical(rownames(normal_rank), rownames(tumor_rank))
    rank_dif = as.matrix(tumor_rank[,2] - normal_rank[,2])
    rownames(rank_dif) = rownames(normal_rank) # rank_dif is now a data frame with the ranks of each gene. 
  
    # Select DEGs as the genes with rank differences >= 2SDs +/- the mean. 
    if(deg_type=="All") {
      deg_names = rownames(rank_dif)
    } else {
      lower_bound = mean(rank_dif) - deg_cutoff*sd(rank_dif)
      upper_bound = mean(rank_dif) + deg_cutoff*sd(rank_dif)
      upreg_degs = rownames(rank_dif[rank_dif[,1] > upper_bound,,drop=F])
      downreg_degs = rownames(rank_dif[rank_dif[,1] < lower_bound,,drop=F])
      deg_names = c(upreg_degs, downreg_degs)
    }
  
    # Create the table of differentially expressed genes. 
    degs = rank_dif[rownames(rank_dif) %in% deg_names,,drop=F]
  
    # Create the table of intensities.
    intensities = patient_sample[rownames(patient_sample) %in% deg_names,,drop=F]
    identical(rownames(intensities), rownames(degs)) # These are the two tables we'll be adding to deg_list[[sample]], so make sure they match. 

    # Add the table of differentially expressed genes to the list. 
    deg_list[[sample]][["DEGs"]] = degs
    deg_list[[sample]][["Intensity"]] = intensities
    
    # Remove all the samples expression matrices and clean up the memory. 
    rm(patient_sample, normal_samples2)
    gc()
  }
  
}

# Save the list.
saveRDS(deg_list, paste0(GEO_processed_data_dir, "GEO_deg_list", all_genes, ".rds"))
```

## Network construction 
```{r}
# 08/03/2021:
# OK, I know this is weird, but the DEG list RDS file will always be named with "all_genes," so we need to set that before loading the file. 
# But once we load the file, we will need to change the deg_type back to whatever it is it will actually be. This is due to a change in how we processed the differentially expressed genes. Back then, we actually removed the non-DE genes before creating the network. Now we just keep all the genes and mark which ones are the DE genes. 
deg_type = "All"
all_genes = ifelse(deg_type == "All", "_all_genes", "") 

# Load the list of DEG genes for each patient sample if it is not loaded already. 
deg_list = readRDS(paste0(folder_generator(data_dir, data_source = "GEO", data_type = "Expression", processing_stage = "Processed"), "GEO_deg_list", all_genes, ".rds"))

# Change to 2SD.
deg_type = "SD"
if(deg_type == "All")  {
  all_genes = "all_genes"
} else if(deg_type == "SD") {
  all_genes = paste0(deg_cutoff, "SD")
} else {
  all_genes = paste0(deg_type)
}

# https://www.biostars.org/p/190137/#222651
# Instantiate STRINGdb reference class. We will set a very stringent threshold (default 400) and of course choose humans as our species. Do it outside the for() loop so we don't have to instantiate it every time. 
string_db = STRINGdb$new(version="10", species=9606, score_threshold=400, input_directory=paste0(folder_generator(data_dir, data_source = "STRING-DB", data_type = "Network", processing_stage = "Raw")))
#system.time({
for(sample in names(deg_list)) {
  if(file.exists(paste0(folder_generator(data_dir, data_source = "GEO", data_type = "Expression", processing_stage = "Processed"), "Disease_networks/", sample, "_disease_network_", all_genes, ".rds"))) next
  
  print(paste0("Processing sample ", sample, "."))
  
  # Set up a list to hold the network, the mapping, and the hits. 
  disease_network_list = list()
  
  # Differential gene expression data.
  de_genes = as.data.frame(cbind(deg_list[[sample]][["DEGs"]], deg_list[[sample]][["Intensity"]]))
  # Add gene names and rename columns.
  de_genes$GeneSymbol = rownames(de_genes)
  colnames(de_genes)[1] = "RankChange"
  colnames(de_genes)[2] = "Intensity"
  # Choose genes for disease module by cutoff.
  rank_dif = de_genes$RankChange
  lower_bound = mean(rank_dif) - deg_cutoff*sd(rank_dif)
  upper_bound = mean(rank_dif) + deg_cutoff*sd(rank_dif)
  upreg_degs = rownames(de_genes[de_genes[,1] > upper_bound,,drop=F])
  downreg_degs = rownames(de_genes[de_genes[,1] < lower_bound,,drop=F])
  deg_names = c(upreg_degs, downreg_degs)
  de_genes$DiseaseModuleGene = ifelse(de_genes$GeneSymbol %in% deg_names, "Y", "N")
  
  # Map gene names from the table of differentially expressed genes to STRING identifiers. 
  #system.time({
  mapped = string_db$map(de_genes, "GeneSymbol", removeUnmappedRows=TRUE)
  #}) # Time: user system elapsed 7.412   0.248   7.978 
  hits = mapped$STRING_id # These are the hits. To select the top n hits, simply subset using [1:n]. Because we start with ~150 genes, which should be enough to make a decent PPI network, we will just use all of these genes without subsetting. 
    # Plot the network, showing the number of proteins (genes), the number of interactions, and the p-value (probability that we would get, by chance, as many interactions as we did in this network.)
    # string_db$plot_network(hits)

  # As of 05/17/2021, we no longer have to create a subnetwork. ... I think.
  # Create an iGraph network object. This is the disease network, which we can now run iGraph functions on.
  #system.time({
  #network = string_db$get_subnetwork(hits) # user system elapsed 0.017   0.066   0.192
  #})
  # Save network to list.
  #disease_network_list[["Network"]] = network 
  disease_network_list[["Map"]] = mapped
  disease_network_list[["Hits"]] = hits
  
  # New addition 11/01/2020; need the intensity for the WINTHER score.
  # Add intensity.
  intensity = as.data.frame(deg_list[[sample]][["Intensity"]])
  intensity = intensity[rownames(intensity) %in% mapped$GeneSymbol,,drop=F]
  colnames(intensity) = "Intensity"
  disease_network_list[["Intensity"]] = intensity
  
  # New addition 03/09/2021; need to know whether the gene is part of the disease module.
  # Make sure the gene names from de_genes matches the gene names in disease_disease_network_list. Or just save the gene names from de_genes.
  disease_network_list[["DiseaseModuleGene"]] = de_genes[,3:4]
  
  # Save the list to RDS.
  saveRDS(disease_network_list, paste0(folder_generator(data_dir, data_source = "GEO", data_type = "Expression", processing_stage = "Processed"), "Disease_networks/", sample, "_disease_network", all_genes, ".rds"))
  
  # Clean up.
  rm(disease_network_list)
  gc()
}
#})
```

## Drug data
### Creation of drug list
```{r}
GEO_pData = readRDS(filename_generator(data_dir, data_source = "GEO", data_type = "pData", extension = ".rds", processing_stage = "Processed"))
GEO_drugs = GEO_pData$Drugs %>% str_split("_") %>% unlist %>% as.character %>% unique
# length(GEO_drugs) == length(unique(GEO_drugs))

# Save to file. 
write.table(GEO_drugs, filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", extension = ".tsv", processing_stage = "Raw", additional_info = "names"), row.names = F, col.names = F, quote = F)
```

### CTD
#### Filtering
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Load the CTD data.
GEO_drug_cgixns_CTD_raw = read.csv(paste0(folder_generator(data_dir, data_source = "GEO", data_type = "Drugs", processing_stage = "Processed"), "CTD_chem_cgixns_1654210413218.csv"))

# Filter drugs to include the following: 1) has data, 2) is human, 3) has no cotreatment stuff, 4) includes information on increasing/decreasing activity/expression (not just "affects.")
GEO_drug_cgixns_CTD_filtered = GEO_drug_cgixns_CTD_raw %>% dplyr::filter(!base::grepl("found", Input) & 
                                          OrganismID == "9606" &
                                          !base::grepl("reaction", InteractionActions) & 
                                          !base::grepl("response", InteractionActions) & 
                                          !base::grepl("cotreatment", InteractionActions) &
                                          (
                                            base::grepl("increases\\^activity", InteractionActions) |
                                              base::grepl("increases\\^expression", InteractionActions) |
                                              base::grepl("decreases\\^activity", InteractionActions) |
                                              base::grepl("decreases\\^expression", InteractionActions)
                                            )
                                        )

# Save the filtered data.
GEO_drug_cgixns_CTD_filtered_filename = paste0(folder_generator(data_dir, data_source = "GEO", data_type = "Drugs", processing_stage = "Processed"), "GEO_CTD_chem_cgixns_1654210413218_filtered.rds")
saveRDS(GEO_drug_cgixns_CTD_filtered, GEO_drug_cgixns_CTD_filtered_filename)
```

### DrugBank
DrugBank data was downloaded as an XML file from [...] on [...]. The data was migrated to a MySQL database for easier retrieval. See the Supplemental Data section for detailed methods. 
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Update 08/16/2021: now including even the drugs without KEGG pathways.
GEO_drugs_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
GEO_drugs = read.csv(GEO_drugs_filename)
drugs = GEO_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(drug_name) %>% unlist %>% unique %>% str_to_lower
DB_ids = GEO_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(DB_id) %>% unlist %>% unique

GEO_drug_target_data_DrugBank_tmp = data.frame(
  Drug = character(),
  Target = character(),
  Effect = numeric(),
  stringsAsFactors = F
)

# Get the targets of the drugs from the MySQL database. 

# Get all the possible pharmacological actions. 
#query = "SELECT PharmacologicalAction FROM DrugTargets.DrugBank;"
#res = dbSendQuery(DrugTargetsDB, query)
#pharm_actions = dbFetch(res) %>% unlist() %>% unique()
#View(pharm_actions)
#dbClearResult(res)
inhibitory_actions = c("inhibitor", "antagonist", "antibody", "inverse agonist", "inhibitory allosteric modulator", "negative modulator", "blocker", "weak inhibitor", "downregulator", "partial antagonist", "suppressor", "inactivator", "degradation", "incorporation into and destabilization", "inhibition of synthesis")
activating_actions = c("activator", "agonist", "stimulator", "potentiator", "inducer", "positive allosteric modulator", "partial agonist", "positive modulator")
        
# https://programminghistorian.org/en/lessons/getting-started-with-mysql-using-r#create-an-r-script-that-connects-to-the-database
# Make the connection to the MySQL database. 
# The connection method below uses a password stored in a settings file.
user_password = "Kibougaaru2020"
DrugTargetsDB = dbConnect(RMariaDB::MariaDB(), 
                          user='root', 
                          password=user_password, 
                          dbname='DrugTargets', 
                          host='localhost')
dbListTables(DrugTargetsDB)

# Make the queries. 
for(db_id in DB_ids) {
  query = paste0("SELECT DrugName, TargetName, Organism, PharmacologicalAction FROM DrugTargets.DrugBank WHERE DrugBankID = '", db_id, "';")
  res = dbSendQuery(DrugTargetsDB, query)
  drug_data = dbFetch(res)
  dbClearResult(res)
  
  if(nrow(drug_data) < 1) next
  
  # Get the drug name.
  drug_name = GEO_drugs %>% dplyr::filter(DB_id==db_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  
  # Select the entries with "Human" in the Organism column.
  drug_data = drug_data %>% dplyr::filter(base::grepl("Human", Organism))
  
  # For each target, get the effect.
  for(target in unique(drug_data$TargetName)) {
    # Get the number of effects.
    drug_actions = drug_data %>% dplyr::filter(TargetName == target) %>% dplyr::select(PharmacologicalAction) %>% unique()
    
    if(length(drug_actions) > 0) {
      # Convert the pharmacological actions to -1, 0, or 1. 
      inhibitory = ifelse(sum(drug_actions %in% inhibitory_actions) > 0, T, F)
      activating = ifelse(sum(drug_actions %in% activating_actions) > 0, T, F)
      if(inhibitory & !activating) {
        drug_action_numeric = -1
      } else if(activating & !inhibitory) {
        drug_action_numeric = 1
      } else {
        drug_action_numeric = 0
      }
        
      # Add to the table.
      GEO_drug_target_data_DrugBank_tmp = rbind(GEO_drug_target_data_DrugBank_tmp, data.frame(
        Drug = drug_name,
        Target = target,
        Effect = drug_action_numeric,
        stringsAsFactors = F
      ))
    }
  }
}
# Disconnect
dbDisconnect(DrugTargetsDB)

# Save the temporary table.
GEO_drug_target_data_DrugBank_tmp_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "DrugBank", extension = ".rds", processing_stage = "Processed", additional_info = "target_data_tmp")
saveRDS(GEO_drug_target_data_DrugBank_tmp, GEO_drug_target_data_DrugBank_tmp_filename)

# Make sure all the drug names in GEO_drug_target_data_DrugBank_tmp match the names in drugs. (We will need to do some manual correction, more than likely.)
setdiff(unique(GEO_drug_target_data_DrugBank_tmp$Drug), drugs)
setdiff(drugs, unique(GEO_drug_target_data_DrugBank_tmp$Drug))

# Convert the targets in GEO_drug_target_data_DrugBank_tmp to ENTREZ IDs.
hs = org.Hs.eg.db
keys = GEO_drug_target_data_DrugBank_tmp$Target %>% as.character()
x = AnnotationDbi::select(hs, 
               keys = keys,
               columns = c("SYMBOL", "ENTREZID"),
               keytype = "SYMBOL") %>% .[complete.cases(.),] %>% distinct()

# Remove any ENTREZIDs that don't have corresponding KEGG entries.
entrez_no_kegg = c()
for(entrez_id in unique(x$ENTREZID)) {
  print(paste0("Checking if gene ", entrez_id, " has a KEGG entry."))
  
  possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
        entrez_test = keggGet(paste0("hsa:", entrez_id))
    }, error=function(cond) {
        message(cond)
    }
    )
  if(inherits(possibleError, "error") | !exists("entrez_test")) {
      entrez_no_kegg = c(entrez_no_kegg, entrez_id)
  }
  
  rm(entrez_test)
}
x = x %>% dplyr::filter(!(ENTREZID %in% entrez_no_kegg))
# Convert to ENTREZ.
# https://stackoverflow.com/a/3905442
a = x$SYMBOL
b = x$ENTREZID
GEO_drug_target_data_DrugBank_tmp$Target = b[match(GEO_drug_target_data_DrugBank_tmp$Target, a)]
GEO_drug_target_data_DrugBank = GEO_drug_target_data_DrugBank_tmp %>% .[complete.cases(.),]

# We won't need to convert to list to match CTD format until we merge the DrugBank and KEGG data.

# Merge.
#GEO_drug_target_data_DrugBank = rbind(GEO_drug_target_data_DrugBank, GEO_drug_target_data_DrugBank_tmp)

# Change everything to sentence caps. 
#GEO_drug_target_data_DrugBank$Drug = str_to_sentence(GEO_drug_target_data_DrugBank$Drug)

# Filter out targets that already exist (i.e. keep only unique rows.)
#GEO_drug_target_data_DrugBank = GEO_drug_target_data_DrugBank %>% distinct()

# 11 Aug 2021: replace venotoclax -> venetoclax.
GEO_drug_target_data_DrugBank$Drug = GEO_drug_target_data_DrugBank$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")

# Save.
# Update 08/16/2021: now including even the drugs without KEGG pathways.
GEO_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
write.table(GEO_drug_target_data_DrugBank, GEO_drug_target_data_DrugBank_filename, sep=",", row.names=F)
```

### KEGG
KEGG data was downloaded using the KEGGREST package in R (3.6.3.) Since KEGG does not provide the pharmacological effects of drugs on the target (e.g. whether the drug acts as an antagonist or agonist), 

```{r echo = FALSE, eval=TRUE, include=FALSE}
GEO_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
GEO_drug_target_data_DrugBank = read.csv(GEO_drug_target_data_DrugBank_filename)

GEO_drugs_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
GEO_drugs = read.csv(GEO_drugs_filename, stringsAsFactors = F)
kegg_ids = GEO_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(KEGG_id) %>% unlist %>% unique %>% .[!is.na(.)]

GEO_drug_target_data_KEGG = data.frame(
  Drug = character(),
  Target = character(),
  Effect = character()
)
# Table to hold the mutant/fusion protein targets. 
GEO_drug_target_data_KEGG_v = data.frame( # v = variation. 
  Drug = character(),
  Target = character()
)
for(kegg_drug_id in kegg_ids) {
  drug = GEO_drugs %>% dplyr::filter(KEGG_id==kegg_drug_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  print(paste0("Getting the KEGG targets for drug ", drug, "."))

    # Get the pathways affected.
  if(!is.null(kegg_drug_id) & !is.na(kegg_drug_id)) {
    
    possibleError = tryCatch(
    {
      kegg_pathways = keggGet(kegg_drug_id)[[1]]$TARGET
    }, error=function(cond) {
      message(paste0("There was a problem retrieving the drug-target data from KEGG for the drug ", drug, ":"))
      message(cond)
    }
  )
  
    if(inherits(possibleError, "error")) {
      print(paste0("There was a problem retrieving the drug-target data from KEGG for the drug ", drug, ":"))
      next
    }
  
    else {
      if(class(kegg_pathways)=="list") {
        # Get the mutant/fusion protein targets and add them to a separate table. 
        kegg_targets = kegg_pathways$TARGET
        v_targets = kegg_targets %>% regexPipes::grep("\\*", value = T) %>% str_split(" ") %>% unlist %>% regexPipes::grep("\\[HSA\\:", value = T) %>% regexPipes::gsub("\\[HSA\\:", "") %>% regexPipes::gsub("\\]", "") # This assumes that drugs can't target both a mutant and non-mutant form. ... 
        GEO_drug_target_data_KEGG_v = rbind(GEO_drug_target_data_KEGG_v, data.frame(
          Drug = rep(drug, length(v_targets)),
          Target = v_targets
        ))
        
        # Now get the rest of the targets from the pathways. 
        kegg_pathways = kegg_pathways$PATHWAY
      
        # Keep only the signal-transduction and disease-associated pathways (hsa03xxx, hsa04xxx and hsa05xxx.) 
        kegg_pathway_names = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("[[:space:]]+.+$", "")
      
        # Get the targets of the drug and filter the targets to include only the ones that are not already present in the DB table.
        drug_targets_DrugBank = GEO_drug_target_data_DrugBank %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist
        targets = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("hsa0[345][[:digit:]]{3}", "") %>% regexPipes::gsub("[[:space:]]+.+$", "") %>% regexPipes::gsub("[()]", "") %>% str_split("\\+") %>% unlist() %>% unique() #%>% .[!(. %in% drug_targets_DrugBank)] As of 2022-06-05, we are no longer removing the drug targets present in the DrugBank table at this step. We will wait until the "Merging DrugBank and KEGG" step to do that, because we need all the KEGG targets present when we do the TRRUST stuff. 
      
        # Add to the table.
        GEO_drug_target_data_KEGG = rbind(GEO_drug_target_data_KEGG, data.frame(
          Drug = rep(drug, length(targets)),
          Target = targets,
          Effect = rep(-1, length(targets)) # I'm assuming most of the drugs are inhibitors. ... 
        ))
      }
    }
  } 
  
}

# Keep only unique rows.
GEO_drug_target_data_KEGG = GEO_drug_target_data_KEGG %>% distinct()

# For the most part, the drugs are inhibitors, but for two drug-target pairs, fulvestrant and 2100, and phenformin and 5563, we will have to manually update them. 
# ... No phenformin in GEO, though. That's in GDSC. 
GEO_drug_target_data_KEGG = GEO_drug_target_data_KEGG
GEO_drug_target_data_KEGG[GEO_drug_target_data_KEGG$Drug=="fulvestrant" & GEO_drug_target_data_KEGG$Target=="2100","Effect"] = 0
#GEO_drug_target_data_KEGG[GEO_drug_target_data_KEGG$Drug=="phenformin" & GEO_drug_target_data_KEGG$Target=="5563","Effect"] = 1

# 11 Aug 2021: replace venotoclax -> venetoclax.
GEO_drug_target_data_KEGG$Drug = GEO_drug_target_data_KEGG$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")
GEO_drug_target_data_KEGG_v$Drug = GEO_drug_target_data_KEGG_v$Drug %>%  regexPipes::gsub("venotoclax", "venetoclax")

# Remove the following drugs from the _v table, since they do not target mutant but overexpressed/fusion proteins: trastuzumab, lapatinib, crizotinib. Well, maybe keep crizo in the _v table for consistency? It looks like we did that for the network scores? 
#GEO_drug_target_data_KEGG_v$Effect = -1
#for(drug in c("Lapatinib")) {
#  # Add the appropriate row to non-_v table.
#  GEO_drug_target_data_KEGG = rbind(GEO_drug_target_data_KEGG, #GEO_drug_target_data_KEGG_v %>% dplyr::filter(Drug==drug))
#}
#GEO_drug_target_data_KEGG_v = GEO_drug_target_data_KEGG_v %>% dplyr::filter(!(Drug %in% c("Lapatinib")))

# Save. 
GEO_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
#GEO_drug_target_data_KEGG_v_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_data", processing_stage = "Processed")
write.table(GEO_drug_target_data_KEGG, GEO_drug_target_data_KEGG_filename, sep=",", row.names=F)
#write.table(GEO_drug_target_data_KEGG_v, GEO_drug_target_data_KEGG_v_filename, sep=",", row.names=F)
```

### Merging DrugBank and KEGG
```{r echo = FALSE, eval=TRUE, include=FALSE}
# Load the Drugbank and KEGG target information.
GEO_drug_target_data_DrugBank_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "DrugBank", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
GEO_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
#GEO_drug_target_data_KEGG_v_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_data", processing_stage = "Processed")
GEO_drug_target_data_KEGG = read.csv(GEO_drug_target_data_KEGG_filename)
#GEO_drug_target_data_KEGG_v = read.csv(GEO_drug_target_data_KEGG_v_filename)
GEO_drug_target_data_DrugBank = read.csv(GEO_drug_target_data_DrugBank_filename)

# Merge the Drugbank and KEGG target tables. 
GEO_drug_target_data_DrugBank_KEGG = rbind(GEO_drug_target_data_DrugBank, GEO_drug_target_data_KEGG) %>% distinct()
# Consolidate duplicate rows (i.e., rows with the same target but different effects).
# https://stackoverflow.com/a/10180178
GEO_drug_target_data_DrugBank_KEGG = GEO_drug_target_data_DrugBank_KEGG %>% dplyr::select(Drug, Target, Effect) %>% ddply(.(Drug, Target), numcolwise(sum))
#rownames(GEO_drug_target_data_DrugBank_KEGG) = GEO_drug_target_data_DrugBank_KEGG$Target
# Because of the consolidation in the previous step, we might have effect values > 1 or < -1. Set the ceiling and floor to be 1 and -1, respectively. 
GEO_drug_target_data_DrugBank_KEGG$Effect = ifelse(GEO_drug_target_data_DrugBank_KEGG$Effect > 1, 1, GEO_drug_target_data_DrugBank_KEGG$Effect)
GEO_drug_target_data_DrugBank_KEGG$Effect = ifelse(GEO_drug_target_data_DrugBank_KEGG$Effect < -1, -1, GEO_drug_target_data_DrugBank_KEGG$Effect)

# Remove all the entries from the Drugbank targets that are also present in the variant KEGG table (i.e. the ones that have mutations/fusions.)
#GEO_drug_target_data_DrugBank_KEGG = GEO_drug_target_data_DrugBank_KEGG %>% .[!(paste(.$Drug, .$Target, sep="_") %in% paste(GEO_drug_target_data_KEGG_v$Drug, GEO_drug_target_data_KEGG_v$Target, sep="_")),]

# Convert from Entrez ID to HUGO gene symbol. 
hs = org.Hs.eg.db
keys = GEO_drug_target_data_DrugBank_KEGG$Target %>% as.character
x = AnnotationDbi::select(hs, 
                          keys = keys,
                          columns = c("SYMBOL", "ENTREZID"),
                          keytype = "ENTREZID") %>% .[complete.cases(.),]
GEO_drug_target_data_DrugBank_KEGG$Target = x %>% .[match(GEO_drug_target_data_DrugBank_KEGG$Target, .$ENTREZID),] %>% .$SYMBOL

# Split the dataframe into a list, to match the CTD drug-target-data format and the format that most of the calcNetworkScores() functions use. 
GEO_drug_target_data_DrugBank_KEGG = split(GEO_drug_target_data_DrugBank_KEGG , f = GEO_drug_target_data_DrugBank_KEGG$Drug)

# Remove all entries in the list whose tables have 0 rows. (28 June 2021.)
for(entry in names(GEO_drug_target_data_DrugBank_KEGG)) {
  if(nrow(GEO_drug_target_data_DrugBank_KEGG[[entry]]) < 1) {
    GEO_drug_target_data_DrugBank_KEGG[[entry]] = NULL
  } 
}

# Save.
GEO_drug_target_data_DrugBank_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "DrugBank_KEGG", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(GEO_drug_target_data_DrugBank_KEGG, GEO_drug_target_data_DrugBank_KEGG_filename)
```

### TRRUST
#### Target pathways from KEGG
```{r}
# From KEGG, get the pathways targeted by each drug. 
GEO_drugs_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", extension = ".csv", processing_stage = "Processed", additional_info = "ids")
GEO_drugs = read.csv(GEO_drugs_filename, stringsAsFactors = F)
drugs = GEO_drugs %>% dplyr::select(drug_name) %>% unlist %>% unique %>% str_to_lower
GEO_drug_target_pathway_data_KEGG = data.frame(
  Drug = character(),
  PathwayName = character(),
  PathwayID = character(),
  Target = character(),
  stringsAsFactors = F
)
#GEO_drug_target_pathway_data_KEGG_v = data.frame(
#  Drug = character(),
#  PathwayName = character(),
#  PathwayID = character(),
#  Target = character(),
#  stringsAsFactors = F
#)
kegg_ids = GEO_drugs %>% dplyr::filter(exclude != "Y") %>% dplyr::select(KEGG_id) %>% unlist %>% unique %>% .[!is.na(.)]
for(kegg_drug_id in kegg_ids) {
  drug = GEO_drugs %>% dplyr::filter(KEGG_id==kegg_drug_id) %>% dplyr::select(drug_name) %>% unlist %>% str_to_lower
  print(paste0("Getting KEGG pathways for drug ", drug, "."))
  
  if(!is.null(kegg_drug_id)) {
    kegg_drug_id = kegg_drug_id %>% str_trim
    kegg_pathways = keggGet(kegg_drug_id)[[1]]$TARGET
    
    if(class(kegg_pathways)=="list") {
      # Get the targets of the drug.
      kegg_targets = kegg_pathways$TARGET
      
      # Get the mutant/fusion protein targets and add them to a separate table. 
      #v_targets = kegg_targets %>% regexPipes::grep("\\*", value = T) %>% str_split(" ") %>% unlist %>% regexPipes::grep("\\[HSA\\:", value = T) %>% regexPipes::gsub("\\[HSA\\:", "") %>% regexPipes::gsub("\\]", "") # This assumes that drugs can't target both a mutant and non-mutant form. ... 
      #GEO_drug_target_pathway_data_KEGG_v = rbind(GEO_drug_target_pathway_data_KEGG_v, data.frame(
       # Drug = rep(drug, length(v_targets)),
       # PathwayName = rep(NA, length(v_targets)),
       # PathwayID = rep(NA, length(v_targets)),
        #Target = v_targets
      #))
      
      # Now get the rest of the targets from the pathways. 
      kegg_pathways = kegg_pathways$PATHWAY
      
      # Get the names of the pathways.
      kegg_pathway_names = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>%  regexPipes::gsub("^[[:alnum:]]+\\(.*\\)[[:space:]]*", "") %>% str_to_upper() %>% regexPipes::gsub("[[:space:]]", "_") %>% paste0("KEGG_", .)
      # Get the KEGG IDs of the pathways.
      KEGG_pathway_ids = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("\\(.+$", "")
      # Get the targets in those pathways. 
      kegg_pathway_targets = kegg_pathways %>% regexPipes::grep("hsa0[345]", value = T) %>% regexPipes::gsub("hsa0[345][[:digit:]]{3}\\(", "") %>% regexPipes::gsub("\\).+$", "") %>% str_split("\\+")
      if(length(kegg_pathway_targets) < 1) {
        print(paste0("There are no applicable KEGG pathways for drug ", drug, ". Skipping to the next one."))
        next
      }
      names(kegg_pathway_targets) = KEGG_pathway_ids
      
      # Create the vectors for the drugs, pathway names, pathway IDs, and targets.
      target_vector = kegg_pathway_targets %>% unlist
      pathway_id_vector = c()
      for(name in names(kegg_pathway_targets)) {
        pathway_id_vector = c(pathway_id_vector, rep(name, length(kegg_pathway_targets[[name]])))
      }
      pathway_name_vector = c()
      for(i in 1:length(kegg_pathway_targets)) {
        pathway_name_vector = c(pathway_name_vector, rep(kegg_pathway_names[i], length(kegg_pathway_targets[[i]])))
      }
  
      if(length(kegg_pathway_names)==length(KEGG_pathway_ids)) {
        GEO_drug_target_pathway_data_KEGG = rbind(GEO_drug_target_pathway_data_KEGG, data.frame(
          Drug = rep(drug, length(pathway_name_vector)),
          PathwayName = pathway_name_vector,
          PathwayID = pathway_id_vector,
          Target = target_vector,
          stringsAsFactors = F
        ))
      } # End if(length(kegg_pathway_names)==length(KEGG_pathway_ids)). 
    } # End if(class(kegg_pathways)=="list"). 
  } # End if(!is.null(kegg_drug_id)). 

}

# Currently, the normal target table has ALL the records. We will remove from it all the mutant protein targets. (This is different from what we did in the KEGG protein target section.)
# Add RecordID field to both _v and normal target tables.
GEO_drug_target_pathway_data_KEGG$RecordID = paste(GEO_drug_target_pathway_data_KEGG$Drug, GEO_drug_target_pathway_data_KEGG$Target, sep = "_")
#GEO_drug_target_pathway_data_KEGG_v$RecordID = paste(GEO_drug_target_pathway_data_KEGG_v$Drug, GEO_drug_target_pathway_data_KEGG_v$Target, sep = "_")

# Remove the following drugs from the _v table, since they do not target mutant but overexpressed/fusion proteins: trastuzumab, lapatinib, crizotinib.
#GEO_drug_target_pathway_data_KEGG_v = GEO_drug_target_pathway_data_KEGG_v %>% dplyr::filter(!(Drug %in% c("Trastuzumab", "Lapatinib", "Crizotinib")))
# Now filter the normal table by the _v table.
# But first save the _v stuff!
#tmp = GEO_drug_target_pathway_data_KEGG %>% dplyr::filter(RecordID %in% GEO_drug_target_pathway_data_KEGG_v$RecordID)
#GEO_drug_target_pathway_data_KEGG = GEO_drug_target_pathway_data_KEGG %>% dplyr::filter(!(RecordID %in% GEO_drug_target_pathway_data_KEGG_v$RecordID))
#GEO_drug_target_pathway_data_KEGG_v = tmp

#rm(tmp)

# Save to file.
GEO_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
#GEO_drug_target_pathway_data_KEGG_v_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "v_target_pathway_data", processing_stage = "Processed")
write.table(GEO_drug_target_pathway_data_KEGG, GEO_drug_target_pathway_data_KEGG_filename, sep=",", row.names=F)
#write.table(GEO_drug_target_pathway_data_KEGG_v, GEO_drug_target_pathway_data_KEGG_v_filename, sep=",", row.names=F)
```

#### Genes downstream of each drug target
```{r}
# Get all the targeted pathways. 
GEO_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
GEO_drug_target_pathway_data_KEGG = read.csv(GEO_drug_target_pathway_data_KEGG_filename)
# We no longer have to remove drug-target-pathway combinations involving mutant/fusion proteins in this step, since we did it in the last one. 08/21/2021.
KEGG_pathway_ids = GEO_drug_target_pathway_data_KEGG$PathwayID %>% unique() 
# Get all the direct targets of the drugs.
GEO_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")
GEO_drug_target_data_KEGG = read.csv(GEO_drug_target_data_KEGG_filename)
GEO_drug_targets_KEGG = GEO_drug_target_data_KEGG$Target %>% unique() %>% paste0("hsa:", .)

# For each pathway, get the nodes downstream of each target. 
GEO_drug_target_downstream_node_data_KEGG = data.frame(
  Pathway = character(),
  Target = character(),
  DownstreamNodes = character(),
  Effects = numeric(),
  stringsAsFactors = F
)
for(pathway in KEGG_pathway_ids) {
  print(paste0("Working on pathway ", pathway, "."))
  
  # Load the KGML file. 
  #kgml = keggGet("hsa04010", option = "kgml")
  #parsed_kgml = parseKGML(kgml)
  #pathway_graph = KEGGpathway2Graph(parsed_kgml)
  kgml = keggGet(pathway, option = "kgml")

  # Convert the KGML file into an iGraph object.
  # First convert to a graphNEL object.
  graphNEL = parseKGML2Graph(kgml, expandGenes = T, genesOnly = F) # PI3K signaling occurs through PIP3, which is a lipid. ... 
  #graphNEL_layout = layoutGraph(graphNEL)
  #renderGraph(graphNEL_layout)
  
  # For MAPK pathway only--create a directed edge between the RTK node and the GRB2 node, and between the GRB2 node and the SOS node. 
  rtk_nodes = c("hsa:1436","hsa:1956","hsa:1969","hsa:2064","hsa:2065","hsa:2066","hsa:2260","hsa:2261","hsa:2263","hsa:2264","hsa:2321","hsa:2322","hsa:2324","hsa:3480","hsa:3643","hsa:3791","hsa:3815","hsa:4233","hsa:4804","hsa:4914","hsa:4915","hsa:5156","hsa:5159","hsa:7010")
  grb2_node = "hsa:2885"
  sos_nodes = c("hsa:6654","hsa:6655")
  if(pathway=="hsa04010") {
    graphNEL = addEdge(rtk_nodes, grb2_node, graphNEL, 1)
    graphNEL = addEdge(grb2_node, sos_nodes, graphNEL, 1)
  }
  
  # Next, weight the edges by whether they are inhibitory or activating. 
  # @_@
  # For each edge in the graph (pathway_graph or graphNEL), use the KEGG edge data to determine whether it is an activating or inhibitory edge. If it is activating, leave it alone. Otherwise, set it to -1. 
  kegg_edge_data = getKEGGedgeData(graphNEL)
  kegg_edges = edges(graphNEL)
  kegg_edge_weights = edgeWeights(graphNEL)
  # Generate a list of all the edges. 
  all_edges = c()
  for(first_node in names(kegg_edges)) {
    if(length(kegg_edges[[first_node]]) > 0) all_edges = c(all_edges, paste0(first_node, "~", kegg_edges[[first_node]]))
  }
        
  for(edge in all_edges) {
    first_node = str_split(edge, "~") %>% unlist %>% .[1]
    second_node = str_split(edge, "~") %>% unlist %>% .[2]
    edge_data = getKEGGedgeData(graphNEL)[[edge]] # This will be NULL for the edges we added on, since we only added the edges, not any metadata. 
    if(!is.null(edge_data)) {
      if(length(getSubtype(edge_data)) > 0) {
        edge_subtype = getName(getSubtype(getKEGGedgeData(graphNEL)[[edge]])$subtype) # "activation" or "inhibition".
        } else {
          edge_subtype = "activation"
        }
    } else {
        edge_subtype = "activation"
      }
    
    if(edge_subtype=="inhibition") kegg_edge_weights[[first_node]][second_node] = -1
  }
  #edgeWeights(graphNEL) = kegg_edge_weights
  # Above line of code doesn't work--see comment below. 
  
  # Then convert to iGraph.
  igraph = graph_from_graphnel(graphNEL, name = TRUE, weight = TRUE,
  unlist.attrs = TRUE)
  # Set the weights of the iGraph to be kegg_edge_weights.
  # (We can't change the weights of a graphNEL object, apparently, so we have to do it this way. ... Of course, this assumes that the edges are in the same order in igraph as they are once you unlist kegg_edge_weights. ... If we ever update any of the packages used here, we will have to 2x check this.)
  edge_attr(igraph)$weight = unlist(kegg_edge_weights)
  
  # Get the downstream nodes of the target of the drug. 
  # https://rdrr.io/github/robertness/lucy/man/get_downstream_nodes.html 
  GEO_drug_targets_KEGG_i = GEO_drug_targets_KEGG %>% .[. %in% names(V(igraph))]
  if(length(GEO_drug_targets_KEGG_i) < 1) {
    print(paste0("None of the nodes of pathway ", pathway, " are present on the graph. Skipping to the next one."))
    next
  }
  for(drug_target in GEO_drug_targets_KEGG_i) {
    print(paste0("Working on target ", drug_target, " in pathway ", pathway, "."))
    
    w = V(igraph)[drug_target]
     possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      downstream_nodes = V(igraph)[get_downstream_nodes(igraph, w)]
    }, error=function(cond) {
      message(paste0("There was a problem getting the nodes downstream from target ", drug_target, ":"))
      message(cond)
    }
  )
    if(inherits(possibleError, "error") | !exists("downstream_nodes")) {
      print(paste0("Skipping drug target ", drug_target, "."))
      next
    }
    
    # Check if there are any downstream nodes. If not, move on to the next target.
    if(length(downstream_nodes) < 1) {
      print(paste0("Target ", drug_target, " has no downstream nodes. Moving on!"))
      next
    }
    downstream_node_names = downstream_nodes %>% names() # %>% paste(collapse=",")
    
    # Determine the effect of the target on each node? (I.e. upregulated or downregulated. ... This is important, but can we do it without having to do it manually??)
    # Get all the edges between the target and the downstream nodes. 
    #all_paths = all_simple_paths(igraph, from = V(igraph)[drug_target], to = downstream_nodes, mode = "out")
    possibleError = tryCatch( # https://stackoverflow.com/a/8094059, https://stackoverflow.com/a/12195574
    {
      all_paths = shortest_paths(igraph, from = V(igraph)[drug_target], to = downstream_nodes, weights = rep(1, length(unlist(kegg_edge_weights)))) %>% .$vpath # Have to set the weights to all be positive; otherwise, the algorithm doesn't work. Using all_simple_paths returns all possible paths. 
    }, error=function(cond) {
      message(paste0("There was a problem getting the shortest paths from target ", drug_target, ":"))
      message(cond)
    }
  )
    if(inherits(possibleError, "error") | !exists("all_paths")) {
      print(paste0("Skipping drug target ", drug_target, "."))
      next
    }

    effects = c()
    for(i in 1:length(all_paths)) {
      # Get path i. 
      path = all_paths[[i]] %>% names()
      # Because of the way get.edge.ids works, we need to duplicate all inner vertices (vertices that are not the first or last) in path in order to get all the edges that make up the path.
      if(length(path) > 2) {
        vertices = c(path[1], rep(path[2:(length(path)-1)], each = 2), path[length(path)])
      } else {
        vertices = path
      }
      # Get the IDs of the edges connecting vertices in the path. 
      edge_ids = get.edge.ids(igraph, vertices, directed = TRUE, error = FALSE,
  multi = FALSE)
      # Get the weights of those edges.
      weights = edge_attr(igraph, "weight", index = E(igraph)[edge_ids])
      # Multiply them together. 
      # https://stackoverflow.com/a/62561005
      effect = ifelse(prod(weights) < 0, -1, 1)
      # If < 0, then -1; if > 0, then 1.
      effects = c(effects, effect)
    }
    
    # Add to the table. 
    GEO_drug_target_downstream_node_data_KEGG = rbind(GEO_drug_target_downstream_node_data_KEGG, data.frame(
    Pathway = rep(pathway, length(downstream_nodes)),
    Target = rep(drug_target, length(downstream_nodes)),
    DownstreamNodes = names(downstream_nodes),
    Effects = effects,
    stringsAsFactors = F
    ))
    
    # Remove old "downstream_nodes" and "all_paths" so that the error checks can be triggered properly.
    rm(downstream_nodes, all_paths)
  }
    
}

# Save.
GEO_drug_target_downstream_node_data_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_downstream_node_data", processing_stage = "Processed")
write.table(GEO_drug_target_downstream_node_data_KEGG, GEO_drug_target_downstream_node_data_KEGG_filename, sep=",", row.names=F)
```

#### Transcription factors and their targets for each pathway
```{r}
GEO_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
GEO_drug_target_pathway_data_KEGG = read.csv(GEO_drug_target_pathway_data_KEGG_filename)

KEGG_pathways_complete_filename = paste0(folder_generator(data_dir, data_source = "GSEA-MSigDB", data_type = "Misc", processing_stage = "Raw"), "c2.cp.kegg.v7.1.symbols.gmt")
KEGG_pathways_complete = GSA.read.gmt(KEGG_pathways_complete_filename)
GEO_drug_target_downstream_node_data_KEGG = read.csv(GEO_drug_target_downstream_node_data_KEGG_filename)

# Load the TRRUST data. 
TRRUST_data_filename = paste0(folder_generator(data_dir, data_source = "TRRUST", data_type = "Misc", processing_stage = "Raw"), "trrust_rawdata.human.tsv")
TRRUST_data = read.table(TRRUST_data_filename, header = F)
colnames(TRRUST_data) = c("TF", "Target",	"ModeOfRegulation",	"PMID")
# Exclude all unknown interactions from the TRRUST data. 
TRRUST_data = TRRUST_data %>% dplyr::filter(ModeOfRegulation != "Unknown")

# For each unique pathway in GEO_drug_target_pathway_data_KEGG, get the transcription factors from that pathway. 
GEO_drug_target_txnal_target_data_KEGG_TRRUST = data.frame(
  Pathway = character(),
  DrugTarget = character(),
  TFentrez = character(),
  TFsymbol = character(),
  TranscriptionalTarget = character(),
  ModeOfRegulation = character(),
  stringsAsFactors = F
)

for(pathway in unique(GEO_drug_target_pathway_data_KEGG$PathwayID)) {
  # Get the drug targets in that pathway. 
  pathway_drug_targets = GEO_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Pathway==pathway) %>% dplyr::select(Target) %>% unlist() %>% unique()
  
  for(drug_target in pathway_drug_targets) {
    # Get the nodes downstream of that target. Remove any nodes that are not genes. 
    downstream_nodes = GEO_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Pathway==pathway & Target == drug_target & regexPipes::grepl(.$DownstreamNodes, "hsa\\:")) %>% dplyr::select(DownstreamNodes, Effects) %>% distinct()
  
    if(nrow(downstream_nodes) < 1) {
      print(paste0("Target ", drug_target, " has no downstream gene nodes. Skipping this one!"))
      next
    }
    
    # Convert the downstream nodes from their KEGG ID to their gene name. 
    hs = org.Hs.eg.db
    keys = downstream_nodes$DownstreamNodes %>% unlist() %>% regexPipes::gsub("hsa\\:", "")
    x = AnnotationDbi::select(hs, 
               keys = keys,
               columns = c("SYMBOL", "ENTREZID"),
               keytype = "ENTREZID") %>% .[complete.cases(.),]
    # We will be back-converting from symbols to ENTREZ IDs, so make sure that each symbol maps to only ONE ENTREZ ID. 
    # ... Which, come to think of it, shouldn't be a problem, since we started out with ENTREZ IDs, and I don't think KEGG had duplicates. ... 
  
    # Get the transcription factors.
    # https://stackoverflow.com/questions/10586652/r-preserve-order-when-using-matching-operators-in
    tfs = intersect(unique(TRRUST_data$TF), x$SYMBOL)
    if(length(tfs) < 1) {
      print(paste0("Target ", drug_target, " has no downstream transcription factors. Skipping this one!"))
      next
    }
    
    tfs_entrez = x %>% .[match(tfs, .$SYMBOL),] %>% .$ENTREZID %>% paste0("hsa:", .)
    names(tfs_entrez) = tfs
  
    # Get the targets of those transcription factors.
    for(tf in tfs) {
      txn_target = TRRUST_data %>% dplyr::filter(TF==tf) %>% dplyr::select(TF, Target, ModeOfRegulation)
    
      # Add to the table if there are any transcriptional targets. 
      GEO_drug_target_txnal_target_data_KEGG_TRRUST = rbind(GEO_drug_target_txnal_target_data_KEGG_TRRUST, data.frame(
        Pathway = rep(pathway, nrow(txn_target)),
        DrugTarget = rep(drug_target, nrow(txn_target)),
        TFentrez = rep(tfs_entrez[tf], nrow(txn_target)),
        TFsymbol = txn_target$TF,
        TranscriptionalTarget = txn_target$Target,
        ModeOfRegulation = txn_target$ModeOfRegulation,
        stringsAsFactors = F
        ))
    }
    
  }
  
}

# Add an effect column.
GEO_drug_target_txnal_target_data_KEGG_TRRUST$Effect = ifelse(GEO_drug_target_txnal_target_data_KEGG_TRRUST$ModeOfRegulation=="Repression", -1, 1)

# Save.
GEO_drug_target_txnal_target_data_KEGG_TRRUST_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG_TRRUST", extension = ".csv", additional_info = "target_txnal_target_data", processing_stage = "Processed")
write.table(GEO_drug_target_txnal_target_data_KEGG_TRRUST, GEO_drug_target_txnal_target_data_KEGG_TRRUST_filename, sep=",", row.names=F)
```

#### Final effects of drugs on downstream targets
Combine the data from GEO_drug_target_data_KEGG, drug_genes_table and GEO_drug_target_txnal_target_data_KEGG_TRRUST (i.e. multiply the effects) to get the final effect of the drug on each of its transcriptional targets. 
```{r}
GEO_drug_target_txnal_target_data_KEGG_TRRUST_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG_TRRUST", extension = ".csv", additional_info = "target_txnal_target_data", processing_stage = "Processed")
GEO_drug_target_pathway_data_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_pathway_data", processing_stage = "Processed")
GEO_drug_target_downstream_node_data_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_downstream_node_data", processing_stage = "Processed")
GEO_drug_target_data_KEGG_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "KEGG", extension = ".csv", additional_info = "target_data", processing_stage = "Processed")

GEO_drug_target_txnal_target_data_KEGG_TRRUST = read.csv(GEO_drug_target_txnal_target_data_KEGG_TRRUST_filename)
GEO_drug_target_pathway_data_KEGG = read.csv(GEO_drug_target_pathway_data_KEGG_filename)
GEO_drug_target_downstream_node_data_KEGG = read.csv(GEO_drug_target_downstream_node_data_KEGG_filename)
GEO_drug_target_data_KEGG = read.csv(GEO_drug_target_data_KEGG_filename)

GEO_drug_target_data_TRRUST = data.frame(
  Drug = character(),
  Target = character(),
  Effect = numeric(),
  stringsAsFactors = F
)

# Indirect targets. 
for(drug in unique(GEO_drug_target_data_KEGG$Drug)) {
  # For each drug, get its corresponding targets from GEO_drug_target_data_KEGG. 
  drug_targets = GEO_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist() %>% paste0("hsa:", .)
  
  # Get the pathways this drug is involved in. We are going to restrict transcriptional effects to the pathways the drug is known to be involved in. (E.g., if drug A targets EGFR, even if EGFR is involved in multiple pathways, we will only consider the pathways that drug A has listed in KEGG.)
  drug_pathways = GEO_drug_target_pathway_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(PathwayID) %>% unlist() %>% unique
  
  for(drug_target in drug_targets) {
    # Get the effect of the drug on this target.
    target_edited = drug_target %>% regexPipes::gsub("hsa\\:", "")
    fx_drug_on_target = GEO_drug_target_data_KEGG %>% dplyr::filter(Drug==drug & Target==target_edited) %>% dplyr::select(Effect) %>% unlist()
    
    # For each drug target, get the TFs that are downstream of that target. 
    tfs = GEO_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & Pathway %in% drug_pathways) %>% dplyr::select(TFentrez) %>% unlist() %>% as.character() %>% unique() # Pathway %in% drug_pathways ensures that only the downstream TFs in the pathways associated with that drug are chosen.
    
    # For each TF, get the downstream transcriptional targets from GEO_drug_target_txnal_target_data_KEGG_TRRUST.
    for(tf in tfs) {
      txn_targets = GEO_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & Pathway %in% drug_pathways & TFentrez==tf) %>% dplyr::select(TranscriptionalTarget) %>% unlist() %>% as.character() %>% unique() # Pathway %in% drug_pathways ensures that only the downstream txnal targets in the pathways associated with that drug are chosen.
    
      # For each downstream transcriptional target, calculate the final effect. 
      # Use GEO_drug_target_downstream_node_data_KEGG.
      for(txn_target in txn_targets) {
        print(paste0("Calculating effect of drug ", drug, " on target ", txn_target, "."))
        # Final effect = effect of drug on target (fx_drug_on_target, already calculated in outer loop) * effect of drug target on TF (from GEO_drug_target_downstream_node_data_KEGG) (fx_drug_target_on_tf) * effect of TF on transcriptional target (from GEO_drug_target_txnal_target_data_KEGG_TRRUST) (fx_tf_on_txn_target).
        fx_drug_target_on_tf = GEO_drug_target_downstream_node_data_KEGG %>% dplyr::filter(Target == drug_target & DownstreamNodes == tf & Pathway %in% drug_pathways) %>% dplyr::select(Effects) %>% unlist()
        fx_tf_on_txn_target = GEO_drug_target_txnal_target_data_KEGG_TRRUST %>% dplyr::filter(DrugTarget==drug_target & TFentrez==tf & TranscriptionalTarget == txn_target & Pathway %in% drug_pathways) %>% dplyr::select(Effect) %>% unlist()
        final_effect = prod(fx_drug_on_target, fx_drug_target_on_tf, fx_tf_on_txn_target)
        
        GEO_drug_target_data_TRRUST = rbind(GEO_drug_target_data_TRRUST, data.frame(
          Drug = drug,
          Target = txn_target,
          Effect = final_effect,
          stringsAsFactors = F
          ))
        }
    }
  }
}

# Direct targets. 
colnames(GEO_drug_target_data_TRRUST)[3] = "Effect"
hs = org.Hs.eg.db
keys = unique(GEO_drug_target_data_KEGG$Target) %>% as.character()
x = AnnotationDbi::select(hs, 
           keys = keys,
           columns = c("SYMBOL", "ENTREZID"),
           keytype = "ENTREZID") %>% .[complete.cases(.),] %>% distinct()
for(drug in unique(GEO_drug_target_data_KEGG$Drug)) {
  # For each drug, get its corresponding targets and effects from GEO_drug_target_data_KEGG. 
  drug_targets = GEO_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Target) %>% unlist()
  final_effects = GEO_drug_target_data_KEGG %>% dplyr::filter(Drug==drug) %>% dplyr::select(Effect) %>% unlist()
  
  # Convert to gene symbol.
  #keggGet(kegg_drug_id) %>% .[[1]] %>% .$NAME %>% str_split(",") %>% .[[1]] %>% .[1]
  a = x$ENTREZID
  b = x$SYMBOL
  target_ids = b[match(drug_targets, a)]
  # Alternative: 
  #target_ids = c()
  #for(target in unique(GEO_drug_target_data_KEGG$Target)) {
  #  print(paste0("Getting gene ID for target ", target, "."))
  #  target_ids = c(target_ids, keggGet(paste0("hsa:",target)) %>% .[[1]] %>% .$NAME %>% str_split(",") %>% .[[1]] %>% .[1])
  #}
  
  # Add to GEO_drug_target_data_TRRUST. 
  GEO_drug_target_data_TRRUST = rbind(GEO_drug_target_data_TRRUST, data.frame(
          Drug = rep(drug, length(final_effects)),
          Target = target_ids,
          Effect = final_effects,
          stringsAsFactors = F
          ))
}

# Keep only unique rows.
GEO_drug_target_data_TRRUST = GEO_drug_target_data_TRRUST %>% distinct()

# Split the dataframe into a list, to match the CTD drug-target-data format and the format that most of the calcNetworkScores() functions use. 
GEO_drug_target_data_TRRUST = split(GEO_drug_target_data_TRRUST , f = GEO_drug_target_data_TRRUST$Drug)

# Remove all entries in the list whose tables have 0 rows. (28 June 2021.)
for(entry in names(GEO_drug_target_data_TRRUST)) {
  if(nrow(GEO_drug_target_data_TRRUST[[entry]]) < 1) {
    GEO_drug_target_data_TRRUST[[entry]] = NULL
  } 
}

# Save.
GEO_drug_target_data_TRRUST_filename = filename_generator(data_dir, data_source = "GEO", data_type = "Drugs", data_set = "TRRUST", extension = ".rds", additional_info = "target_data", processing_stage = "Processed")
saveRDS(GEO_drug_target_data_TRRUST, GEO_drug_target_data_TRRUST_filename)
#write.table(GEO_drug_target_data_TRRUST, paste0(data_dir, "Processed_data/GEO/GEO_kegg_drug_final_effects.csv"), sep = ",", row.names = F)
```
